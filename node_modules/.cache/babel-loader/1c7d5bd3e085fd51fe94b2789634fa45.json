{"ast":null,"code":"'use strict';\n\nfunction _worker_threads() {\n  const data = require('worker_threads');\n\n  _worker_threads = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _types = require('../types');\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nlet file = null;\nlet setupArgs = [];\nlet initialized = false;\n/**\n * This file is a small bootstrapper for workers. It sets up the communication\n * between the worker and the parent process, interpreting parent messages and\n * sending results back.\n *\n * The file loaded will be lazily initialized the first time any of the workers\n * is called. This is done for optimal performance: if the farm is initialized,\n * but no call is made to it, child Node processes will be consuming the least\n * possible amount of memory.\n *\n * If an invalid message is detected, the child will exit (by throwing) with a\n * non-zero exit code.\n */\n\nconst messageListener = request => {\n  switch (request[0]) {\n    case _types.CHILD_MESSAGE_INITIALIZE:\n      const init = request;\n      file = init[2];\n      setupArgs = request[3];\n      process.env.JEST_WORKER_ID = request[4];\n      break;\n\n    case _types.CHILD_MESSAGE_CALL:\n      const call = request;\n      execMethod(call[2], call[3]);\n      break;\n\n    case _types.CHILD_MESSAGE_END:\n      end();\n      break;\n\n    default:\n      throw new TypeError(`Unexpected request from parent process: ${request[0]}`);\n  }\n};\n\n_worker_threads().parentPort.on('message', messageListener);\n\nfunction reportSuccess(result) {\n  if (_worker_threads().isMainThread) {\n    throw new Error('Child can only be used on a forked process');\n  }\n\n  _worker_threads().parentPort.postMessage([_types.PARENT_MESSAGE_OK, result]);\n}\n\nfunction reportClientError(error) {\n  return reportError(error, _types.PARENT_MESSAGE_CLIENT_ERROR);\n}\n\nfunction reportInitializeError(error) {\n  return reportError(error, _types.PARENT_MESSAGE_SETUP_ERROR);\n}\n\nfunction reportError(error, type) {\n  if (_worker_threads().isMainThread) {\n    throw new Error('Child can only be used on a forked process');\n  }\n\n  if (error == null) {\n    error = new Error('\"null\" or \"undefined\" thrown');\n  }\n\n  _worker_threads().parentPort.postMessage([type, error.constructor && error.constructor.name, error.message, error.stack, typeof error === 'object' ? { ...error\n  } : error]);\n}\n\nfunction end() {\n  const main = require(file);\n\n  if (!main.teardown) {\n    exitProcess();\n    return;\n  }\n\n  execFunction(main.teardown, main, [], exitProcess, exitProcess);\n}\n\nfunction exitProcess() {\n  // Clean up open handles so the worker ideally exits gracefully\n  _worker_threads().parentPort.removeListener('message', messageListener);\n}\n\nfunction execMethod(method, args) {\n  const main = require(file);\n\n  let fn;\n\n  if (method === 'default') {\n    fn = main.__esModule ? main['default'] : main;\n  } else {\n    fn = main[method];\n  }\n\n  function execHelper() {\n    execFunction(fn, main, args, reportSuccess, reportClientError);\n  }\n\n  if (initialized || !main.setup) {\n    execHelper();\n    return;\n  }\n\n  initialized = true;\n  execFunction(main.setup, main, setupArgs, execHelper, reportInitializeError);\n}\n\nconst isPromise = obj => !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';\n\nfunction execFunction(fn, ctx, args, onResult, onError) {\n  let result;\n\n  try {\n    result = fn.apply(ctx, args);\n  } catch (err) {\n    onError(err);\n    return;\n  }\n\n  if (isPromise(result)) {\n    result.then(onResult, onError);\n  } else {\n    onResult(result);\n  }\n}","map":{"version":3,"names":["_worker_threads","data","require","_types","file","setupArgs","initialized","messageListener","request","CHILD_MESSAGE_INITIALIZE","init","process","env","JEST_WORKER_ID","CHILD_MESSAGE_CALL","call","execMethod","CHILD_MESSAGE_END","end","TypeError","parentPort","on","reportSuccess","result","isMainThread","Error","postMessage","PARENT_MESSAGE_OK","reportClientError","error","reportError","PARENT_MESSAGE_CLIENT_ERROR","reportInitializeError","PARENT_MESSAGE_SETUP_ERROR","type","constructor","name","message","stack","main","teardown","exitProcess","execFunction","removeListener","method","args","fn","__esModule","execHelper","setup","isPromise","obj","then","ctx","onResult","onError","apply","err"],"sources":["/Users/wonjaelee/Desktop/final/node_modules/jest-runtime/node_modules/jest-worker/build/workers/threadChild.js"],"sourcesContent":["'use strict';\n\nfunction _worker_threads() {\n  const data = require('worker_threads');\n\n  _worker_threads = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _types = require('../types');\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nlet file = null;\nlet setupArgs = [];\nlet initialized = false;\n/**\n * This file is a small bootstrapper for workers. It sets up the communication\n * between the worker and the parent process, interpreting parent messages and\n * sending results back.\n *\n * The file loaded will be lazily initialized the first time any of the workers\n * is called. This is done for optimal performance: if the farm is initialized,\n * but no call is made to it, child Node processes will be consuming the least\n * possible amount of memory.\n *\n * If an invalid message is detected, the child will exit (by throwing) with a\n * non-zero exit code.\n */\n\nconst messageListener = request => {\n  switch (request[0]) {\n    case _types.CHILD_MESSAGE_INITIALIZE:\n      const init = request;\n      file = init[2];\n      setupArgs = request[3];\n      process.env.JEST_WORKER_ID = request[4];\n      break;\n\n    case _types.CHILD_MESSAGE_CALL:\n      const call = request;\n      execMethod(call[2], call[3]);\n      break;\n\n    case _types.CHILD_MESSAGE_END:\n      end();\n      break;\n\n    default:\n      throw new TypeError(\n        `Unexpected request from parent process: ${request[0]}`\n      );\n  }\n};\n\n_worker_threads().parentPort.on('message', messageListener);\n\nfunction reportSuccess(result) {\n  if (_worker_threads().isMainThread) {\n    throw new Error('Child can only be used on a forked process');\n  }\n\n  _worker_threads().parentPort.postMessage([_types.PARENT_MESSAGE_OK, result]);\n}\n\nfunction reportClientError(error) {\n  return reportError(error, _types.PARENT_MESSAGE_CLIENT_ERROR);\n}\n\nfunction reportInitializeError(error) {\n  return reportError(error, _types.PARENT_MESSAGE_SETUP_ERROR);\n}\n\nfunction reportError(error, type) {\n  if (_worker_threads().isMainThread) {\n    throw new Error('Child can only be used on a forked process');\n  }\n\n  if (error == null) {\n    error = new Error('\"null\" or \"undefined\" thrown');\n  }\n\n  _worker_threads().parentPort.postMessage([\n    type,\n    error.constructor && error.constructor.name,\n    error.message,\n    error.stack,\n    typeof error === 'object' ? {...error} : error\n  ]);\n}\n\nfunction end() {\n  const main = require(file);\n\n  if (!main.teardown) {\n    exitProcess();\n    return;\n  }\n\n  execFunction(main.teardown, main, [], exitProcess, exitProcess);\n}\n\nfunction exitProcess() {\n  // Clean up open handles so the worker ideally exits gracefully\n  _worker_threads().parentPort.removeListener('message', messageListener);\n}\n\nfunction execMethod(method, args) {\n  const main = require(file);\n\n  let fn;\n\n  if (method === 'default') {\n    fn = main.__esModule ? main['default'] : main;\n  } else {\n    fn = main[method];\n  }\n\n  function execHelper() {\n    execFunction(fn, main, args, reportSuccess, reportClientError);\n  }\n\n  if (initialized || !main.setup) {\n    execHelper();\n    return;\n  }\n\n  initialized = true;\n  execFunction(main.setup, main, setupArgs, execHelper, reportInitializeError);\n}\n\nconst isPromise = obj =>\n  !!obj &&\n  (typeof obj === 'object' || typeof obj === 'function') &&\n  typeof obj.then === 'function';\n\nfunction execFunction(fn, ctx, args, onResult, onError) {\n  let result;\n\n  try {\n    result = fn.apply(ctx, args);\n  } catch (err) {\n    onError(err);\n    return;\n  }\n\n  if (isPromise(result)) {\n    result.then(onResult, onError);\n  } else {\n    onResult(result);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}