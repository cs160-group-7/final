{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _module() {\n  const data = _interopRequireDefault(require('module'));\n\n  _module = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _url() {\n  const data = require('url');\n\n  _url = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _vm() {\n  const data = require('vm');\n\n  _vm = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _cjsModuleLexer() {\n  const data = require('cjs-module-lexer');\n\n  _cjsModuleLexer = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _collectV8Coverage() {\n  const data = require('collect-v8-coverage');\n\n  _collectV8Coverage = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _execa() {\n  const data = _interopRequireDefault(require('execa'));\n\n  _execa = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fs() {\n  const data = _interopRequireWildcard(require('graceful-fs'));\n\n  fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _slash() {\n  const data = _interopRequireDefault(require('slash'));\n\n  _slash = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _stripBom() {\n  const data = _interopRequireDefault(require('strip-bom'));\n\n  _stripBom = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _transform() {\n  const data = require('@jest/transform');\n\n  _transform = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestHasteMap() {\n  const data = _interopRequireDefault(require('jest-haste-map'));\n\n  _jestHasteMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRegexUtil() {\n  const data = require('jest-regex-util');\n\n  _jestRegexUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestResolve() {\n  const data = _interopRequireDefault(require('jest-resolve'));\n\n  _jestResolve = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSnapshot() {\n  const data = require('jest-snapshot');\n\n  _jestSnapshot = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _helpers = require('./helpers');\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst esmIsAvailable = typeof _vm().SourceTextModule === 'function';\nconst dataURIRegex = /^data:(?<mime>text\\/javascript|application\\/json|application\\/wasm)(?:;(?<encoding>charset=utf-8|base64))?,(?<code>.*)$/;\nconst defaultTransformOptions = {\n  isInternalModule: false,\n  supportsDynamicImport: esmIsAvailable,\n  supportsExportNamespaceFrom: false,\n  supportsStaticESM: false,\n  supportsTopLevelAwait: false\n}; // These are modules that we know\n// * are safe to require from the outside (not stateful, not prone to errors passing in instances from different realms), and\n// * take sufficiently long to require to warrant an optimization.\n// When required from the outside, they use the worker's require cache and are thus\n// only loaded once per worker, not once per test file.\n// Use /benchmarks/test-file-overhead to measure the impact.\n// Note that this only applies when they are required in an internal context;\n// users who require one of these modules in their tests will still get the module from inside the VM.\n// Prefer listing a module here only if it is impractical to use the jest-resolve-outside-vm-option where it is required,\n// e.g. because there are many require sites spread across the dependency graph.\n\nconst INTERNAL_MODULE_REQUIRE_OUTSIDE_OPTIMIZED_MODULES = new Set(['chalk']);\nconst JEST_RESOLVE_OUTSIDE_VM_OPTION = Symbol.for('jest-resolve-outside-vm-option');\nconst testTimeoutSymbol = Symbol.for('TEST_TIMEOUT_SYMBOL');\nconst retryTimesSymbol = Symbol.for('RETRY_TIMES');\nconst logErrorsBeforeRetrySymbol = Symbol.for('LOG_ERRORS_BEFORE_RETRY');\nconst NODE_MODULES = `${path().sep}node_modules${path().sep}`;\n\nconst getModuleNameMapper = config => {\n  if (Array.isArray(config.moduleNameMapper) && config.moduleNameMapper.length) {\n    return config.moduleNameMapper.map(_ref => {\n      let [regex, moduleName] = _ref;\n      return {\n        moduleName,\n        regex: new RegExp(regex)\n      };\n    });\n  }\n\n  return null;\n};\n\nconst unmockRegExpCache = new WeakMap();\nconst EVAL_RESULT_VARIABLE = 'Object.<anonymous>';\nconst runtimeSupportsVmModules = typeof _vm().SyntheticModule === 'function';\n\nconst supportsTopLevelAwait = runtimeSupportsVmModules && (() => {\n  try {\n    // eslint-disable-next-line no-new\n    new (_vm().SourceTextModule)('await Promise.resolve()');\n    return true;\n  } catch {\n    return false;\n  }\n})();\n\nconst supportsNodeColonModulePrefixInRequire = (() => {\n  try {\n    require('node:fs');\n\n    return true;\n  } catch {\n    return false;\n  }\n})();\n\nconst supportsNodeColonModulePrefixInImport = (() => {\n  const {\n    stdout\n  } = _execa().default.sync('node', ['--eval', 'import(\"node:fs\").then(() => console.log(true), () => console.log(false));'], {\n    reject: false\n  });\n\n  return stdout === 'true';\n})();\n\nclass Runtime {\n  _cacheFS;\n  _config;\n  _coverageOptions;\n  _currentlyExecutingModulePath;\n  _environment;\n  _explicitShouldMock;\n  _explicitShouldMockModule;\n  _fakeTimersImplementation;\n  _internalModuleRegistry;\n  _isCurrentlyExecutingManualMock;\n  _mainModule;\n  _mockFactories;\n  _mockMetaDataCache;\n  _mockRegistry;\n  _isolatedMockRegistry;\n  _moduleMockRegistry;\n  _moduleMockFactories;\n  _moduleMocker;\n  _isolatedModuleRegistry;\n  _moduleRegistry;\n  _esmoduleRegistry;\n  _cjsNamedExports;\n  _esmModuleLinkingMap;\n  _testPath;\n  _resolver;\n  _shouldAutoMock;\n  _shouldMockModuleCache;\n  _shouldUnmockTransitiveDependenciesCache;\n  _sourceMapRegistry;\n  _scriptTransformer;\n  _fileTransforms;\n  _fileTransformsMutex;\n  _v8CoverageInstrumenter;\n  _v8CoverageResult;\n  _v8CoverageSources;\n  _transitiveShouldMock;\n  _unmockList;\n  _virtualMocks;\n  _virtualModuleMocks;\n  _moduleImplementation;\n  jestObjectCaches;\n  jestGlobals;\n  esmConditions;\n  cjsConditions;\n  isTornDown = false;\n\n  constructor(config, environment, resolver, transformer, cacheFS, coverageOptions, testPath) {\n    var _this$_environment$ex, _this$_environment$ex2, _this$_environment;\n\n    this._cacheFS = cacheFS;\n    this._config = config;\n    this._coverageOptions = coverageOptions;\n    this._currentlyExecutingModulePath = '';\n    this._environment = environment;\n    this._explicitShouldMock = new Map();\n    this._explicitShouldMockModule = new Map();\n    this._internalModuleRegistry = new Map();\n    this._isCurrentlyExecutingManualMock = null;\n    this._mainModule = null;\n    this._mockFactories = new Map();\n    this._mockRegistry = new Map();\n    this._moduleMockRegistry = new Map();\n    this._moduleMockFactories = new Map();\n    invariant(this._environment.moduleMocker, '`moduleMocker` must be set on an environment when created');\n    this._moduleMocker = this._environment.moduleMocker;\n    this._isolatedModuleRegistry = null;\n    this._isolatedMockRegistry = null;\n    this._moduleRegistry = new Map();\n    this._esmoduleRegistry = new Map();\n    this._cjsNamedExports = new Map();\n    this._esmModuleLinkingMap = new WeakMap();\n    this._testPath = testPath;\n    this._resolver = resolver;\n    this._scriptTransformer = transformer;\n    this._shouldAutoMock = config.automock;\n    this._sourceMapRegistry = new Map();\n    this._fileTransforms = new Map();\n    this._fileTransformsMutex = new Map();\n    this._virtualMocks = new Map();\n    this._virtualModuleMocks = new Map();\n    this.jestObjectCaches = new Map();\n    this._mockMetaDataCache = new Map();\n    this._shouldMockModuleCache = new Map();\n    this._shouldUnmockTransitiveDependenciesCache = new Map();\n    this._transitiveShouldMock = new Map();\n    this._fakeTimersImplementation = config.fakeTimers.legacyFakeTimers ? this._environment.fakeTimers : this._environment.fakeTimersModern;\n    this._unmockList = unmockRegExpCache.get(config);\n\n    if (!this._unmockList && config.unmockedModulePathPatterns) {\n      this._unmockList = new RegExp(config.unmockedModulePathPatterns.join('|'));\n      unmockRegExpCache.set(config, this._unmockList);\n    }\n\n    const envExportConditions = (_this$_environment$ex = (_this$_environment$ex2 = (_this$_environment = this._environment).exportConditions) === null || _this$_environment$ex2 === void 0 ? void 0 : _this$_environment$ex2.call(_this$_environment)) !== null && _this$_environment$ex !== void 0 ? _this$_environment$ex : [];\n    this.esmConditions = Array.from(new Set(['import', 'default', ...envExportConditions]));\n    this.cjsConditions = Array.from(new Set(['require', 'default', ...envExportConditions]));\n\n    if (config.automock) {\n      config.setupFiles.forEach(filePath => {\n        if (filePath.includes(NODE_MODULES)) {\n          const moduleID = this._resolver.getModuleID(this._virtualMocks, filePath, undefined, // shouldn't really matter, but in theory this will make sure the caching is correct\n          {\n            conditions: this.unstable_shouldLoadAsEsm(filePath) ? this.esmConditions : this.cjsConditions\n          });\n\n          this._transitiveShouldMock.set(moduleID, false);\n        }\n      });\n    }\n\n    this.resetModules();\n  }\n\n  static shouldInstrument = _transform().shouldInstrument;\n\n  static async createContext(config, options) {\n    (0, _jestUtil().createDirectory)(config.cacheDirectory);\n    const instance = await Runtime.createHasteMap(config, {\n      console: options.console,\n      maxWorkers: options.maxWorkers,\n      resetCache: !config.cache,\n      watch: options.watch,\n      watchman: options.watchman\n    });\n    const hasteMap = await instance.build();\n    return {\n      config,\n      hasteFS: hasteMap.hasteFS,\n      moduleMap: hasteMap.moduleMap,\n      resolver: Runtime.createResolver(config, hasteMap.moduleMap)\n    };\n  }\n\n  static createHasteMap(config, options) {\n    const ignorePatternParts = [...config.modulePathIgnorePatterns, ...(options && options.watch ? config.watchPathIgnorePatterns : []), config.cacheDirectory.startsWith(config.rootDir + path().sep) && config.cacheDirectory].filter(Boolean);\n    const ignorePattern = ignorePatternParts.length > 0 ? new RegExp(ignorePatternParts.join('|')) : undefined;\n    return _jestHasteMap().default.create({\n      cacheDirectory: config.cacheDirectory,\n      computeSha1: config.haste.computeSha1,\n      console: options === null || options === void 0 ? void 0 : options.console,\n      dependencyExtractor: config.dependencyExtractor,\n      enableSymlinks: config.haste.enableSymlinks,\n      extensions: [_jestSnapshot().EXTENSION].concat(config.moduleFileExtensions),\n      forceNodeFilesystemAPI: config.haste.forceNodeFilesystemAPI,\n      hasteImplModulePath: config.haste.hasteImplModulePath,\n      hasteMapModulePath: config.haste.hasteMapModulePath,\n      id: config.id,\n      ignorePattern,\n      maxWorkers: (options === null || options === void 0 ? void 0 : options.maxWorkers) || 1,\n      mocksPattern: (0, _jestRegexUtil().escapePathForRegex)(`${path().sep}__mocks__${path().sep}`),\n      platforms: config.haste.platforms || ['ios', 'android'],\n      resetCache: options === null || options === void 0 ? void 0 : options.resetCache,\n      retainAllFiles: config.haste.retainAllFiles || false,\n      rootDir: config.rootDir,\n      roots: config.roots,\n      throwOnModuleCollision: config.haste.throwOnModuleCollision,\n      useWatchman: options === null || options === void 0 ? void 0 : options.watchman,\n      watch: options === null || options === void 0 ? void 0 : options.watch\n    });\n  }\n\n  static createResolver(config, moduleMap) {\n    return new (_jestResolve().default)(moduleMap, {\n      defaultPlatform: config.haste.defaultPlatform,\n      extensions: config.moduleFileExtensions.map(extension => `.${extension}`),\n      hasCoreModules: true,\n      moduleDirectories: config.moduleDirectories,\n      moduleNameMapper: getModuleNameMapper(config),\n      modulePaths: config.modulePaths,\n      platforms: config.haste.platforms,\n      resolver: config.resolver,\n      rootDir: config.rootDir\n    });\n  }\n\n  static async runCLI() {\n    throw new Error('The jest-runtime CLI has been moved into jest-repl');\n  }\n\n  static getCLIOptions() {\n    throw new Error('The jest-runtime CLI has been moved into jest-repl');\n  } // unstable as it should be replaced by https://github.com/nodejs/modules/issues/393, and we don't want people to use it\n\n\n  unstable_shouldLoadAsEsm(path) {\n    return _jestResolve().default.unstable_shouldLoadAsEsm(path, this._config.extensionsToTreatAsEsm);\n  } // not async _now_, but transform will be\n\n\n  async loadEsmModule(modulePath) {\n    let query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    const cacheKey = modulePath + query;\n\n    if (this._fileTransformsMutex.has(cacheKey)) {\n      await this._fileTransformsMutex.get(cacheKey);\n    }\n\n    if (!this._esmoduleRegistry.has(cacheKey)) {\n      invariant(typeof this._environment.getVmContext === 'function', 'ES Modules are only supported if your test environment has the `getVmContext` function');\n\n      const context = this._environment.getVmContext();\n\n      invariant(context, 'Test environment has been torn down');\n      let transformResolve;\n      let transformReject;\n\n      this._fileTransformsMutex.set(cacheKey, new Promise((resolve, reject) => {\n        transformResolve = resolve;\n        transformReject = reject;\n      }));\n\n      invariant(transformResolve && transformReject, 'Promise initialization should be sync - please report this bug to Jest!');\n\n      if (this._resolver.isCoreModule(modulePath)) {\n        const core = this._importCoreModule(modulePath, context);\n\n        this._esmoduleRegistry.set(cacheKey, core);\n\n        transformResolve();\n        return core;\n      }\n\n      const transformedCode = await this.transformFileAsync(modulePath, {\n        isInternalModule: false,\n        supportsDynamicImport: true,\n        supportsExportNamespaceFrom: true,\n        supportsStaticESM: true,\n        supportsTopLevelAwait\n      });\n\n      try {\n        const module = new (_vm().SourceTextModule)(transformedCode, {\n          context,\n          identifier: modulePath,\n          importModuleDynamically: async (specifier, referencingModule) => {\n            invariant(runtimeSupportsVmModules, 'You need to run with a version of node that supports ES Modules in the VM API. See https://jestjs.io/docs/ecmascript-modules');\n            const module = await this.resolveModule(specifier, referencingModule.identifier, referencingModule.context);\n            return this.linkAndEvaluateModule(module);\n          },\n          initializeImportMeta: meta => {\n            meta.url = (0, _url().pathToFileURL)(modulePath).href;\n            let jest = this.jestObjectCaches.get(modulePath);\n\n            if (!jest) {\n              jest = this._createJestObjectFor(modulePath);\n              this.jestObjectCaches.set(modulePath, jest);\n            }\n\n            meta.jest = jest;\n          }\n        });\n        invariant(!this._esmoduleRegistry.has(cacheKey), `Module cache already has entry ${cacheKey}. This is a bug in Jest, please report it!`);\n\n        this._esmoduleRegistry.set(cacheKey, module);\n\n        transformResolve();\n      } catch (error) {\n        transformReject(error);\n        throw error;\n      }\n    }\n\n    const module = this._esmoduleRegistry.get(cacheKey);\n\n    invariant(module, 'Module cache does not contain module. This is a bug in Jest, please open up an issue');\n    return module;\n  }\n\n  async resolveModule(specifier, referencingIdentifier, context) {\n    if (this.isTornDown) {\n      this._logFormattedReferenceError('You are trying to `import` a file after the Jest environment has been torn down.');\n\n      process.exitCode = 1; // @ts-expect-error - exiting\n\n      return;\n    }\n\n    if (specifier === '@jest/globals') {\n      const fromCache = this._esmoduleRegistry.get('@jest/globals');\n\n      if (fromCache) {\n        return fromCache;\n      }\n\n      const globals = this.getGlobalsForEsm(referencingIdentifier, context);\n\n      this._esmoduleRegistry.set('@jest/globals', globals);\n\n      return globals;\n    }\n\n    if (specifier.startsWith('data:')) {\n      if (await this._shouldMockModule(referencingIdentifier, specifier, this._explicitShouldMockModule, {\n        conditions: this.esmConditions\n      })) {\n        return this.importMock(referencingIdentifier, specifier, context);\n      }\n\n      const fromCache = this._esmoduleRegistry.get(specifier);\n\n      if (fromCache) {\n        return fromCache;\n      }\n\n      const match = specifier.match(dataURIRegex);\n\n      if (!match || !match.groups) {\n        throw new Error('Invalid data URI');\n      }\n\n      const mime = match.groups.mime;\n\n      if (mime === 'application/wasm') {\n        throw new Error('WASM is currently not supported');\n      }\n\n      const encoding = match.groups.encoding;\n      let code = match.groups.code;\n\n      if (!encoding || encoding === 'charset=utf-8') {\n        code = decodeURIComponent(code);\n      } else if (encoding === 'base64') {\n        code = Buffer.from(code, 'base64').toString();\n      } else {\n        throw new Error(`Invalid data URI encoding: ${encoding}`);\n      }\n\n      let module;\n\n      if (mime === 'application/json') {\n        module = new (_vm().SyntheticModule)(['default'], function () {\n          const obj = JSON.parse(code); // @ts-expect-error: TS doesn't know what `this` is\n\n          this.setExport('default', obj);\n        }, {\n          context,\n          identifier: specifier\n        });\n      } else {\n        module = new (_vm().SourceTextModule)(code, {\n          context,\n          identifier: specifier,\n          importModuleDynamically: async (specifier, referencingModule) => {\n            invariant(runtimeSupportsVmModules, 'You need to run with a version of node that supports ES Modules in the VM API. See https://jestjs.io/docs/ecmascript-modules');\n            const module = await this.resolveModule(specifier, referencingModule.identifier, referencingModule.context);\n            return this.linkAndEvaluateModule(module);\n          },\n\n          initializeImportMeta(meta) {\n            // no `jest` here as it's not loaded in a file\n            meta.url = specifier;\n          }\n\n        });\n      }\n\n      this._esmoduleRegistry.set(specifier, module);\n\n      return module;\n    }\n\n    if (specifier.startsWith('file://')) {\n      specifier = (0, _url().fileURLToPath)(specifier);\n    }\n\n    const [path, query] = specifier.split('?');\n\n    if (await this._shouldMockModule(referencingIdentifier, path, this._explicitShouldMockModule, {\n      conditions: this.esmConditions\n    })) {\n      return this.importMock(referencingIdentifier, path, context);\n    }\n\n    const resolved = await this._resolveModule(referencingIdentifier, path, {\n      conditions: this.esmConditions\n    });\n\n    if (this._resolver.isCoreModule(resolved) || this.unstable_shouldLoadAsEsm(resolved)) {\n      return this.loadEsmModule(resolved, query);\n    }\n\n    return this.loadCjsAsEsm(referencingIdentifier, resolved, context);\n  }\n\n  async linkAndEvaluateModule(module) {\n    if (this.isTornDown) {\n      this._logFormattedReferenceError('You are trying to `import` a file after the Jest environment has been torn down.');\n\n      process.exitCode = 1;\n      return;\n    }\n\n    if (module.status === 'unlinked') {\n      // since we might attempt to link the same module in parallel, stick the promise in a weak map so every call to\n      // this method can await it\n      this._esmModuleLinkingMap.set(module, module.link((specifier, referencingModule) => this.resolveModule(specifier, referencingModule.identifier, referencingModule.context)));\n    }\n\n    await this._esmModuleLinkingMap.get(module);\n\n    if (module.status === 'linked') {\n      await module.evaluate();\n    }\n\n    return module;\n  }\n\n  async unstable_importModule(from, moduleName) {\n    invariant(runtimeSupportsVmModules, 'You need to run with a version of node that supports ES Modules in the VM API. See https://jestjs.io/docs/ecmascript-modules');\n    const [path, query] = (moduleName !== null && moduleName !== void 0 ? moduleName : '').split('?');\n    const modulePath = await this._resolveModule(from, path, {\n      conditions: this.esmConditions\n    });\n    const module = await this.loadEsmModule(modulePath, query);\n    return this.linkAndEvaluateModule(module);\n  }\n\n  loadCjsAsEsm(from, modulePath, context) {\n    // CJS loaded via `import` should share cache with other CJS: https://github.com/nodejs/modules/issues/503\n    const cjs = this.requireModuleOrMock(from, modulePath);\n    const parsedExports = this.getExportsOfCjs(modulePath);\n    const cjsExports = [...parsedExports].filter(exportName => {\n      // we don't wanna respect any exports _named_ default as a named export\n      if (exportName === 'default') {\n        return false;\n      }\n\n      return Object.hasOwnProperty.call(cjs, exportName);\n    });\n    const module = new (_vm().SyntheticModule)([...cjsExports, 'default'], function () {\n      cjsExports.forEach(exportName => {\n        // @ts-expect-error: TS doesn't know what `this` is\n        this.setExport(exportName, cjs[exportName]);\n      }); // @ts-expect-error: TS doesn't know what `this` is\n\n      this.setExport('default', cjs);\n    }, {\n      context,\n      identifier: modulePath\n    });\n    return evaluateSyntheticModule(module);\n  }\n\n  async importMock(from, moduleName, context) {\n    const moduleID = await this._resolver.getModuleIDAsync(this._virtualModuleMocks, from, moduleName, {\n      conditions: this.esmConditions\n    });\n\n    if (this._moduleMockRegistry.has(moduleID)) {\n      return this._moduleMockRegistry.get(moduleID);\n    }\n\n    if (this._moduleMockFactories.has(moduleID)) {\n      const invokedFactory = await this._moduleMockFactories.get(moduleID // has check above makes this ok\n      )();\n      const module = new (_vm().SyntheticModule)(Object.keys(invokedFactory), function () {\n        Object.entries(invokedFactory).forEach(_ref2 => {\n          let [key, value] = _ref2;\n          // @ts-expect-error: TS doesn't know what `this` is\n          this.setExport(key, value);\n        });\n      }, {\n        context,\n        identifier: moduleName\n      });\n\n      this._moduleMockRegistry.set(moduleID, module);\n\n      return evaluateSyntheticModule(module);\n    }\n\n    throw new Error('Attempting to import a mock without a factory');\n  }\n\n  getExportsOfCjs(modulePath) {\n    var _this$_fileTransforms, _this$_fileTransforms2;\n\n    const cachedNamedExports = this._cjsNamedExports.get(modulePath);\n\n    if (cachedNamedExports) {\n      return cachedNamedExports;\n    }\n\n    const transformedCode = (_this$_fileTransforms = (_this$_fileTransforms2 = this._fileTransforms.get(modulePath)) === null || _this$_fileTransforms2 === void 0 ? void 0 : _this$_fileTransforms2.code) !== null && _this$_fileTransforms !== void 0 ? _this$_fileTransforms : this.readFile(modulePath);\n    const {\n      exports,\n      reexports\n    } = (0, _cjsModuleLexer().parse)(transformedCode);\n    const namedExports = new Set(exports);\n    reexports.forEach(reexport => {\n      const resolved = this._resolveCjsModule(modulePath, reexport, {\n        conditions: this.esmConditions\n      });\n\n      const exports = this.getExportsOfCjs(resolved);\n      exports.forEach(namedExports.add, namedExports);\n    });\n\n    this._cjsNamedExports.set(modulePath, namedExports);\n\n    return namedExports;\n  }\n\n  requireModule(from, moduleName, options) {\n    let isRequireActual = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    var _options$isInternalMo;\n\n    const isInternal = (_options$isInternalMo = options === null || options === void 0 ? void 0 : options.isInternalModule) !== null && _options$isInternalMo !== void 0 ? _options$isInternalMo : false;\n\n    const moduleID = this._resolver.getModuleID(this._virtualMocks, from, moduleName, {\n      conditions: this.cjsConditions\n    });\n\n    let modulePath; // Some old tests rely on this mocking behavior. Ideally we'll change this\n    // to be more explicit.\n\n    const moduleResource = moduleName && this._resolver.getModule(moduleName);\n\n    const manualMock = moduleName && this._resolver.getMockModule(from, moduleName);\n\n    if (!(options !== null && options !== void 0 && options.isInternalModule) && !isRequireActual && !moduleResource && manualMock && manualMock !== this._isCurrentlyExecutingManualMock && this._explicitShouldMock.get(moduleID) !== false) {\n      modulePath = manualMock;\n    }\n\n    if (moduleName && this._resolver.isCoreModule(moduleName)) {\n      return this._requireCoreModule(moduleName, supportsNodeColonModulePrefixInRequire);\n    }\n\n    if (!modulePath) {\n      modulePath = this._resolveCjsModule(from, moduleName, {\n        conditions: this.cjsConditions\n      });\n    }\n\n    if (this.unstable_shouldLoadAsEsm(modulePath)) {\n      // Node includes more info in the message\n      const error = new Error(`Must use import to load ES Module: ${modulePath}`);\n      error.code = 'ERR_REQUIRE_ESM';\n      throw error;\n    }\n\n    let moduleRegistry;\n\n    if (isInternal) {\n      moduleRegistry = this._internalModuleRegistry;\n    } else if (this._isolatedModuleRegistry) {\n      moduleRegistry = this._isolatedModuleRegistry;\n    } else {\n      moduleRegistry = this._moduleRegistry;\n    }\n\n    const module = moduleRegistry.get(modulePath);\n\n    if (module) {\n      return module.exports;\n    } // We must register the pre-allocated module object first so that any\n    // circular dependencies that may arise while evaluating the module can\n    // be satisfied.\n\n\n    const localModule = {\n      children: [],\n      exports: {},\n      filename: modulePath,\n      id: modulePath,\n      loaded: false,\n      path: path().dirname(modulePath)\n    };\n    moduleRegistry.set(modulePath, localModule);\n\n    try {\n      this._loadModule(localModule, from, moduleName, modulePath, options, moduleRegistry);\n    } catch (error) {\n      moduleRegistry.delete(modulePath);\n      throw error;\n    }\n\n    return localModule.exports;\n  }\n\n  requireInternalModule(from, to) {\n    if (to) {\n      var _nativeModule$createR;\n\n      const require = ((_nativeModule$createR = _module().default.createRequire) !== null && _nativeModule$createR !== void 0 ? _nativeModule$createR : _module().default.createRequireFromPath)(from);\n\n      if (INTERNAL_MODULE_REQUIRE_OUTSIDE_OPTIMIZED_MODULES.has(to)) {\n        return require(to);\n      }\n\n      const outsideJestVmPath = (0, _helpers.decodePossibleOutsideJestVmPath)(to);\n\n      if (outsideJestVmPath) {\n        return require(outsideJestVmPath);\n      }\n    }\n\n    return this.requireModule(from, to, {\n      isInternalModule: true,\n      supportsDynamicImport: esmIsAvailable,\n      supportsExportNamespaceFrom: false,\n      supportsStaticESM: false,\n      supportsTopLevelAwait: false\n    });\n  }\n\n  requireActual(from, moduleName) {\n    return this.requireModule(from, moduleName, undefined, true);\n  }\n\n  requireMock(from, moduleName) {\n    var _this$_isolatedMockRe;\n\n    const moduleID = this._resolver.getModuleID(this._virtualMocks, from, moduleName, {\n      conditions: this.cjsConditions\n    });\n\n    if ((_this$_isolatedMockRe = this._isolatedMockRegistry) !== null && _this$_isolatedMockRe !== void 0 && _this$_isolatedMockRe.has(moduleID)) {\n      return this._isolatedMockRegistry.get(moduleID);\n    } else if (this._mockRegistry.has(moduleID)) {\n      return this._mockRegistry.get(moduleID);\n    }\n\n    const mockRegistry = this._isolatedMockRegistry || this._mockRegistry;\n\n    if (this._mockFactories.has(moduleID)) {\n      // has check above makes this ok\n      const module = this._mockFactories.get(moduleID)();\n\n      mockRegistry.set(moduleID, module);\n      return module;\n    }\n\n    const manualMockOrStub = this._resolver.getMockModule(from, moduleName);\n\n    let modulePath = this._resolver.getMockModule(from, moduleName) || this._resolveCjsModule(from, moduleName, {\n      conditions: this.cjsConditions\n    });\n\n    let isManualMock = manualMockOrStub && !this._resolver.resolveStubModuleName(from, moduleName);\n\n    if (!isManualMock) {\n      // If the actual module file has a __mocks__ dir sitting immediately next\n      // to it, look to see if there is a manual mock for this file.\n      //\n      // subDir1/my_module.js\n      // subDir1/__mocks__/my_module.js\n      // subDir2/my_module.js\n      // subDir2/__mocks__/my_module.js\n      //\n      // Where some other module does a relative require into each of the\n      // respective subDir{1,2} directories and expects a manual mock\n      // corresponding to that particular my_module.js file.\n      const moduleDir = path().dirname(modulePath);\n      const moduleFileName = path().basename(modulePath);\n      const potentialManualMock = path().join(moduleDir, '__mocks__', moduleFileName);\n\n      if (fs().existsSync(potentialManualMock)) {\n        isManualMock = true;\n        modulePath = potentialManualMock;\n      }\n    }\n\n    if (isManualMock) {\n      const localModule = {\n        children: [],\n        exports: {},\n        filename: modulePath,\n        id: modulePath,\n        loaded: false,\n        path: path().dirname(modulePath)\n      };\n\n      this._loadModule(localModule, from, moduleName, modulePath, undefined, mockRegistry);\n\n      mockRegistry.set(moduleID, localModule.exports);\n    } else {\n      // Look for a real module to generate an automock from\n      mockRegistry.set(moduleID, this._generateMock(from, moduleName));\n    }\n\n    return mockRegistry.get(moduleID);\n  }\n\n  _loadModule(localModule, from, moduleName, modulePath, options, moduleRegistry) {\n    if (path().extname(modulePath) === '.json') {\n      const text = (0, _stripBom().default)(this.readFile(modulePath));\n\n      const transformedFile = this._scriptTransformer.transformJson(modulePath, this._getFullTransformationOptions(options), text);\n\n      localModule.exports = this._environment.global.JSON.parse(transformedFile);\n    } else if (path().extname(modulePath) === '.node') {\n      localModule.exports = require(modulePath);\n    } else {\n      // Only include the fromPath if a moduleName is given. Else treat as root.\n      const fromPath = moduleName ? from : null;\n\n      this._execModule(localModule, options, moduleRegistry, fromPath);\n    }\n\n    localModule.loaded = true;\n  }\n\n  _getFullTransformationOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultTransformOptions;\n    return { ...options,\n      ...this._coverageOptions\n    };\n  }\n\n  requireModuleOrMock(from, moduleName) {\n    // this module is unmockable\n    if (moduleName === '@jest/globals') {\n      // @ts-expect-error: we don't care that it's not assignable to T\n      return this.getGlobalsForCjs(from);\n    }\n\n    try {\n      if (this._shouldMockCjs(from, moduleName, this._explicitShouldMock, {\n        conditions: this.cjsConditions\n      })) {\n        return this.requireMock(from, moduleName);\n      } else {\n        return this.requireModule(from, moduleName);\n      }\n    } catch (e) {\n      const moduleNotFound = _jestResolve().default.tryCastModuleNotFoundError(e);\n\n      if (moduleNotFound) {\n        if (moduleNotFound.siblingWithSimilarExtensionFound === null || moduleNotFound.siblingWithSimilarExtensionFound === undefined) {\n          moduleNotFound.hint = (0, _helpers.findSiblingsWithFileExtension)(this._config.moduleFileExtensions, from, moduleNotFound.moduleName || moduleName);\n          moduleNotFound.siblingWithSimilarExtensionFound = Boolean(moduleNotFound.hint);\n        }\n\n        moduleNotFound.buildMessage(this._config.rootDir);\n        throw moduleNotFound;\n      }\n\n      throw e;\n    }\n  }\n\n  isolateModules(fn) {\n    if (this._isolatedModuleRegistry || this._isolatedMockRegistry) {\n      throw new Error('isolateModules cannot be nested inside another isolateModules.');\n    }\n\n    this._isolatedModuleRegistry = new Map();\n    this._isolatedMockRegistry = new Map();\n\n    try {\n      fn();\n    } finally {\n      var _this$_isolatedModule, _this$_isolatedMockRe2; // might be cleared within the callback\n\n\n      (_this$_isolatedModule = this._isolatedModuleRegistry) === null || _this$_isolatedModule === void 0 ? void 0 : _this$_isolatedModule.clear();\n      (_this$_isolatedMockRe2 = this._isolatedMockRegistry) === null || _this$_isolatedMockRe2 === void 0 ? void 0 : _this$_isolatedMockRe2.clear();\n      this._isolatedModuleRegistry = null;\n      this._isolatedMockRegistry = null;\n    }\n  }\n\n  resetModules() {\n    var _this$_isolatedModule2, _this$_isolatedMockRe3;\n\n    (_this$_isolatedModule2 = this._isolatedModuleRegistry) === null || _this$_isolatedModule2 === void 0 ? void 0 : _this$_isolatedModule2.clear();\n    (_this$_isolatedMockRe3 = this._isolatedMockRegistry) === null || _this$_isolatedMockRe3 === void 0 ? void 0 : _this$_isolatedMockRe3.clear();\n    this._isolatedModuleRegistry = null;\n    this._isolatedMockRegistry = null;\n\n    this._mockRegistry.clear();\n\n    this._moduleRegistry.clear();\n\n    this._esmoduleRegistry.clear();\n\n    this._cjsNamedExports.clear();\n\n    this._moduleMockRegistry.clear();\n\n    this._cacheFS.clear();\n\n    if (this._coverageOptions.collectCoverage && this._coverageOptions.coverageProvider === 'v8' && this._v8CoverageSources) {\n      this._v8CoverageSources = new Map([...this._v8CoverageSources, ...this._fileTransforms]);\n    }\n\n    this._fileTransforms.clear();\n\n    if (this._environment) {\n      if (this._environment.global) {\n        const envGlobal = this._environment.global;\n        Object.keys(envGlobal).forEach(key => {\n          const globalMock = envGlobal[key];\n\n          if ((typeof globalMock === 'object' && globalMock !== null || typeof globalMock === 'function') && globalMock._isMockFunction === true) {\n            globalMock.mockClear();\n          }\n        });\n      }\n\n      if (this._environment.fakeTimers) {\n        this._environment.fakeTimers.clearAllTimers();\n      }\n    }\n  }\n\n  async collectV8Coverage() {\n    this._v8CoverageInstrumenter = new (_collectV8Coverage().CoverageInstrumenter)();\n    this._v8CoverageSources = new Map();\n    await this._v8CoverageInstrumenter.startInstrumenting();\n  }\n\n  async stopCollectingV8Coverage() {\n    if (!this._v8CoverageInstrumenter || !this._v8CoverageSources) {\n      throw new Error('You need to call `collectV8Coverage` first.');\n    }\n\n    this._v8CoverageResult = await this._v8CoverageInstrumenter.stopInstrumenting();\n    this._v8CoverageSources = new Map([...this._v8CoverageSources, ...this._fileTransforms]);\n  }\n\n  getAllCoverageInfoCopy() {\n    return (0, _jestUtil().deepCyclicCopy)(this._environment.global.__coverage__);\n  }\n\n  getAllV8CoverageInfoCopy() {\n    if (!this._v8CoverageResult || !this._v8CoverageSources) {\n      throw new Error('You need to call `stopCollectingV8Coverage` first.');\n    }\n\n    return this._v8CoverageResult.filter(res => res.url.startsWith('file://')).map(res => ({ ...res,\n      url: (0, _url().fileURLToPath)(res.url)\n    })).filter((res // TODO: will this work on windows? It might be better if `shouldInstrument` deals with it anyways\n    ) => res.url.startsWith(this._config.rootDir) && this._v8CoverageSources.has(res.url) && (0, _transform().shouldInstrument)(res.url, this._coverageOptions, this._config)).map(result => {\n      const transformedFile = this._v8CoverageSources.get(result.url);\n\n      return {\n        codeTransformResult: transformedFile,\n        result\n      };\n    });\n  }\n\n  getSourceMaps() {\n    return this._sourceMapRegistry;\n  }\n\n  setMock(from, moduleName, mockFactory, options) {\n    if (options !== null && options !== void 0 && options.virtual) {\n      const mockPath = this._resolver.getModulePath(from, moduleName);\n\n      this._virtualMocks.set(mockPath, true);\n    }\n\n    const moduleID = this._resolver.getModuleID(this._virtualMocks, from, moduleName, {\n      conditions: this.cjsConditions\n    });\n\n    this._explicitShouldMock.set(moduleID, true);\n\n    this._mockFactories.set(moduleID, mockFactory);\n  }\n\n  setModuleMock(from, moduleName, mockFactory, options) {\n    if (options !== null && options !== void 0 && options.virtual) {\n      const mockPath = this._resolver.getModulePath(from, moduleName);\n\n      this._virtualModuleMocks.set(mockPath, true);\n    }\n\n    const moduleID = this._resolver.getModuleID(this._virtualModuleMocks, from, moduleName, {\n      conditions: this.esmConditions\n    });\n\n    this._explicitShouldMockModule.set(moduleID, true);\n\n    this._moduleMockFactories.set(moduleID, mockFactory);\n  }\n\n  restoreAllMocks() {\n    this._moduleMocker.restoreAllMocks();\n  }\n\n  resetAllMocks() {\n    this._moduleMocker.resetAllMocks();\n  }\n\n  clearAllMocks() {\n    this._moduleMocker.clearAllMocks();\n  }\n\n  teardown() {\n    var _this$_v8CoverageSour;\n\n    this.restoreAllMocks();\n    this.resetAllMocks();\n    this.resetModules();\n\n    this._internalModuleRegistry.clear();\n\n    this._mainModule = null;\n\n    this._mockFactories.clear();\n\n    this._moduleMockFactories.clear();\n\n    this._mockMetaDataCache.clear();\n\n    this._shouldMockModuleCache.clear();\n\n    this._shouldUnmockTransitiveDependenciesCache.clear();\n\n    this._explicitShouldMock.clear();\n\n    this._explicitShouldMockModule.clear();\n\n    this._transitiveShouldMock.clear();\n\n    this._virtualMocks.clear();\n\n    this._virtualModuleMocks.clear();\n\n    this._cacheFS.clear();\n\n    this._unmockList = undefined;\n\n    this._sourceMapRegistry.clear();\n\n    this._fileTransforms.clear();\n\n    this._fileTransformsMutex.clear();\n\n    this.jestObjectCaches.clear();\n    (_this$_v8CoverageSour = this._v8CoverageSources) === null || _this$_v8CoverageSour === void 0 ? void 0 : _this$_v8CoverageSour.clear();\n    this._v8CoverageResult = [];\n    this._v8CoverageInstrumenter = undefined;\n    this._moduleImplementation = undefined;\n    this.isTornDown = true;\n  }\n\n  _resolveCjsModule(from, to, options) {\n    return to ? this._resolver.resolveModule(from, to, options) : from;\n  }\n\n  _resolveModule(from, to, options) {\n    return to ? this._resolver.resolveModuleAsync(from, to, options) : from;\n  }\n\n  _requireResolve(from, moduleName) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (moduleName == null) {\n      throw new Error('The first argument to require.resolve must be a string. Received null or undefined.');\n    }\n\n    if (path().isAbsolute(moduleName)) {\n      const module = this._resolver.resolveModuleFromDirIfExists(moduleName, moduleName, {\n        conditions: this.cjsConditions,\n        paths: []\n      });\n\n      if (module) {\n        return module;\n      }\n    } else {\n      const {\n        paths\n      } = options;\n\n      if (paths) {\n        for (const p of paths) {\n          const absolutePath = path().resolve(from, '..', p);\n\n          const module = this._resolver.resolveModuleFromDirIfExists(absolutePath, moduleName, // required to also resolve files without leading './' directly in the path\n          {\n            conditions: this.cjsConditions,\n            paths: [absolutePath]\n          });\n\n          if (module) {\n            return module;\n          }\n        }\n\n        throw new (_jestResolve().default.ModuleNotFoundError)(`Cannot resolve module '${moduleName}' from paths ['${paths.join(\"', '\")}'] from ${from}`);\n      }\n    }\n\n    try {\n      return this._resolveCjsModule(from, moduleName, {\n        conditions: this.cjsConditions\n      });\n    } catch (err) {\n      const module = this._resolver.getMockModule(from, moduleName);\n\n      if (module) {\n        return module;\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  _requireResolvePaths(from, moduleName) {\n    if (moduleName == null) {\n      throw new Error('The first argument to require.resolve.paths must be a string. Received null or undefined.');\n    }\n\n    if (!moduleName.length) {\n      throw new Error('The first argument to require.resolve.paths must not be the empty string.');\n    }\n\n    if (moduleName[0] === '.') {\n      return [path().resolve(from, '..')];\n    }\n\n    if (this._resolver.isCoreModule(moduleName)) {\n      return null;\n    }\n\n    return this._resolver.getModulePaths(path().resolve(from, '..'));\n  }\n\n  _execModule(localModule, options, moduleRegistry, from) {\n    if (this.isTornDown) {\n      this._logFormattedReferenceError('You are trying to `import` a file after the Jest environment has been torn down.');\n\n      process.exitCode = 1;\n      return;\n    } // If the environment was disposed, prevent this module from being executed.\n\n\n    if (!this._environment.global) {\n      return;\n    }\n\n    const module = localModule;\n    const filename = module.filename;\n    const lastExecutingModulePath = this._currentlyExecutingModulePath;\n    this._currentlyExecutingModulePath = filename;\n    const origCurrExecutingManualMock = this._isCurrentlyExecutingManualMock;\n    this._isCurrentlyExecutingManualMock = filename;\n    module.children = [];\n    Object.defineProperty(module, 'parent', {\n      enumerable: true,\n\n      get() {\n        const key = from || '';\n        return moduleRegistry.get(key) || null;\n      }\n\n    });\n    module.paths = this._resolver.getModulePaths(module.path);\n    Object.defineProperty(module, 'require', {\n      value: this._createRequireImplementation(module, options)\n    });\n    const transformedCode = this.transformFile(filename, options);\n    let compiledFunction = null;\n    const script = this.createScriptFromCode(transformedCode, filename);\n    let runScript = null;\n\n    const vmContext = this._environment.getVmContext();\n\n    if (vmContext) {\n      runScript = script.runInContext(vmContext, {\n        filename\n      });\n    }\n\n    if (runScript !== null) {\n      compiledFunction = runScript[EVAL_RESULT_VARIABLE];\n    }\n\n    if (compiledFunction === null) {\n      this._logFormattedReferenceError('You are trying to `import` a file after the Jest environment has been torn down.');\n\n      process.exitCode = 1;\n      return;\n    }\n\n    const jestObject = this._createJestObjectFor(filename);\n\n    this.jestObjectCaches.set(filename, jestObject);\n    const lastArgs = [this._config.injectGlobals ? jestObject : undefined, // jest object\n    ...this._config.sandboxInjectedGlobals.map(globalVariable => {\n      if (this._environment.global[globalVariable]) {\n        return this._environment.global[globalVariable];\n      }\n\n      throw new Error(`You have requested '${globalVariable}' as a global variable, but it was not present. Please check your config or your global environment.`);\n    })];\n\n    if (!this._mainModule && filename === this._testPath) {\n      this._mainModule = module;\n    }\n\n    Object.defineProperty(module, 'main', {\n      enumerable: true,\n      value: this._mainModule\n    });\n\n    try {\n      compiledFunction.call(module.exports, module, // module object\n      module.exports, // module exports\n      module.require, // require implementation\n      module.path, // __dirname\n      module.filename, // __filename\n      lastArgs[0], ...lastArgs.slice(1).filter(notEmpty));\n    } catch (error) {\n      this.handleExecutionError(error, module);\n    }\n\n    this._isCurrentlyExecutingManualMock = origCurrExecutingManualMock;\n    this._currentlyExecutingModulePath = lastExecutingModulePath;\n  }\n\n  transformFile(filename, options) {\n    const source = this.readFile(filename);\n\n    if (options !== null && options !== void 0 && options.isInternalModule) {\n      return source;\n    }\n\n    let transformedFile = this._fileTransforms.get(filename);\n\n    if (transformedFile) {\n      return transformedFile.code;\n    }\n\n    transformedFile = this._scriptTransformer.transform(filename, this._getFullTransformationOptions(options), source);\n\n    this._fileTransforms.set(filename, { ...transformedFile,\n      wrapperLength: this.constructModuleWrapperStart().length\n    });\n\n    if (transformedFile.sourceMapPath) {\n      this._sourceMapRegistry.set(filename, transformedFile.sourceMapPath);\n    }\n\n    return transformedFile.code;\n  }\n\n  async transformFileAsync(filename, options) {\n    const source = this.readFile(filename);\n\n    if (options !== null && options !== void 0 && options.isInternalModule) {\n      return source;\n    }\n\n    let transformedFile = this._fileTransforms.get(filename);\n\n    if (transformedFile) {\n      return transformedFile.code;\n    }\n\n    transformedFile = await this._scriptTransformer.transformAsync(filename, this._getFullTransformationOptions(options), source);\n\n    this._fileTransforms.set(filename, { ...transformedFile,\n      wrapperLength: 0\n    });\n\n    if (transformedFile.sourceMapPath) {\n      this._sourceMapRegistry.set(filename, transformedFile.sourceMapPath);\n    }\n\n    return transformedFile.code;\n  }\n\n  createScriptFromCode(scriptSource, filename) {\n    try {\n      const scriptFilename = this._resolver.isCoreModule(filename) ? `jest-nodejs-core-${filename}` : filename;\n      return new (_vm().Script)(this.wrapCodeInModuleWrapper(scriptSource), {\n        displayErrors: true,\n        filename: scriptFilename,\n        // @ts-expect-error: Experimental ESM API\n        importModuleDynamically: async specifier => {\n          var _this$_environment$ge, _this$_environment2;\n\n          invariant(runtimeSupportsVmModules, 'You need to run with a version of node that supports ES Modules in the VM API. See https://jestjs.io/docs/ecmascript-modules');\n          const context = (_this$_environment$ge = (_this$_environment2 = this._environment).getVmContext) === null || _this$_environment$ge === void 0 ? void 0 : _this$_environment$ge.call(_this$_environment2);\n          invariant(context, 'Test environment has been torn down');\n          const module = await this.resolveModule(specifier, scriptFilename, context);\n          return this.linkAndEvaluateModule(module);\n        }\n      });\n    } catch (e) {\n      throw (0, _transform().handlePotentialSyntaxError)(e);\n    }\n  }\n\n  _requireCoreModule(moduleName, supportPrefix) {\n    const moduleWithoutNodePrefix = supportPrefix && moduleName.startsWith('node:') ? moduleName.slice('node:'.length) : moduleName;\n\n    if (moduleWithoutNodePrefix === 'process') {\n      return this._environment.global.process;\n    }\n\n    if (moduleWithoutNodePrefix === 'module') {\n      return this._getMockedNativeModule();\n    }\n\n    return require(moduleWithoutNodePrefix);\n  }\n\n  _importCoreModule(moduleName, context) {\n    const required = this._requireCoreModule(moduleName, supportsNodeColonModulePrefixInImport);\n\n    const module = new (_vm().SyntheticModule)(['default', ...Object.keys(required)], function () {\n      // @ts-expect-error: TS doesn't know what `this` is\n      this.setExport('default', required);\n      Object.entries(required).forEach(_ref3 => {\n        let [key, value] = _ref3;\n        // @ts-expect-error: TS doesn't know what `this` is\n        this.setExport(key, value);\n      });\n    }, // should identifier be `node://${moduleName}`?\n    {\n      context,\n      identifier: moduleName\n    });\n    return evaluateSyntheticModule(module);\n  }\n\n  _getMockedNativeModule() {\n    if (this._moduleImplementation) {\n      return this._moduleImplementation;\n    }\n\n    const createRequire = modulePath => {\n      const filename = typeof modulePath === 'string' ? modulePath.startsWith('file:///') ? (0, _url().fileURLToPath)(new (_url().URL)(modulePath)) : modulePath : (0, _url().fileURLToPath)(modulePath);\n\n      if (!path().isAbsolute(filename)) {\n        const error = new TypeError(`The argument 'filename' must be a file URL object, file URL string, or absolute path string. Received '${filename}'`);\n        error.code = 'ERR_INVALID_ARG_TYPE';\n        throw error;\n      }\n\n      return this._createRequireImplementation({\n        children: [],\n        exports: {},\n        filename,\n        id: filename,\n        loaded: false,\n        path: path().dirname(filename)\n      });\n    }; // should we implement the class ourselves?\n\n\n    class Module extends _module().default.Module {}\n\n    Object.entries(_module().default.Module).forEach(_ref4 => {\n      let [key, value] = _ref4;\n      // @ts-expect-error: no index signature\n      Module[key] = value;\n    });\n    Module.Module = Module;\n\n    if ('createRequire' in _module().default) {\n      Module.createRequire = createRequire;\n    }\n\n    if ('createRequireFromPath' in _module().default) {\n      Module.createRequireFromPath = function createRequireFromPath(filename) {\n        if (typeof filename !== 'string') {\n          const error = new TypeError(`The argument 'filename' must be string. Received '${filename}'.${filename instanceof _url().URL ? ' Use createRequire for URL filename.' : ''}`);\n          error.code = 'ERR_INVALID_ARG_TYPE';\n          throw error;\n        }\n\n        return createRequire(filename);\n      };\n    }\n\n    if ('syncBuiltinESMExports' in _module().default) {\n      // cast since TS seems very confused about whether it exists or not\n      Module.syncBuiltinESMExports = // eslint-disable-next-line @typescript-eslint/no-empty-function\n      function syncBuiltinESMExports() {};\n    }\n\n    this._moduleImplementation = Module;\n    return Module;\n  }\n\n  _generateMock(from, moduleName) {\n    const modulePath = this._resolver.resolveStubModuleName(from, moduleName) || this._resolveCjsModule(from, moduleName, {\n      conditions: this.cjsConditions\n    });\n\n    if (!this._mockMetaDataCache.has(modulePath)) {\n      // This allows us to handle circular dependencies while generating an\n      // automock\n      this._mockMetaDataCache.set(modulePath, this._moduleMocker.getMetadata({}) || {}); // In order to avoid it being possible for automocking to potentially\n      // cause side-effects within the module environment, we need to execute\n      // the module in isolation. This could cause issues if the module being\n      // mocked has calls into side-effectful APIs on another module.\n\n\n      const origMockRegistry = this._mockRegistry;\n      const origModuleRegistry = this._moduleRegistry;\n      this._mockRegistry = new Map();\n      this._moduleRegistry = new Map();\n      const moduleExports = this.requireModule(from, moduleName); // Restore the \"real\" module/mock registries\n\n      this._mockRegistry = origMockRegistry;\n      this._moduleRegistry = origModuleRegistry;\n\n      const mockMetadata = this._moduleMocker.getMetadata(moduleExports);\n\n      if (mockMetadata == null) {\n        throw new Error(`Failed to get mock metadata: ${modulePath}\\n\\n` + 'See: https://jestjs.io/docs/manual-mocks#content');\n      }\n\n      this._mockMetaDataCache.set(modulePath, mockMetadata);\n    }\n\n    return this._moduleMocker.generateFromMetadata( // added above if missing\n    this._mockMetaDataCache.get(modulePath));\n  }\n\n  _shouldMockCjs(from, moduleName, explicitShouldMock, options) {\n    const moduleID = this._resolver.getModuleID(this._virtualMocks, from, moduleName, options);\n\n    const key = from + path().delimiter + moduleID;\n\n    if (explicitShouldMock.has(moduleID)) {\n      // guaranteed by `has` above\n      return explicitShouldMock.get(moduleID);\n    }\n\n    if (!this._shouldAutoMock || this._resolver.isCoreModule(moduleName) || this._shouldUnmockTransitiveDependenciesCache.get(key)) {\n      return false;\n    }\n\n    if (this._shouldMockModuleCache.has(moduleID)) {\n      // guaranteed by `has` above\n      return this._shouldMockModuleCache.get(moduleID);\n    }\n\n    let modulePath;\n\n    try {\n      modulePath = this._resolveCjsModule(from, moduleName, options);\n    } catch (e) {\n      const manualMock = this._resolver.getMockModule(from, moduleName);\n\n      if (manualMock) {\n        this._shouldMockModuleCache.set(moduleID, true);\n\n        return true;\n      }\n\n      throw e;\n    }\n\n    if (this._unmockList && this._unmockList.test(modulePath)) {\n      this._shouldMockModuleCache.set(moduleID, false);\n\n      return false;\n    } // transitive unmocking for package managers that store flat packages (npm3)\n\n\n    const currentModuleID = this._resolver.getModuleID(this._virtualMocks, from, undefined, options);\n\n    if (this._transitiveShouldMock.get(currentModuleID) === false || from.includes(NODE_MODULES) && modulePath.includes(NODE_MODULES) && (this._unmockList && this._unmockList.test(from) || explicitShouldMock.get(currentModuleID) === false)) {\n      this._transitiveShouldMock.set(moduleID, false);\n\n      this._shouldUnmockTransitiveDependenciesCache.set(key, true);\n\n      return false;\n    }\n\n    this._shouldMockModuleCache.set(moduleID, true);\n\n    return true;\n  }\n\n  async _shouldMockModule(from, moduleName, explicitShouldMock, options) {\n    const moduleID = await this._resolver.getModuleIDAsync(this._virtualMocks, from, moduleName, options);\n    const key = from + path().delimiter + moduleID;\n\n    if (explicitShouldMock.has(moduleID)) {\n      // guaranteed by `has` above\n      return explicitShouldMock.get(moduleID);\n    }\n\n    if (!this._shouldAutoMock || this._resolver.isCoreModule(moduleName) || this._shouldUnmockTransitiveDependenciesCache.get(key)) {\n      return false;\n    }\n\n    if (this._shouldMockModuleCache.has(moduleID)) {\n      // guaranteed by `has` above\n      return this._shouldMockModuleCache.get(moduleID);\n    }\n\n    let modulePath;\n\n    try {\n      modulePath = await this._resolveModule(from, moduleName, options);\n    } catch (e) {\n      const manualMock = await this._resolver.getMockModuleAsync(from, moduleName);\n\n      if (manualMock) {\n        this._shouldMockModuleCache.set(moduleID, true);\n\n        return true;\n      }\n\n      throw e;\n    }\n\n    if (this._unmockList && this._unmockList.test(modulePath)) {\n      this._shouldMockModuleCache.set(moduleID, false);\n\n      return false;\n    } // transitive unmocking for package managers that store flat packages (npm3)\n\n\n    const currentModuleID = await this._resolver.getModuleIDAsync(this._virtualMocks, from, undefined, options);\n\n    if (this._transitiveShouldMock.get(currentModuleID) === false || from.includes(NODE_MODULES) && modulePath.includes(NODE_MODULES) && (this._unmockList && this._unmockList.test(from) || explicitShouldMock.get(currentModuleID) === false)) {\n      this._transitiveShouldMock.set(moduleID, false);\n\n      this._shouldUnmockTransitiveDependenciesCache.set(key, true);\n\n      return false;\n    }\n\n    this._shouldMockModuleCache.set(moduleID, true);\n\n    return true;\n  }\n\n  _createRequireImplementation(from, options) {\n    const resolve = (moduleName, resolveOptions) => {\n      const resolved = this._requireResolve(from.filename, moduleName, resolveOptions);\n\n      if (resolveOptions !== null && resolveOptions !== void 0 && resolveOptions[JEST_RESOLVE_OUTSIDE_VM_OPTION] && options !== null && options !== void 0 && options.isInternalModule) {\n        return (0, _helpers.createOutsideJestVmPath)(resolved);\n      }\n\n      return resolved;\n    };\n\n    resolve.paths = moduleName => this._requireResolvePaths(from.filename, moduleName);\n\n    const moduleRequire = options !== null && options !== void 0 && options.isInternalModule ? moduleName => this.requireInternalModule(from.filename, moduleName) : this.requireModuleOrMock.bind(this, from.filename);\n    moduleRequire.extensions = Object.create(null);\n    moduleRequire.resolve = resolve;\n\n    moduleRequire.cache = (() => {\n      // TODO: consider warning somehow that this does nothing. We should support deletions, anyways\n      const notPermittedMethod = () => true;\n\n      return new Proxy(Object.create(null), {\n        defineProperty: notPermittedMethod,\n        deleteProperty: notPermittedMethod,\n        get: (_target, key) => typeof key === 'string' ? this._moduleRegistry.get(key) : undefined,\n\n        getOwnPropertyDescriptor() {\n          return {\n            configurable: true,\n            enumerable: true\n          };\n        },\n\n        has: (_target, key) => typeof key === 'string' && this._moduleRegistry.has(key),\n        ownKeys: () => Array.from(this._moduleRegistry.keys()),\n        set: notPermittedMethod\n      });\n    })();\n\n    Object.defineProperty(moduleRequire, 'main', {\n      enumerable: true,\n      value: this._mainModule\n    });\n    return moduleRequire;\n  }\n\n  _createJestObjectFor(from) {\n    var _this$_moduleMocker$m, _this$_moduleMocker$m2;\n\n    const disableAutomock = () => {\n      this._shouldAutoMock = false;\n      return jestObject;\n    };\n\n    const enableAutomock = () => {\n      this._shouldAutoMock = true;\n      return jestObject;\n    };\n\n    const unmock = moduleName => {\n      const moduleID = this._resolver.getModuleID(this._virtualMocks, from, moduleName, {\n        conditions: this.cjsConditions\n      });\n\n      this._explicitShouldMock.set(moduleID, false);\n\n      return jestObject;\n    };\n\n    const deepUnmock = moduleName => {\n      const moduleID = this._resolver.getModuleID(this._virtualMocks, from, moduleName, {\n        conditions: this.cjsConditions\n      });\n\n      this._explicitShouldMock.set(moduleID, false);\n\n      this._transitiveShouldMock.set(moduleID, false);\n\n      return jestObject;\n    };\n\n    const mock = (moduleName, mockFactory, options) => {\n      if (mockFactory !== undefined) {\n        return setMockFactory(moduleName, mockFactory, options);\n      }\n\n      const moduleID = this._resolver.getModuleID(this._virtualMocks, from, moduleName, {\n        conditions: this.cjsConditions\n      });\n\n      this._explicitShouldMock.set(moduleID, true);\n\n      return jestObject;\n    };\n\n    const setMockFactory = (moduleName, mockFactory, options) => {\n      this.setMock(from, moduleName, mockFactory, options);\n      return jestObject;\n    };\n\n    const mockModule = (moduleName, mockFactory, options) => {\n      if (typeof mockFactory !== 'function') {\n        throw new Error('`unstable_mockModule` must be passed a mock factory');\n      }\n\n      this.setModuleMock(from, moduleName, mockFactory, options);\n      return jestObject;\n    };\n\n    const clearAllMocks = () => {\n      this.clearAllMocks();\n      return jestObject;\n    };\n\n    const resetAllMocks = () => {\n      this.resetAllMocks();\n      return jestObject;\n    };\n\n    const restoreAllMocks = () => {\n      this.restoreAllMocks();\n      return jestObject;\n    };\n\n    const _getFakeTimers = () => {\n      if (this.isTornDown || !(this._environment.fakeTimers || this._environment.fakeTimersModern)) {\n        this._logFormattedReferenceError('You are trying to access a property or method of the Jest environment after it has been torn down.');\n\n        process.exitCode = 1;\n      }\n\n      return this._fakeTimersImplementation;\n    };\n\n    const useFakeTimers = fakeTimersConfig => {\n      var _fakeTimersConfig;\n\n      fakeTimersConfig = { ...this._config.fakeTimers,\n        ...fakeTimersConfig\n      };\n\n      if ((_fakeTimersConfig = fakeTimersConfig) !== null && _fakeTimersConfig !== void 0 && _fakeTimersConfig.legacyFakeTimers) {\n        this._fakeTimersImplementation = this._environment.fakeTimers;\n      } else {\n        this._fakeTimersImplementation = this._environment.fakeTimersModern;\n      }\n\n      this._fakeTimersImplementation.useFakeTimers(fakeTimersConfig);\n\n      return jestObject;\n    };\n\n    const useRealTimers = () => {\n      _getFakeTimers().useRealTimers();\n\n      return jestObject;\n    };\n\n    const resetModules = () => {\n      this.resetModules();\n      return jestObject;\n    };\n\n    const isolateModules = fn => {\n      this.isolateModules(fn);\n      return jestObject;\n    };\n\n    const fn = this._moduleMocker.fn.bind(this._moduleMocker);\n\n    const spyOn = this._moduleMocker.spyOn.bind(this._moduleMocker);\n\n    const mocked = (_this$_moduleMocker$m = (_this$_moduleMocker$m2 = this._moduleMocker.mocked) === null || _this$_moduleMocker$m2 === void 0 ? void 0 : _this$_moduleMocker$m2.bind(this._moduleMocker)) !== null && _this$_moduleMocker$m !== void 0 ? _this$_moduleMocker$m : () => {\n      throw new Error('Your test environment does not support `mocked`, please update it.');\n    };\n\n    const setTimeout = timeout => {\n      this._environment.global[testTimeoutSymbol] = timeout;\n      return jestObject;\n    };\n\n    const retryTimes = (numTestRetries, options) => {\n      this._environment.global[retryTimesSymbol] = numTestRetries;\n      this._environment.global[logErrorsBeforeRetrySymbol] = options === null || options === void 0 ? void 0 : options.logErrorsBeforeRetry;\n      return jestObject;\n    };\n\n    const jestObject = {\n      advanceTimersByTime: msToRun => _getFakeTimers().advanceTimersByTime(msToRun),\n      advanceTimersToNextTimer: steps => _getFakeTimers().advanceTimersToNextTimer(steps),\n      autoMockOff: disableAutomock,\n      autoMockOn: enableAutomock,\n      clearAllMocks,\n      clearAllTimers: () => _getFakeTimers().clearAllTimers(),\n      createMockFromModule: moduleName => this._generateMock(from, moduleName),\n      deepUnmock,\n      disableAutomock,\n      doMock: mock,\n      dontMock: unmock,\n      enableAutomock,\n      fn,\n      genMockFromModule: moduleName => this._generateMock(from, moduleName),\n      getRealSystemTime: () => {\n        const fakeTimers = _getFakeTimers();\n\n        if (fakeTimers === this._environment.fakeTimersModern) {\n          return fakeTimers.getRealSystemTime();\n        } else {\n          throw new TypeError('`jest.getRealSystemTime()` is not available when using legacy fake timers.');\n        }\n      },\n      getTimerCount: () => _getFakeTimers().getTimerCount(),\n      isMockFunction: this._moduleMocker.isMockFunction,\n      isolateModules,\n      mock,\n      mocked,\n      requireActual: this.requireActual.bind(this, from),\n      requireMock: this.requireMock.bind(this, from),\n      resetAllMocks,\n      resetModules,\n      restoreAllMocks,\n      retryTimes,\n      runAllImmediates: () => {\n        const fakeTimers = _getFakeTimers();\n\n        if (fakeTimers === this._environment.fakeTimers) {\n          fakeTimers.runAllImmediates();\n        } else {\n          throw new TypeError('`jest.runAllImmediates()` is only available when using legacy fake timers.');\n        }\n      },\n      runAllTicks: () => _getFakeTimers().runAllTicks(),\n      runAllTimers: () => _getFakeTimers().runAllTimers(),\n      runOnlyPendingTimers: () => _getFakeTimers().runOnlyPendingTimers(),\n      setMock: (moduleName, mock) => setMockFactory(moduleName, () => mock),\n      setSystemTime: now => {\n        const fakeTimers = _getFakeTimers();\n\n        if (fakeTimers === this._environment.fakeTimersModern) {\n          fakeTimers.setSystemTime(now);\n        } else {\n          throw new TypeError('`jest.setSystemTime()` is not available when using legacy fake timers.');\n        }\n      },\n      setTimeout,\n      spyOn,\n      unmock,\n      unstable_mockModule: mockModule,\n      useFakeTimers,\n      useRealTimers\n    };\n    return jestObject;\n  }\n\n  _logFormattedReferenceError(errorMessage) {\n    const testPath = this._testPath ? ` From ${(0, _slash().default)(path().relative(this._config.rootDir, this._testPath))}.` : '';\n    const originalStack = new ReferenceError(`${errorMessage}${testPath}`).stack.split('\\n') // Remove this file from the stack (jest-message-utils will keep one line)\n    .filter(line => line.indexOf(__filename) === -1).join('\\n');\n    const {\n      message,\n      stack\n    } = (0, _jestMessageUtil().separateMessageFromStack)(originalStack);\n    console.error(`\\n${message}\\n${(0, _jestMessageUtil().formatStackTrace)(stack, this._config, {\n      noStackTrace: false\n    })}`);\n  }\n\n  wrapCodeInModuleWrapper(content) {\n    return `${this.constructModuleWrapperStart() + content}\\n}});`;\n  }\n\n  constructModuleWrapperStart() {\n    const args = this.constructInjectedModuleParameters();\n    return `({\"${EVAL_RESULT_VARIABLE}\":function(${args.join(',')}){`;\n  }\n\n  constructInjectedModuleParameters() {\n    return ['module', 'exports', 'require', '__dirname', '__filename', this._config.injectGlobals ? 'jest' : undefined, ...this._config.sandboxInjectedGlobals].filter(notEmpty);\n  }\n\n  handleExecutionError(e, module) {\n    const moduleNotFoundError = _jestResolve().default.tryCastModuleNotFoundError(e);\n\n    if (moduleNotFoundError) {\n      if (!moduleNotFoundError.requireStack) {\n        moduleNotFoundError.requireStack = [module.filename || module.id];\n\n        for (let cursor = module.parent; cursor; cursor = cursor.parent) {\n          moduleNotFoundError.requireStack.push(cursor.filename || cursor.id);\n        }\n\n        moduleNotFoundError.buildMessage(this._config.rootDir);\n      }\n\n      throw moduleNotFoundError;\n    }\n\n    throw e;\n  }\n\n  getGlobalsForCjs(from) {\n    const jest = this.jestObjectCaches.get(from);\n    invariant(jest, 'There should always be a Jest object already');\n    return { ...this.getGlobalsFromEnvironment(),\n      jest\n    };\n  }\n\n  getGlobalsForEsm(from, context) {\n    let jest = this.jestObjectCaches.get(from);\n\n    if (!jest) {\n      jest = this._createJestObjectFor(from);\n      this.jestObjectCaches.set(from, jest);\n    }\n\n    const globals = { ...this.getGlobalsFromEnvironment(),\n      jest\n    };\n    const module = new (_vm().SyntheticModule)(Object.keys(globals), function () {\n      Object.entries(globals).forEach(_ref5 => {\n        let [key, value] = _ref5;\n        // @ts-expect-error: TS doesn't know what `this` is\n        this.setExport(key, value);\n      });\n    }, {\n      context,\n      identifier: '@jest/globals'\n    });\n    return evaluateSyntheticModule(module);\n  }\n\n  getGlobalsFromEnvironment() {\n    if (this.jestGlobals) {\n      return { ...this.jestGlobals\n      };\n    }\n\n    return {\n      afterAll: this._environment.global.afterAll,\n      afterEach: this._environment.global.afterEach,\n      beforeAll: this._environment.global.beforeAll,\n      beforeEach: this._environment.global.beforeEach,\n      describe: this._environment.global.describe,\n      expect: this._environment.global.expect,\n      fdescribe: this._environment.global.fdescribe,\n      fit: this._environment.global.fit,\n      it: this._environment.global.it,\n      test: this._environment.global.test,\n      xdescribe: this._environment.global.xdescribe,\n      xit: this._environment.global.xit,\n      xtest: this._environment.global.xtest\n    };\n  }\n\n  readFile(filename) {\n    let source = this._cacheFS.get(filename);\n\n    if (!source) {\n      source = fs().readFileSync(filename, 'utf8');\n\n      this._cacheFS.set(filename, source);\n    }\n\n    return source;\n  }\n\n  setGlobalsForRuntime(globals) {\n    this.jestGlobals = globals;\n  }\n\n}\n\nexports.default = Runtime;\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nfunction notEmpty(value) {\n  return value !== null && value !== undefined;\n}\n\nasync function evaluateSyntheticModule(module) {\n  await module.link(() => {\n    throw new Error('This should never happen');\n  });\n  await module.evaluate();\n  return module;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_module","data","_interopRequireDefault","require","path","_interopRequireWildcard","_url","_vm","_cjsModuleLexer","_collectV8Coverage","_execa","fs","_slash","_stripBom","_transform","_jestHasteMap","_jestMessageUtil","_jestRegexUtil","_jestResolve","_jestSnapshot","_jestUtil","_helpers","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","esmIsAvailable","SourceTextModule","dataURIRegex","defaultTransformOptions","isInternalModule","supportsDynamicImport","supportsExportNamespaceFrom","supportsStaticESM","supportsTopLevelAwait","INTERNAL_MODULE_REQUIRE_OUTSIDE_OPTIMIZED_MODULES","Set","JEST_RESOLVE_OUTSIDE_VM_OPTION","Symbol","for","testTimeoutSymbol","retryTimesSymbol","logErrorsBeforeRetrySymbol","NODE_MODULES","sep","getModuleNameMapper","config","Array","isArray","moduleNameMapper","length","map","regex","moduleName","RegExp","unmockRegExpCache","EVAL_RESULT_VARIABLE","runtimeSupportsVmModules","SyntheticModule","supportsNodeColonModulePrefixInRequire","supportsNodeColonModulePrefixInImport","stdout","sync","reject","Runtime","_cacheFS","_config","_coverageOptions","_currentlyExecutingModulePath","_environment","_explicitShouldMock","_explicitShouldMockModule","_fakeTimersImplementation","_internalModuleRegistry","_isCurrentlyExecutingManualMock","_mainModule","_mockFactories","_mockMetaDataCache","_mockRegistry","_isolatedMockRegistry","_moduleMockRegistry","_moduleMockFactories","_moduleMocker","_isolatedModuleRegistry","_moduleRegistry","_esmoduleRegistry","_cjsNamedExports","_esmModuleLinkingMap","_testPath","_resolver","_shouldAutoMock","_shouldMockModuleCache","_shouldUnmockTransitiveDependenciesCache","_sourceMapRegistry","_scriptTransformer","_fileTransforms","_fileTransformsMutex","_v8CoverageInstrumenter","_v8CoverageResult","_v8CoverageSources","_transitiveShouldMock","_unmockList","_virtualMocks","_virtualModuleMocks","_moduleImplementation","jestObjectCaches","jestGlobals","esmConditions","cjsConditions","isTornDown","constructor","environment","resolver","transformer","cacheFS","coverageOptions","testPath","_this$_environment$ex","_this$_environment$ex2","_this$_environment","Map","invariant","moduleMocker","automock","fakeTimers","legacyFakeTimers","fakeTimersModern","unmockedModulePathPatterns","join","envExportConditions","exportConditions","from","setupFiles","forEach","filePath","includes","moduleID","getModuleID","undefined","conditions","unstable_shouldLoadAsEsm","resetModules","shouldInstrument","createContext","options","createDirectory","cacheDirectory","instance","createHasteMap","console","maxWorkers","resetCache","watch","watchman","hasteMap","build","hasteFS","moduleMap","createResolver","ignorePatternParts","modulePathIgnorePatterns","watchPathIgnorePatterns","startsWith","rootDir","filter","Boolean","ignorePattern","create","computeSha1","haste","dependencyExtractor","enableSymlinks","extensions","EXTENSION","concat","moduleFileExtensions","forceNodeFilesystemAPI","hasteImplModulePath","hasteMapModulePath","id","mocksPattern","escapePathForRegex","platforms","retainAllFiles","roots","throwOnModuleCollision","useWatchman","defaultPlatform","extension","hasCoreModules","moduleDirectories","modulePaths","runCLI","Error","getCLIOptions","extensionsToTreatAsEsm","loadEsmModule","modulePath","query","cacheKey","getVmContext","context","transformResolve","transformReject","Promise","resolve","isCoreModule","core","_importCoreModule","transformedCode","transformFileAsync","module","identifier","importModuleDynamically","specifier","referencingModule","resolveModule","linkAndEvaluateModule","initializeImportMeta","meta","url","pathToFileURL","href","jest","_createJestObjectFor","error","referencingIdentifier","_logFormattedReferenceError","process","exitCode","fromCache","globals","getGlobalsForEsm","_shouldMockModule","importMock","match","groups","mime","encoding","code","decodeURIComponent","Buffer","toString","JSON","parse","setExport","fileURLToPath","split","resolved","_resolveModule","loadCjsAsEsm","status","link","evaluate","unstable_importModule","cjs","requireModuleOrMock","parsedExports","getExportsOfCjs","cjsExports","exportName","evaluateSyntheticModule","getModuleIDAsync","invokedFactory","keys","entries","_this$_fileTransforms","_this$_fileTransforms2","cachedNamedExports","readFile","reexports","namedExports","reexport","_resolveCjsModule","add","requireModule","isRequireActual","_options$isInternalMo","isInternal","moduleResource","getModule","manualMock","getMockModule","_requireCoreModule","moduleRegistry","localModule","children","filename","loaded","dirname","_loadModule","delete","requireInternalModule","to","_nativeModule$createR","createRequire","createRequireFromPath","outsideJestVmPath","decodePossibleOutsideJestVmPath","requireActual","requireMock","_this$_isolatedMockRe","mockRegistry","manualMockOrStub","isManualMock","resolveStubModuleName","moduleDir","moduleFileName","basename","potentialManualMock","existsSync","_generateMock","extname","text","transformedFile","transformJson","_getFullTransformationOptions","global","fromPath","_execModule","getGlobalsForCjs","_shouldMockCjs","e","moduleNotFound","tryCastModuleNotFoundError","siblingWithSimilarExtensionFound","hint","findSiblingsWithFileExtension","buildMessage","isolateModules","fn","_this$_isolatedModule","_this$_isolatedMockRe2","clear","_this$_isolatedModule2","_this$_isolatedMockRe3","collectCoverage","coverageProvider","envGlobal","globalMock","_isMockFunction","mockClear","clearAllTimers","collectV8Coverage","CoverageInstrumenter","startInstrumenting","stopCollectingV8Coverage","stopInstrumenting","getAllCoverageInfoCopy","deepCyclicCopy","__coverage__","getAllV8CoverageInfoCopy","res","result","codeTransformResult","getSourceMaps","setMock","mockFactory","virtual","mockPath","getModulePath","setModuleMock","restoreAllMocks","resetAllMocks","clearAllMocks","teardown","_this$_v8CoverageSour","resolveModuleAsync","_requireResolve","isAbsolute","resolveModuleFromDirIfExists","paths","p","absolutePath","ModuleNotFoundError","err","_requireResolvePaths","getModulePaths","lastExecutingModulePath","origCurrExecutingManualMock","enumerable","_createRequireImplementation","transformFile","compiledFunction","script","createScriptFromCode","runScript","vmContext","runInContext","jestObject","lastArgs","injectGlobals","sandboxInjectedGlobals","globalVariable","slice","notEmpty","handleExecutionError","source","transform","wrapperLength","constructModuleWrapperStart","sourceMapPath","transformAsync","scriptSource","scriptFilename","Script","wrapCodeInModuleWrapper","displayErrors","_this$_environment$ge","_this$_environment2","handlePotentialSyntaxError","supportPrefix","moduleWithoutNodePrefix","_getMockedNativeModule","required","URL","TypeError","Module","syncBuiltinESMExports","getMetadata","origMockRegistry","origModuleRegistry","moduleExports","mockMetadata","generateFromMetadata","explicitShouldMock","delimiter","test","currentModuleID","getMockModuleAsync","resolveOptions","createOutsideJestVmPath","moduleRequire","bind","notPermittedMethod","Proxy","deleteProperty","_target","configurable","ownKeys","_this$_moduleMocker$m","_this$_moduleMocker$m2","disableAutomock","enableAutomock","unmock","deepUnmock","mock","setMockFactory","mockModule","_getFakeTimers","useFakeTimers","fakeTimersConfig","_fakeTimersConfig","useRealTimers","spyOn","mocked","setTimeout","timeout","retryTimes","numTestRetries","logErrorsBeforeRetry","advanceTimersByTime","msToRun","advanceTimersToNextTimer","steps","autoMockOff","autoMockOn","createMockFromModule","doMock","dontMock","genMockFromModule","getRealSystemTime","getTimerCount","isMockFunction","runAllImmediates","runAllTicks","runAllTimers","runOnlyPendingTimers","setSystemTime","now","unstable_mockModule","errorMessage","relative","originalStack","ReferenceError","stack","line","indexOf","__filename","message","separateMessageFromStack","formatStackTrace","noStackTrace","content","args","constructInjectedModuleParameters","moduleNotFoundError","requireStack","cursor","parent","push","getGlobalsFromEnvironment","afterAll","afterEach","beforeAll","beforeEach","describe","expect","fdescribe","fit","it","xdescribe","xit","xtest","readFileSync","setGlobalsForRuntime","condition"],"sources":["/Users/wonjaelee/Desktop/final/node_modules/jest-runtime/build/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _module() {\n  const data = _interopRequireDefault(require('module'));\n\n  _module = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _url() {\n  const data = require('url');\n\n  _url = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _vm() {\n  const data = require('vm');\n\n  _vm = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _cjsModuleLexer() {\n  const data = require('cjs-module-lexer');\n\n  _cjsModuleLexer = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _collectV8Coverage() {\n  const data = require('collect-v8-coverage');\n\n  _collectV8Coverage = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _execa() {\n  const data = _interopRequireDefault(require('execa'));\n\n  _execa = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fs() {\n  const data = _interopRequireWildcard(require('graceful-fs'));\n\n  fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _slash() {\n  const data = _interopRequireDefault(require('slash'));\n\n  _slash = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _stripBom() {\n  const data = _interopRequireDefault(require('strip-bom'));\n\n  _stripBom = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _transform() {\n  const data = require('@jest/transform');\n\n  _transform = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestHasteMap() {\n  const data = _interopRequireDefault(require('jest-haste-map'));\n\n  _jestHasteMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRegexUtil() {\n  const data = require('jest-regex-util');\n\n  _jestRegexUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestResolve() {\n  const data = _interopRequireDefault(require('jest-resolve'));\n\n  _jestResolve = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSnapshot() {\n  const data = require('jest-snapshot');\n\n  _jestSnapshot = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _helpers = require('./helpers');\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst esmIsAvailable = typeof _vm().SourceTextModule === 'function';\nconst dataURIRegex =\n  /^data:(?<mime>text\\/javascript|application\\/json|application\\/wasm)(?:;(?<encoding>charset=utf-8|base64))?,(?<code>.*)$/;\nconst defaultTransformOptions = {\n  isInternalModule: false,\n  supportsDynamicImport: esmIsAvailable,\n  supportsExportNamespaceFrom: false,\n  supportsStaticESM: false,\n  supportsTopLevelAwait: false\n};\n// These are modules that we know\n// * are safe to require from the outside (not stateful, not prone to errors passing in instances from different realms), and\n// * take sufficiently long to require to warrant an optimization.\n// When required from the outside, they use the worker's require cache and are thus\n// only loaded once per worker, not once per test file.\n// Use /benchmarks/test-file-overhead to measure the impact.\n// Note that this only applies when they are required in an internal context;\n// users who require one of these modules in their tests will still get the module from inside the VM.\n// Prefer listing a module here only if it is impractical to use the jest-resolve-outside-vm-option where it is required,\n// e.g. because there are many require sites spread across the dependency graph.\nconst INTERNAL_MODULE_REQUIRE_OUTSIDE_OPTIMIZED_MODULES = new Set(['chalk']);\nconst JEST_RESOLVE_OUTSIDE_VM_OPTION = Symbol.for(\n  'jest-resolve-outside-vm-option'\n);\nconst testTimeoutSymbol = Symbol.for('TEST_TIMEOUT_SYMBOL');\nconst retryTimesSymbol = Symbol.for('RETRY_TIMES');\nconst logErrorsBeforeRetrySymbol = Symbol.for('LOG_ERRORS_BEFORE_RETRY');\nconst NODE_MODULES = `${path().sep}node_modules${path().sep}`;\n\nconst getModuleNameMapper = config => {\n  if (\n    Array.isArray(config.moduleNameMapper) &&\n    config.moduleNameMapper.length\n  ) {\n    return config.moduleNameMapper.map(([regex, moduleName]) => ({\n      moduleName,\n      regex: new RegExp(regex)\n    }));\n  }\n\n  return null;\n};\n\nconst unmockRegExpCache = new WeakMap();\nconst EVAL_RESULT_VARIABLE = 'Object.<anonymous>';\nconst runtimeSupportsVmModules = typeof _vm().SyntheticModule === 'function';\n\nconst supportsTopLevelAwait =\n  runtimeSupportsVmModules &&\n  (() => {\n    try {\n      // eslint-disable-next-line no-new\n      new (_vm().SourceTextModule)('await Promise.resolve()');\n      return true;\n    } catch {\n      return false;\n    }\n  })();\n\nconst supportsNodeColonModulePrefixInRequire = (() => {\n  try {\n    require('node:fs');\n\n    return true;\n  } catch {\n    return false;\n  }\n})();\n\nconst supportsNodeColonModulePrefixInImport = (() => {\n  const {stdout} = _execa().default.sync(\n    'node',\n    [\n      '--eval',\n      'import(\"node:fs\").then(() => console.log(true), () => console.log(false));'\n    ],\n    {\n      reject: false\n    }\n  );\n\n  return stdout === 'true';\n})();\n\nclass Runtime {\n  _cacheFS;\n  _config;\n  _coverageOptions;\n  _currentlyExecutingModulePath;\n  _environment;\n  _explicitShouldMock;\n  _explicitShouldMockModule;\n  _fakeTimersImplementation;\n  _internalModuleRegistry;\n  _isCurrentlyExecutingManualMock;\n  _mainModule;\n  _mockFactories;\n  _mockMetaDataCache;\n  _mockRegistry;\n  _isolatedMockRegistry;\n  _moduleMockRegistry;\n  _moduleMockFactories;\n  _moduleMocker;\n  _isolatedModuleRegistry;\n  _moduleRegistry;\n  _esmoduleRegistry;\n  _cjsNamedExports;\n  _esmModuleLinkingMap;\n  _testPath;\n  _resolver;\n  _shouldAutoMock;\n  _shouldMockModuleCache;\n  _shouldUnmockTransitiveDependenciesCache;\n  _sourceMapRegistry;\n  _scriptTransformer;\n  _fileTransforms;\n  _fileTransformsMutex;\n  _v8CoverageInstrumenter;\n  _v8CoverageResult;\n  _v8CoverageSources;\n  _transitiveShouldMock;\n  _unmockList;\n  _virtualMocks;\n  _virtualModuleMocks;\n  _moduleImplementation;\n  jestObjectCaches;\n  jestGlobals;\n  esmConditions;\n  cjsConditions;\n  isTornDown = false;\n\n  constructor(\n    config,\n    environment,\n    resolver,\n    transformer,\n    cacheFS,\n    coverageOptions,\n    testPath\n  ) {\n    var _this$_environment$ex, _this$_environment$ex2, _this$_environment;\n\n    this._cacheFS = cacheFS;\n    this._config = config;\n    this._coverageOptions = coverageOptions;\n    this._currentlyExecutingModulePath = '';\n    this._environment = environment;\n    this._explicitShouldMock = new Map();\n    this._explicitShouldMockModule = new Map();\n    this._internalModuleRegistry = new Map();\n    this._isCurrentlyExecutingManualMock = null;\n    this._mainModule = null;\n    this._mockFactories = new Map();\n    this._mockRegistry = new Map();\n    this._moduleMockRegistry = new Map();\n    this._moduleMockFactories = new Map();\n    invariant(\n      this._environment.moduleMocker,\n      '`moduleMocker` must be set on an environment when created'\n    );\n    this._moduleMocker = this._environment.moduleMocker;\n    this._isolatedModuleRegistry = null;\n    this._isolatedMockRegistry = null;\n    this._moduleRegistry = new Map();\n    this._esmoduleRegistry = new Map();\n    this._cjsNamedExports = new Map();\n    this._esmModuleLinkingMap = new WeakMap();\n    this._testPath = testPath;\n    this._resolver = resolver;\n    this._scriptTransformer = transformer;\n    this._shouldAutoMock = config.automock;\n    this._sourceMapRegistry = new Map();\n    this._fileTransforms = new Map();\n    this._fileTransformsMutex = new Map();\n    this._virtualMocks = new Map();\n    this._virtualModuleMocks = new Map();\n    this.jestObjectCaches = new Map();\n    this._mockMetaDataCache = new Map();\n    this._shouldMockModuleCache = new Map();\n    this._shouldUnmockTransitiveDependenciesCache = new Map();\n    this._transitiveShouldMock = new Map();\n    this._fakeTimersImplementation = config.fakeTimers.legacyFakeTimers\n      ? this._environment.fakeTimers\n      : this._environment.fakeTimersModern;\n    this._unmockList = unmockRegExpCache.get(config);\n\n    if (!this._unmockList && config.unmockedModulePathPatterns) {\n      this._unmockList = new RegExp(\n        config.unmockedModulePathPatterns.join('|')\n      );\n      unmockRegExpCache.set(config, this._unmockList);\n    }\n\n    const envExportConditions =\n      (_this$_environment$ex =\n        (_this$_environment$ex2 = (_this$_environment = this._environment)\n          .exportConditions) === null || _this$_environment$ex2 === void 0\n          ? void 0\n          : _this$_environment$ex2.call(_this$_environment)) !== null &&\n      _this$_environment$ex !== void 0\n        ? _this$_environment$ex\n        : [];\n    this.esmConditions = Array.from(\n      new Set(['import', 'default', ...envExportConditions])\n    );\n    this.cjsConditions = Array.from(\n      new Set(['require', 'default', ...envExportConditions])\n    );\n\n    if (config.automock) {\n      config.setupFiles.forEach(filePath => {\n        if (filePath.includes(NODE_MODULES)) {\n          const moduleID = this._resolver.getModuleID(\n            this._virtualMocks,\n            filePath,\n            undefined, // shouldn't really matter, but in theory this will make sure the caching is correct\n            {\n              conditions: this.unstable_shouldLoadAsEsm(filePath)\n                ? this.esmConditions\n                : this.cjsConditions\n            }\n          );\n\n          this._transitiveShouldMock.set(moduleID, false);\n        }\n      });\n    }\n\n    this.resetModules();\n  }\n\n  static shouldInstrument = _transform().shouldInstrument;\n\n  static async createContext(config, options) {\n    (0, _jestUtil().createDirectory)(config.cacheDirectory);\n    const instance = await Runtime.createHasteMap(config, {\n      console: options.console,\n      maxWorkers: options.maxWorkers,\n      resetCache: !config.cache,\n      watch: options.watch,\n      watchman: options.watchman\n    });\n    const hasteMap = await instance.build();\n    return {\n      config,\n      hasteFS: hasteMap.hasteFS,\n      moduleMap: hasteMap.moduleMap,\n      resolver: Runtime.createResolver(config, hasteMap.moduleMap)\n    };\n  }\n\n  static createHasteMap(config, options) {\n    const ignorePatternParts = [\n      ...config.modulePathIgnorePatterns,\n      ...(options && options.watch ? config.watchPathIgnorePatterns : []),\n      config.cacheDirectory.startsWith(config.rootDir + path().sep) &&\n        config.cacheDirectory\n    ].filter(Boolean);\n    const ignorePattern =\n      ignorePatternParts.length > 0\n        ? new RegExp(ignorePatternParts.join('|'))\n        : undefined;\n    return _jestHasteMap().default.create({\n      cacheDirectory: config.cacheDirectory,\n      computeSha1: config.haste.computeSha1,\n      console:\n        options === null || options === void 0 ? void 0 : options.console,\n      dependencyExtractor: config.dependencyExtractor,\n      enableSymlinks: config.haste.enableSymlinks,\n      extensions: [_jestSnapshot().EXTENSION].concat(\n        config.moduleFileExtensions\n      ),\n      forceNodeFilesystemAPI: config.haste.forceNodeFilesystemAPI,\n      hasteImplModulePath: config.haste.hasteImplModulePath,\n      hasteMapModulePath: config.haste.hasteMapModulePath,\n      id: config.id,\n      ignorePattern,\n      maxWorkers:\n        (options === null || options === void 0\n          ? void 0\n          : options.maxWorkers) || 1,\n      mocksPattern: (0, _jestRegexUtil().escapePathForRegex)(\n        `${path().sep}__mocks__${path().sep}`\n      ),\n      platforms: config.haste.platforms || ['ios', 'android'],\n      resetCache:\n        options === null || options === void 0 ? void 0 : options.resetCache,\n      retainAllFiles: config.haste.retainAllFiles || false,\n      rootDir: config.rootDir,\n      roots: config.roots,\n      throwOnModuleCollision: config.haste.throwOnModuleCollision,\n      useWatchman:\n        options === null || options === void 0 ? void 0 : options.watchman,\n      watch: options === null || options === void 0 ? void 0 : options.watch\n    });\n  }\n\n  static createResolver(config, moduleMap) {\n    return new (_jestResolve().default)(moduleMap, {\n      defaultPlatform: config.haste.defaultPlatform,\n      extensions: config.moduleFileExtensions.map(extension => `.${extension}`),\n      hasCoreModules: true,\n      moduleDirectories: config.moduleDirectories,\n      moduleNameMapper: getModuleNameMapper(config),\n      modulePaths: config.modulePaths,\n      platforms: config.haste.platforms,\n      resolver: config.resolver,\n      rootDir: config.rootDir\n    });\n  }\n\n  static async runCLI() {\n    throw new Error('The jest-runtime CLI has been moved into jest-repl');\n  }\n\n  static getCLIOptions() {\n    throw new Error('The jest-runtime CLI has been moved into jest-repl');\n  } // unstable as it should be replaced by https://github.com/nodejs/modules/issues/393, and we don't want people to use it\n\n  unstable_shouldLoadAsEsm(path) {\n    return _jestResolve().default.unstable_shouldLoadAsEsm(\n      path,\n      this._config.extensionsToTreatAsEsm\n    );\n  } // not async _now_, but transform will be\n\n  async loadEsmModule(modulePath, query = '') {\n    const cacheKey = modulePath + query;\n\n    if (this._fileTransformsMutex.has(cacheKey)) {\n      await this._fileTransformsMutex.get(cacheKey);\n    }\n\n    if (!this._esmoduleRegistry.has(cacheKey)) {\n      invariant(\n        typeof this._environment.getVmContext === 'function',\n        'ES Modules are only supported if your test environment has the `getVmContext` function'\n      );\n\n      const context = this._environment.getVmContext();\n\n      invariant(context, 'Test environment has been torn down');\n      let transformResolve;\n      let transformReject;\n\n      this._fileTransformsMutex.set(\n        cacheKey,\n        new Promise((resolve, reject) => {\n          transformResolve = resolve;\n          transformReject = reject;\n        })\n      );\n\n      invariant(\n        transformResolve && transformReject,\n        'Promise initialization should be sync - please report this bug to Jest!'\n      );\n\n      if (this._resolver.isCoreModule(modulePath)) {\n        const core = this._importCoreModule(modulePath, context);\n\n        this._esmoduleRegistry.set(cacheKey, core);\n\n        transformResolve();\n        return core;\n      }\n\n      const transformedCode = await this.transformFileAsync(modulePath, {\n        isInternalModule: false,\n        supportsDynamicImport: true,\n        supportsExportNamespaceFrom: true,\n        supportsStaticESM: true,\n        supportsTopLevelAwait\n      });\n\n      try {\n        const module = new (_vm().SourceTextModule)(transformedCode, {\n          context,\n          identifier: modulePath,\n          importModuleDynamically: async (specifier, referencingModule) => {\n            invariant(\n              runtimeSupportsVmModules,\n              'You need to run with a version of node that supports ES Modules in the VM API. See https://jestjs.io/docs/ecmascript-modules'\n            );\n            const module = await this.resolveModule(\n              specifier,\n              referencingModule.identifier,\n              referencingModule.context\n            );\n            return this.linkAndEvaluateModule(module);\n          },\n          initializeImportMeta: meta => {\n            meta.url = (0, _url().pathToFileURL)(modulePath).href;\n            let jest = this.jestObjectCaches.get(modulePath);\n\n            if (!jest) {\n              jest = this._createJestObjectFor(modulePath);\n              this.jestObjectCaches.set(modulePath, jest);\n            }\n\n            meta.jest = jest;\n          }\n        });\n        invariant(\n          !this._esmoduleRegistry.has(cacheKey),\n          `Module cache already has entry ${cacheKey}. This is a bug in Jest, please report it!`\n        );\n\n        this._esmoduleRegistry.set(cacheKey, module);\n\n        transformResolve();\n      } catch (error) {\n        transformReject(error);\n        throw error;\n      }\n    }\n\n    const module = this._esmoduleRegistry.get(cacheKey);\n\n    invariant(\n      module,\n      'Module cache does not contain module. This is a bug in Jest, please open up an issue'\n    );\n    return module;\n  }\n\n  async resolveModule(specifier, referencingIdentifier, context) {\n    if (this.isTornDown) {\n      this._logFormattedReferenceError(\n        'You are trying to `import` a file after the Jest environment has been torn down.'\n      );\n\n      process.exitCode = 1; // @ts-expect-error - exiting\n\n      return;\n    }\n\n    if (specifier === '@jest/globals') {\n      const fromCache = this._esmoduleRegistry.get('@jest/globals');\n\n      if (fromCache) {\n        return fromCache;\n      }\n\n      const globals = this.getGlobalsForEsm(referencingIdentifier, context);\n\n      this._esmoduleRegistry.set('@jest/globals', globals);\n\n      return globals;\n    }\n\n    if (specifier.startsWith('data:')) {\n      if (\n        await this._shouldMockModule(\n          referencingIdentifier,\n          specifier,\n          this._explicitShouldMockModule,\n          {\n            conditions: this.esmConditions\n          }\n        )\n      ) {\n        return this.importMock(referencingIdentifier, specifier, context);\n      }\n\n      const fromCache = this._esmoduleRegistry.get(specifier);\n\n      if (fromCache) {\n        return fromCache;\n      }\n\n      const match = specifier.match(dataURIRegex);\n\n      if (!match || !match.groups) {\n        throw new Error('Invalid data URI');\n      }\n\n      const mime = match.groups.mime;\n\n      if (mime === 'application/wasm') {\n        throw new Error('WASM is currently not supported');\n      }\n\n      const encoding = match.groups.encoding;\n      let code = match.groups.code;\n\n      if (!encoding || encoding === 'charset=utf-8') {\n        code = decodeURIComponent(code);\n      } else if (encoding === 'base64') {\n        code = Buffer.from(code, 'base64').toString();\n      } else {\n        throw new Error(`Invalid data URI encoding: ${encoding}`);\n      }\n\n      let module;\n\n      if (mime === 'application/json') {\n        module = new (_vm().SyntheticModule)(\n          ['default'],\n          function () {\n            const obj = JSON.parse(code); // @ts-expect-error: TS doesn't know what `this` is\n\n            this.setExport('default', obj);\n          },\n          {\n            context,\n            identifier: specifier\n          }\n        );\n      } else {\n        module = new (_vm().SourceTextModule)(code, {\n          context,\n          identifier: specifier,\n          importModuleDynamically: async (specifier, referencingModule) => {\n            invariant(\n              runtimeSupportsVmModules,\n              'You need to run with a version of node that supports ES Modules in the VM API. See https://jestjs.io/docs/ecmascript-modules'\n            );\n            const module = await this.resolveModule(\n              specifier,\n              referencingModule.identifier,\n              referencingModule.context\n            );\n            return this.linkAndEvaluateModule(module);\n          },\n\n          initializeImportMeta(meta) {\n            // no `jest` here as it's not loaded in a file\n            meta.url = specifier;\n          }\n        });\n      }\n\n      this._esmoduleRegistry.set(specifier, module);\n\n      return module;\n    }\n\n    if (specifier.startsWith('file://')) {\n      specifier = (0, _url().fileURLToPath)(specifier);\n    }\n\n    const [path, query] = specifier.split('?');\n\n    if (\n      await this._shouldMockModule(\n        referencingIdentifier,\n        path,\n        this._explicitShouldMockModule,\n        {\n          conditions: this.esmConditions\n        }\n      )\n    ) {\n      return this.importMock(referencingIdentifier, path, context);\n    }\n\n    const resolved = await this._resolveModule(referencingIdentifier, path, {\n      conditions: this.esmConditions\n    });\n\n    if (\n      this._resolver.isCoreModule(resolved) ||\n      this.unstable_shouldLoadAsEsm(resolved)\n    ) {\n      return this.loadEsmModule(resolved, query);\n    }\n\n    return this.loadCjsAsEsm(referencingIdentifier, resolved, context);\n  }\n\n  async linkAndEvaluateModule(module) {\n    if (this.isTornDown) {\n      this._logFormattedReferenceError(\n        'You are trying to `import` a file after the Jest environment has been torn down.'\n      );\n\n      process.exitCode = 1;\n      return;\n    }\n\n    if (module.status === 'unlinked') {\n      // since we might attempt to link the same module in parallel, stick the promise in a weak map so every call to\n      // this method can await it\n      this._esmModuleLinkingMap.set(\n        module,\n        module.link((specifier, referencingModule) =>\n          this.resolveModule(\n            specifier,\n            referencingModule.identifier,\n            referencingModule.context\n          )\n        )\n      );\n    }\n\n    await this._esmModuleLinkingMap.get(module);\n\n    if (module.status === 'linked') {\n      await module.evaluate();\n    }\n\n    return module;\n  }\n\n  async unstable_importModule(from, moduleName) {\n    invariant(\n      runtimeSupportsVmModules,\n      'You need to run with a version of node that supports ES Modules in the VM API. See https://jestjs.io/docs/ecmascript-modules'\n    );\n    const [path, query] = (\n      moduleName !== null && moduleName !== void 0 ? moduleName : ''\n    ).split('?');\n    const modulePath = await this._resolveModule(from, path, {\n      conditions: this.esmConditions\n    });\n    const module = await this.loadEsmModule(modulePath, query);\n    return this.linkAndEvaluateModule(module);\n  }\n\n  loadCjsAsEsm(from, modulePath, context) {\n    // CJS loaded via `import` should share cache with other CJS: https://github.com/nodejs/modules/issues/503\n    const cjs = this.requireModuleOrMock(from, modulePath);\n    const parsedExports = this.getExportsOfCjs(modulePath);\n    const cjsExports = [...parsedExports].filter(exportName => {\n      // we don't wanna respect any exports _named_ default as a named export\n      if (exportName === 'default') {\n        return false;\n      }\n\n      return Object.hasOwnProperty.call(cjs, exportName);\n    });\n    const module = new (_vm().SyntheticModule)(\n      [...cjsExports, 'default'],\n      function () {\n        cjsExports.forEach(exportName => {\n          // @ts-expect-error: TS doesn't know what `this` is\n          this.setExport(exportName, cjs[exportName]);\n        }); // @ts-expect-error: TS doesn't know what `this` is\n\n        this.setExport('default', cjs);\n      },\n      {\n        context,\n        identifier: modulePath\n      }\n    );\n    return evaluateSyntheticModule(module);\n  }\n\n  async importMock(from, moduleName, context) {\n    const moduleID = await this._resolver.getModuleIDAsync(\n      this._virtualModuleMocks,\n      from,\n      moduleName,\n      {\n        conditions: this.esmConditions\n      }\n    );\n\n    if (this._moduleMockRegistry.has(moduleID)) {\n      return this._moduleMockRegistry.get(moduleID);\n    }\n\n    if (this._moduleMockFactories.has(moduleID)) {\n      const invokedFactory = await this._moduleMockFactories.get(\n        moduleID // has check above makes this ok\n      )();\n      const module = new (_vm().SyntheticModule)(\n        Object.keys(invokedFactory),\n        function () {\n          Object.entries(invokedFactory).forEach(([key, value]) => {\n            // @ts-expect-error: TS doesn't know what `this` is\n            this.setExport(key, value);\n          });\n        },\n        {\n          context,\n          identifier: moduleName\n        }\n      );\n\n      this._moduleMockRegistry.set(moduleID, module);\n\n      return evaluateSyntheticModule(module);\n    }\n\n    throw new Error('Attempting to import a mock without a factory');\n  }\n\n  getExportsOfCjs(modulePath) {\n    var _this$_fileTransforms, _this$_fileTransforms2;\n\n    const cachedNamedExports = this._cjsNamedExports.get(modulePath);\n\n    if (cachedNamedExports) {\n      return cachedNamedExports;\n    }\n\n    const transformedCode =\n      (_this$_fileTransforms =\n        (_this$_fileTransforms2 = this._fileTransforms.get(modulePath)) ===\n          null || _this$_fileTransforms2 === void 0\n          ? void 0\n          : _this$_fileTransforms2.code) !== null &&\n      _this$_fileTransforms !== void 0\n        ? _this$_fileTransforms\n        : this.readFile(modulePath);\n    const {exports, reexports} = (0, _cjsModuleLexer().parse)(transformedCode);\n    const namedExports = new Set(exports);\n    reexports.forEach(reexport => {\n      const resolved = this._resolveCjsModule(modulePath, reexport, {\n        conditions: this.esmConditions\n      });\n\n      const exports = this.getExportsOfCjs(resolved);\n      exports.forEach(namedExports.add, namedExports);\n    });\n\n    this._cjsNamedExports.set(modulePath, namedExports);\n\n    return namedExports;\n  }\n\n  requireModule(from, moduleName, options, isRequireActual = false) {\n    var _options$isInternalMo;\n\n    const isInternal =\n      (_options$isInternalMo =\n        options === null || options === void 0\n          ? void 0\n          : options.isInternalModule) !== null &&\n      _options$isInternalMo !== void 0\n        ? _options$isInternalMo\n        : false;\n\n    const moduleID = this._resolver.getModuleID(\n      this._virtualMocks,\n      from,\n      moduleName,\n      {\n        conditions: this.cjsConditions\n      }\n    );\n\n    let modulePath; // Some old tests rely on this mocking behavior. Ideally we'll change this\n    // to be more explicit.\n\n    const moduleResource = moduleName && this._resolver.getModule(moduleName);\n\n    const manualMock =\n      moduleName && this._resolver.getMockModule(from, moduleName);\n\n    if (\n      !(options !== null && options !== void 0 && options.isInternalModule) &&\n      !isRequireActual &&\n      !moduleResource &&\n      manualMock &&\n      manualMock !== this._isCurrentlyExecutingManualMock &&\n      this._explicitShouldMock.get(moduleID) !== false\n    ) {\n      modulePath = manualMock;\n    }\n\n    if (moduleName && this._resolver.isCoreModule(moduleName)) {\n      return this._requireCoreModule(\n        moduleName,\n        supportsNodeColonModulePrefixInRequire\n      );\n    }\n\n    if (!modulePath) {\n      modulePath = this._resolveCjsModule(from, moduleName, {\n        conditions: this.cjsConditions\n      });\n    }\n\n    if (this.unstable_shouldLoadAsEsm(modulePath)) {\n      // Node includes more info in the message\n      const error = new Error(\n        `Must use import to load ES Module: ${modulePath}`\n      );\n      error.code = 'ERR_REQUIRE_ESM';\n      throw error;\n    }\n\n    let moduleRegistry;\n\n    if (isInternal) {\n      moduleRegistry = this._internalModuleRegistry;\n    } else if (this._isolatedModuleRegistry) {\n      moduleRegistry = this._isolatedModuleRegistry;\n    } else {\n      moduleRegistry = this._moduleRegistry;\n    }\n\n    const module = moduleRegistry.get(modulePath);\n\n    if (module) {\n      return module.exports;\n    } // We must register the pre-allocated module object first so that any\n    // circular dependencies that may arise while evaluating the module can\n    // be satisfied.\n\n    const localModule = {\n      children: [],\n      exports: {},\n      filename: modulePath,\n      id: modulePath,\n      loaded: false,\n      path: path().dirname(modulePath)\n    };\n    moduleRegistry.set(modulePath, localModule);\n\n    try {\n      this._loadModule(\n        localModule,\n        from,\n        moduleName,\n        modulePath,\n        options,\n        moduleRegistry\n      );\n    } catch (error) {\n      moduleRegistry.delete(modulePath);\n      throw error;\n    }\n\n    return localModule.exports;\n  }\n\n  requireInternalModule(from, to) {\n    if (to) {\n      var _nativeModule$createR;\n\n      const require = (\n        (_nativeModule$createR = _module().default.createRequire) !== null &&\n          _nativeModule$createR !== void 0\n          ? _nativeModule$createR\n          : _module().default.createRequireFromPath\n      )(from);\n\n      if (INTERNAL_MODULE_REQUIRE_OUTSIDE_OPTIMIZED_MODULES.has(to)) {\n        return require(to);\n      }\n\n      const outsideJestVmPath = (0, _helpers.decodePossibleOutsideJestVmPath)(\n        to\n      );\n\n      if (outsideJestVmPath) {\n        return require(outsideJestVmPath);\n      }\n    }\n\n    return this.requireModule(from, to, {\n      isInternalModule: true,\n      supportsDynamicImport: esmIsAvailable,\n      supportsExportNamespaceFrom: false,\n      supportsStaticESM: false,\n      supportsTopLevelAwait: false\n    });\n  }\n\n  requireActual(from, moduleName) {\n    return this.requireModule(from, moduleName, undefined, true);\n  }\n\n  requireMock(from, moduleName) {\n    var _this$_isolatedMockRe;\n\n    const moduleID = this._resolver.getModuleID(\n      this._virtualMocks,\n      from,\n      moduleName,\n      {\n        conditions: this.cjsConditions\n      }\n    );\n\n    if (\n      (_this$_isolatedMockRe = this._isolatedMockRegistry) !== null &&\n      _this$_isolatedMockRe !== void 0 &&\n      _this$_isolatedMockRe.has(moduleID)\n    ) {\n      return this._isolatedMockRegistry.get(moduleID);\n    } else if (this._mockRegistry.has(moduleID)) {\n      return this._mockRegistry.get(moduleID);\n    }\n\n    const mockRegistry = this._isolatedMockRegistry || this._mockRegistry;\n\n    if (this._mockFactories.has(moduleID)) {\n      // has check above makes this ok\n      const module = this._mockFactories.get(moduleID)();\n\n      mockRegistry.set(moduleID, module);\n      return module;\n    }\n\n    const manualMockOrStub = this._resolver.getMockModule(from, moduleName);\n\n    let modulePath =\n      this._resolver.getMockModule(from, moduleName) ||\n      this._resolveCjsModule(from, moduleName, {\n        conditions: this.cjsConditions\n      });\n\n    let isManualMock =\n      manualMockOrStub &&\n      !this._resolver.resolveStubModuleName(from, moduleName);\n\n    if (!isManualMock) {\n      // If the actual module file has a __mocks__ dir sitting immediately next\n      // to it, look to see if there is a manual mock for this file.\n      //\n      // subDir1/my_module.js\n      // subDir1/__mocks__/my_module.js\n      // subDir2/my_module.js\n      // subDir2/__mocks__/my_module.js\n      //\n      // Where some other module does a relative require into each of the\n      // respective subDir{1,2} directories and expects a manual mock\n      // corresponding to that particular my_module.js file.\n      const moduleDir = path().dirname(modulePath);\n      const moduleFileName = path().basename(modulePath);\n      const potentialManualMock = path().join(\n        moduleDir,\n        '__mocks__',\n        moduleFileName\n      );\n\n      if (fs().existsSync(potentialManualMock)) {\n        isManualMock = true;\n        modulePath = potentialManualMock;\n      }\n    }\n\n    if (isManualMock) {\n      const localModule = {\n        children: [],\n        exports: {},\n        filename: modulePath,\n        id: modulePath,\n        loaded: false,\n        path: path().dirname(modulePath)\n      };\n\n      this._loadModule(\n        localModule,\n        from,\n        moduleName,\n        modulePath,\n        undefined,\n        mockRegistry\n      );\n\n      mockRegistry.set(moduleID, localModule.exports);\n    } else {\n      // Look for a real module to generate an automock from\n      mockRegistry.set(moduleID, this._generateMock(from, moduleName));\n    }\n\n    return mockRegistry.get(moduleID);\n  }\n\n  _loadModule(\n    localModule,\n    from,\n    moduleName,\n    modulePath,\n    options,\n    moduleRegistry\n  ) {\n    if (path().extname(modulePath) === '.json') {\n      const text = (0, _stripBom().default)(this.readFile(modulePath));\n\n      const transformedFile = this._scriptTransformer.transformJson(\n        modulePath,\n        this._getFullTransformationOptions(options),\n        text\n      );\n\n      localModule.exports =\n        this._environment.global.JSON.parse(transformedFile);\n    } else if (path().extname(modulePath) === '.node') {\n      localModule.exports = require(modulePath);\n    } else {\n      // Only include the fromPath if a moduleName is given. Else treat as root.\n      const fromPath = moduleName ? from : null;\n\n      this._execModule(localModule, options, moduleRegistry, fromPath);\n    }\n\n    localModule.loaded = true;\n  }\n\n  _getFullTransformationOptions(options = defaultTransformOptions) {\n    return {...options, ...this._coverageOptions};\n  }\n\n  requireModuleOrMock(from, moduleName) {\n    // this module is unmockable\n    if (moduleName === '@jest/globals') {\n      // @ts-expect-error: we don't care that it's not assignable to T\n      return this.getGlobalsForCjs(from);\n    }\n\n    try {\n      if (\n        this._shouldMockCjs(from, moduleName, this._explicitShouldMock, {\n          conditions: this.cjsConditions\n        })\n      ) {\n        return this.requireMock(from, moduleName);\n      } else {\n        return this.requireModule(from, moduleName);\n      }\n    } catch (e) {\n      const moduleNotFound =\n        _jestResolve().default.tryCastModuleNotFoundError(e);\n\n      if (moduleNotFound) {\n        if (\n          moduleNotFound.siblingWithSimilarExtensionFound === null ||\n          moduleNotFound.siblingWithSimilarExtensionFound === undefined\n        ) {\n          moduleNotFound.hint = (0, _helpers.findSiblingsWithFileExtension)(\n            this._config.moduleFileExtensions,\n            from,\n            moduleNotFound.moduleName || moduleName\n          );\n          moduleNotFound.siblingWithSimilarExtensionFound = Boolean(\n            moduleNotFound.hint\n          );\n        }\n\n        moduleNotFound.buildMessage(this._config.rootDir);\n        throw moduleNotFound;\n      }\n\n      throw e;\n    }\n  }\n\n  isolateModules(fn) {\n    if (this._isolatedModuleRegistry || this._isolatedMockRegistry) {\n      throw new Error(\n        'isolateModules cannot be nested inside another isolateModules.'\n      );\n    }\n\n    this._isolatedModuleRegistry = new Map();\n    this._isolatedMockRegistry = new Map();\n\n    try {\n      fn();\n    } finally {\n      var _this$_isolatedModule, _this$_isolatedMockRe2;\n\n      // might be cleared within the callback\n      (_this$_isolatedModule = this._isolatedModuleRegistry) === null ||\n      _this$_isolatedModule === void 0\n        ? void 0\n        : _this$_isolatedModule.clear();\n      (_this$_isolatedMockRe2 = this._isolatedMockRegistry) === null ||\n      _this$_isolatedMockRe2 === void 0\n        ? void 0\n        : _this$_isolatedMockRe2.clear();\n      this._isolatedModuleRegistry = null;\n      this._isolatedMockRegistry = null;\n    }\n  }\n\n  resetModules() {\n    var _this$_isolatedModule2, _this$_isolatedMockRe3;\n\n    (_this$_isolatedModule2 = this._isolatedModuleRegistry) === null ||\n    _this$_isolatedModule2 === void 0\n      ? void 0\n      : _this$_isolatedModule2.clear();\n    (_this$_isolatedMockRe3 = this._isolatedMockRegistry) === null ||\n    _this$_isolatedMockRe3 === void 0\n      ? void 0\n      : _this$_isolatedMockRe3.clear();\n    this._isolatedModuleRegistry = null;\n    this._isolatedMockRegistry = null;\n\n    this._mockRegistry.clear();\n\n    this._moduleRegistry.clear();\n\n    this._esmoduleRegistry.clear();\n\n    this._cjsNamedExports.clear();\n\n    this._moduleMockRegistry.clear();\n\n    this._cacheFS.clear();\n\n    if (\n      this._coverageOptions.collectCoverage &&\n      this._coverageOptions.coverageProvider === 'v8' &&\n      this._v8CoverageSources\n    ) {\n      this._v8CoverageSources = new Map([\n        ...this._v8CoverageSources,\n        ...this._fileTransforms\n      ]);\n    }\n\n    this._fileTransforms.clear();\n\n    if (this._environment) {\n      if (this._environment.global) {\n        const envGlobal = this._environment.global;\n        Object.keys(envGlobal).forEach(key => {\n          const globalMock = envGlobal[key];\n\n          if (\n            ((typeof globalMock === 'object' && globalMock !== null) ||\n              typeof globalMock === 'function') &&\n            globalMock._isMockFunction === true\n          ) {\n            globalMock.mockClear();\n          }\n        });\n      }\n\n      if (this._environment.fakeTimers) {\n        this._environment.fakeTimers.clearAllTimers();\n      }\n    }\n  }\n\n  async collectV8Coverage() {\n    this._v8CoverageInstrumenter =\n      new (_collectV8Coverage().CoverageInstrumenter)();\n    this._v8CoverageSources = new Map();\n    await this._v8CoverageInstrumenter.startInstrumenting();\n  }\n\n  async stopCollectingV8Coverage() {\n    if (!this._v8CoverageInstrumenter || !this._v8CoverageSources) {\n      throw new Error('You need to call `collectV8Coverage` first.');\n    }\n\n    this._v8CoverageResult =\n      await this._v8CoverageInstrumenter.stopInstrumenting();\n    this._v8CoverageSources = new Map([\n      ...this._v8CoverageSources,\n      ...this._fileTransforms\n    ]);\n  }\n\n  getAllCoverageInfoCopy() {\n    return (0, _jestUtil().deepCyclicCopy)(\n      this._environment.global.__coverage__\n    );\n  }\n\n  getAllV8CoverageInfoCopy() {\n    if (!this._v8CoverageResult || !this._v8CoverageSources) {\n      throw new Error('You need to call `stopCollectingV8Coverage` first.');\n    }\n\n    return this._v8CoverageResult\n      .filter(res => res.url.startsWith('file://'))\n      .map(res => ({...res, url: (0, _url().fileURLToPath)(res.url)}))\n      .filter(\n        (\n          res // TODO: will this work on windows? It might be better if `shouldInstrument` deals with it anyways\n        ) =>\n          res.url.startsWith(this._config.rootDir) &&\n          this._v8CoverageSources.has(res.url) &&\n          (0, _transform().shouldInstrument)(\n            res.url,\n            this._coverageOptions,\n            this._config\n          )\n      )\n      .map(result => {\n        const transformedFile = this._v8CoverageSources.get(result.url);\n\n        return {\n          codeTransformResult: transformedFile,\n          result\n        };\n      });\n  }\n\n  getSourceMaps() {\n    return this._sourceMapRegistry;\n  }\n\n  setMock(from, moduleName, mockFactory, options) {\n    if (options !== null && options !== void 0 && options.virtual) {\n      const mockPath = this._resolver.getModulePath(from, moduleName);\n\n      this._virtualMocks.set(mockPath, true);\n    }\n\n    const moduleID = this._resolver.getModuleID(\n      this._virtualMocks,\n      from,\n      moduleName,\n      {\n        conditions: this.cjsConditions\n      }\n    );\n\n    this._explicitShouldMock.set(moduleID, true);\n\n    this._mockFactories.set(moduleID, mockFactory);\n  }\n\n  setModuleMock(from, moduleName, mockFactory, options) {\n    if (options !== null && options !== void 0 && options.virtual) {\n      const mockPath = this._resolver.getModulePath(from, moduleName);\n\n      this._virtualModuleMocks.set(mockPath, true);\n    }\n\n    const moduleID = this._resolver.getModuleID(\n      this._virtualModuleMocks,\n      from,\n      moduleName,\n      {\n        conditions: this.esmConditions\n      }\n    );\n\n    this._explicitShouldMockModule.set(moduleID, true);\n\n    this._moduleMockFactories.set(moduleID, mockFactory);\n  }\n\n  restoreAllMocks() {\n    this._moduleMocker.restoreAllMocks();\n  }\n\n  resetAllMocks() {\n    this._moduleMocker.resetAllMocks();\n  }\n\n  clearAllMocks() {\n    this._moduleMocker.clearAllMocks();\n  }\n\n  teardown() {\n    var _this$_v8CoverageSour;\n\n    this.restoreAllMocks();\n    this.resetAllMocks();\n    this.resetModules();\n\n    this._internalModuleRegistry.clear();\n\n    this._mainModule = null;\n\n    this._mockFactories.clear();\n\n    this._moduleMockFactories.clear();\n\n    this._mockMetaDataCache.clear();\n\n    this._shouldMockModuleCache.clear();\n\n    this._shouldUnmockTransitiveDependenciesCache.clear();\n\n    this._explicitShouldMock.clear();\n\n    this._explicitShouldMockModule.clear();\n\n    this._transitiveShouldMock.clear();\n\n    this._virtualMocks.clear();\n\n    this._virtualModuleMocks.clear();\n\n    this._cacheFS.clear();\n\n    this._unmockList = undefined;\n\n    this._sourceMapRegistry.clear();\n\n    this._fileTransforms.clear();\n\n    this._fileTransformsMutex.clear();\n\n    this.jestObjectCaches.clear();\n    (_this$_v8CoverageSour = this._v8CoverageSources) === null ||\n    _this$_v8CoverageSour === void 0\n      ? void 0\n      : _this$_v8CoverageSour.clear();\n    this._v8CoverageResult = [];\n    this._v8CoverageInstrumenter = undefined;\n    this._moduleImplementation = undefined;\n    this.isTornDown = true;\n  }\n\n  _resolveCjsModule(from, to, options) {\n    return to ? this._resolver.resolveModule(from, to, options) : from;\n  }\n\n  _resolveModule(from, to, options) {\n    return to ? this._resolver.resolveModuleAsync(from, to, options) : from;\n  }\n\n  _requireResolve(from, moduleName, options = {}) {\n    if (moduleName == null) {\n      throw new Error(\n        'The first argument to require.resolve must be a string. Received null or undefined.'\n      );\n    }\n\n    if (path().isAbsolute(moduleName)) {\n      const module = this._resolver.resolveModuleFromDirIfExists(\n        moduleName,\n        moduleName,\n        {\n          conditions: this.cjsConditions,\n          paths: []\n        }\n      );\n\n      if (module) {\n        return module;\n      }\n    } else {\n      const {paths} = options;\n\n      if (paths) {\n        for (const p of paths) {\n          const absolutePath = path().resolve(from, '..', p);\n\n          const module = this._resolver.resolveModuleFromDirIfExists(\n            absolutePath,\n            moduleName, // required to also resolve files without leading './' directly in the path\n            {\n              conditions: this.cjsConditions,\n              paths: [absolutePath]\n            }\n          );\n\n          if (module) {\n            return module;\n          }\n        }\n\n        throw new (_jestResolve().default.ModuleNotFoundError)(\n          `Cannot resolve module '${moduleName}' from paths ['${paths.join(\n            \"', '\"\n          )}'] from ${from}`\n        );\n      }\n    }\n\n    try {\n      return this._resolveCjsModule(from, moduleName, {\n        conditions: this.cjsConditions\n      });\n    } catch (err) {\n      const module = this._resolver.getMockModule(from, moduleName);\n\n      if (module) {\n        return module;\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  _requireResolvePaths(from, moduleName) {\n    if (moduleName == null) {\n      throw new Error(\n        'The first argument to require.resolve.paths must be a string. Received null or undefined.'\n      );\n    }\n\n    if (!moduleName.length) {\n      throw new Error(\n        'The first argument to require.resolve.paths must not be the empty string.'\n      );\n    }\n\n    if (moduleName[0] === '.') {\n      return [path().resolve(from, '..')];\n    }\n\n    if (this._resolver.isCoreModule(moduleName)) {\n      return null;\n    }\n\n    return this._resolver.getModulePaths(path().resolve(from, '..'));\n  }\n\n  _execModule(localModule, options, moduleRegistry, from) {\n    if (this.isTornDown) {\n      this._logFormattedReferenceError(\n        'You are trying to `import` a file after the Jest environment has been torn down.'\n      );\n\n      process.exitCode = 1;\n      return;\n    } // If the environment was disposed, prevent this module from being executed.\n\n    if (!this._environment.global) {\n      return;\n    }\n\n    const module = localModule;\n    const filename = module.filename;\n    const lastExecutingModulePath = this._currentlyExecutingModulePath;\n    this._currentlyExecutingModulePath = filename;\n    const origCurrExecutingManualMock = this._isCurrentlyExecutingManualMock;\n    this._isCurrentlyExecutingManualMock = filename;\n    module.children = [];\n    Object.defineProperty(module, 'parent', {\n      enumerable: true,\n\n      get() {\n        const key = from || '';\n        return moduleRegistry.get(key) || null;\n      }\n    });\n    module.paths = this._resolver.getModulePaths(module.path);\n    Object.defineProperty(module, 'require', {\n      value: this._createRequireImplementation(module, options)\n    });\n    const transformedCode = this.transformFile(filename, options);\n    let compiledFunction = null;\n    const script = this.createScriptFromCode(transformedCode, filename);\n    let runScript = null;\n\n    const vmContext = this._environment.getVmContext();\n\n    if (vmContext) {\n      runScript = script.runInContext(vmContext, {\n        filename\n      });\n    }\n\n    if (runScript !== null) {\n      compiledFunction = runScript[EVAL_RESULT_VARIABLE];\n    }\n\n    if (compiledFunction === null) {\n      this._logFormattedReferenceError(\n        'You are trying to `import` a file after the Jest environment has been torn down.'\n      );\n\n      process.exitCode = 1;\n      return;\n    }\n\n    const jestObject = this._createJestObjectFor(filename);\n\n    this.jestObjectCaches.set(filename, jestObject);\n    const lastArgs = [\n      this._config.injectGlobals ? jestObject : undefined, // jest object\n      ...this._config.sandboxInjectedGlobals.map(globalVariable => {\n        if (this._environment.global[globalVariable]) {\n          return this._environment.global[globalVariable];\n        }\n\n        throw new Error(\n          `You have requested '${globalVariable}' as a global variable, but it was not present. Please check your config or your global environment.`\n        );\n      })\n    ];\n\n    if (!this._mainModule && filename === this._testPath) {\n      this._mainModule = module;\n    }\n\n    Object.defineProperty(module, 'main', {\n      enumerable: true,\n      value: this._mainModule\n    });\n\n    try {\n      compiledFunction.call(\n        module.exports,\n        module, // module object\n        module.exports, // module exports\n        module.require, // require implementation\n        module.path, // __dirname\n        module.filename, // __filename\n        lastArgs[0],\n        ...lastArgs.slice(1).filter(notEmpty)\n      );\n    } catch (error) {\n      this.handleExecutionError(error, module);\n    }\n\n    this._isCurrentlyExecutingManualMock = origCurrExecutingManualMock;\n    this._currentlyExecutingModulePath = lastExecutingModulePath;\n  }\n\n  transformFile(filename, options) {\n    const source = this.readFile(filename);\n\n    if (options !== null && options !== void 0 && options.isInternalModule) {\n      return source;\n    }\n\n    let transformedFile = this._fileTransforms.get(filename);\n\n    if (transformedFile) {\n      return transformedFile.code;\n    }\n\n    transformedFile = this._scriptTransformer.transform(\n      filename,\n      this._getFullTransformationOptions(options),\n      source\n    );\n\n    this._fileTransforms.set(filename, {\n      ...transformedFile,\n      wrapperLength: this.constructModuleWrapperStart().length\n    });\n\n    if (transformedFile.sourceMapPath) {\n      this._sourceMapRegistry.set(filename, transformedFile.sourceMapPath);\n    }\n\n    return transformedFile.code;\n  }\n\n  async transformFileAsync(filename, options) {\n    const source = this.readFile(filename);\n\n    if (options !== null && options !== void 0 && options.isInternalModule) {\n      return source;\n    }\n\n    let transformedFile = this._fileTransforms.get(filename);\n\n    if (transformedFile) {\n      return transformedFile.code;\n    }\n\n    transformedFile = await this._scriptTransformer.transformAsync(\n      filename,\n      this._getFullTransformationOptions(options),\n      source\n    );\n\n    this._fileTransforms.set(filename, {...transformedFile, wrapperLength: 0});\n\n    if (transformedFile.sourceMapPath) {\n      this._sourceMapRegistry.set(filename, transformedFile.sourceMapPath);\n    }\n\n    return transformedFile.code;\n  }\n\n  createScriptFromCode(scriptSource, filename) {\n    try {\n      const scriptFilename = this._resolver.isCoreModule(filename)\n        ? `jest-nodejs-core-${filename}`\n        : filename;\n      return new (_vm().Script)(this.wrapCodeInModuleWrapper(scriptSource), {\n        displayErrors: true,\n        filename: scriptFilename,\n        // @ts-expect-error: Experimental ESM API\n        importModuleDynamically: async specifier => {\n          var _this$_environment$ge, _this$_environment2;\n\n          invariant(\n            runtimeSupportsVmModules,\n            'You need to run with a version of node that supports ES Modules in the VM API. See https://jestjs.io/docs/ecmascript-modules'\n          );\n          const context =\n            (_this$_environment$ge = (_this$_environment2 = this._environment)\n              .getVmContext) === null || _this$_environment$ge === void 0\n              ? void 0\n              : _this$_environment$ge.call(_this$_environment2);\n          invariant(context, 'Test environment has been torn down');\n          const module = await this.resolveModule(\n            specifier,\n            scriptFilename,\n            context\n          );\n          return this.linkAndEvaluateModule(module);\n        }\n      });\n    } catch (e) {\n      throw (0, _transform().handlePotentialSyntaxError)(e);\n    }\n  }\n\n  _requireCoreModule(moduleName, supportPrefix) {\n    const moduleWithoutNodePrefix =\n      supportPrefix && moduleName.startsWith('node:')\n        ? moduleName.slice('node:'.length)\n        : moduleName;\n\n    if (moduleWithoutNodePrefix === 'process') {\n      return this._environment.global.process;\n    }\n\n    if (moduleWithoutNodePrefix === 'module') {\n      return this._getMockedNativeModule();\n    }\n\n    return require(moduleWithoutNodePrefix);\n  }\n\n  _importCoreModule(moduleName, context) {\n    const required = this._requireCoreModule(\n      moduleName,\n      supportsNodeColonModulePrefixInImport\n    );\n\n    const module = new (_vm().SyntheticModule)(\n      ['default', ...Object.keys(required)],\n      function () {\n        // @ts-expect-error: TS doesn't know what `this` is\n        this.setExport('default', required);\n        Object.entries(required).forEach(([key, value]) => {\n          // @ts-expect-error: TS doesn't know what `this` is\n          this.setExport(key, value);\n        });\n      }, // should identifier be `node://${moduleName}`?\n      {\n        context,\n        identifier: moduleName\n      }\n    );\n    return evaluateSyntheticModule(module);\n  }\n\n  _getMockedNativeModule() {\n    if (this._moduleImplementation) {\n      return this._moduleImplementation;\n    }\n\n    const createRequire = modulePath => {\n      const filename =\n        typeof modulePath === 'string'\n          ? modulePath.startsWith('file:///')\n            ? (0, _url().fileURLToPath)(new (_url().URL)(modulePath))\n            : modulePath\n          : (0, _url().fileURLToPath)(modulePath);\n\n      if (!path().isAbsolute(filename)) {\n        const error = new TypeError(\n          `The argument 'filename' must be a file URL object, file URL string, or absolute path string. Received '${filename}'`\n        );\n        error.code = 'ERR_INVALID_ARG_TYPE';\n        throw error;\n      }\n\n      return this._createRequireImplementation({\n        children: [],\n        exports: {},\n        filename,\n        id: filename,\n        loaded: false,\n        path: path().dirname(filename)\n      });\n    }; // should we implement the class ourselves?\n\n    class Module extends _module().default.Module {}\n\n    Object.entries(_module().default.Module).forEach(([key, value]) => {\n      // @ts-expect-error: no index signature\n      Module[key] = value;\n    });\n    Module.Module = Module;\n\n    if ('createRequire' in _module().default) {\n      Module.createRequire = createRequire;\n    }\n\n    if ('createRequireFromPath' in _module().default) {\n      Module.createRequireFromPath = function createRequireFromPath(filename) {\n        if (typeof filename !== 'string') {\n          const error = new TypeError(\n            `The argument 'filename' must be string. Received '${filename}'.${\n              filename instanceof _url().URL\n                ? ' Use createRequire for URL filename.'\n                : ''\n            }`\n          );\n          error.code = 'ERR_INVALID_ARG_TYPE';\n          throw error;\n        }\n\n        return createRequire(filename);\n      };\n    }\n\n    if ('syncBuiltinESMExports' in _module().default) {\n      // cast since TS seems very confused about whether it exists or not\n      Module.syncBuiltinESMExports = // eslint-disable-next-line @typescript-eslint/no-empty-function\n        function syncBuiltinESMExports() {};\n    }\n\n    this._moduleImplementation = Module;\n    return Module;\n  }\n\n  _generateMock(from, moduleName) {\n    const modulePath =\n      this._resolver.resolveStubModuleName(from, moduleName) ||\n      this._resolveCjsModule(from, moduleName, {\n        conditions: this.cjsConditions\n      });\n\n    if (!this._mockMetaDataCache.has(modulePath)) {\n      // This allows us to handle circular dependencies while generating an\n      // automock\n      this._mockMetaDataCache.set(\n        modulePath,\n        this._moduleMocker.getMetadata({}) || {}\n      ); // In order to avoid it being possible for automocking to potentially\n      // cause side-effects within the module environment, we need to execute\n      // the module in isolation. This could cause issues if the module being\n      // mocked has calls into side-effectful APIs on another module.\n\n      const origMockRegistry = this._mockRegistry;\n      const origModuleRegistry = this._moduleRegistry;\n      this._mockRegistry = new Map();\n      this._moduleRegistry = new Map();\n      const moduleExports = this.requireModule(from, moduleName); // Restore the \"real\" module/mock registries\n\n      this._mockRegistry = origMockRegistry;\n      this._moduleRegistry = origModuleRegistry;\n\n      const mockMetadata = this._moduleMocker.getMetadata(moduleExports);\n\n      if (mockMetadata == null) {\n        throw new Error(\n          `Failed to get mock metadata: ${modulePath}\\n\\n` +\n            'See: https://jestjs.io/docs/manual-mocks#content'\n        );\n      }\n\n      this._mockMetaDataCache.set(modulePath, mockMetadata);\n    }\n\n    return this._moduleMocker.generateFromMetadata(\n      // added above if missing\n      this._mockMetaDataCache.get(modulePath)\n    );\n  }\n\n  _shouldMockCjs(from, moduleName, explicitShouldMock, options) {\n    const moduleID = this._resolver.getModuleID(\n      this._virtualMocks,\n      from,\n      moduleName,\n      options\n    );\n\n    const key = from + path().delimiter + moduleID;\n\n    if (explicitShouldMock.has(moduleID)) {\n      // guaranteed by `has` above\n      return explicitShouldMock.get(moduleID);\n    }\n\n    if (\n      !this._shouldAutoMock ||\n      this._resolver.isCoreModule(moduleName) ||\n      this._shouldUnmockTransitiveDependenciesCache.get(key)\n    ) {\n      return false;\n    }\n\n    if (this._shouldMockModuleCache.has(moduleID)) {\n      // guaranteed by `has` above\n      return this._shouldMockModuleCache.get(moduleID);\n    }\n\n    let modulePath;\n\n    try {\n      modulePath = this._resolveCjsModule(from, moduleName, options);\n    } catch (e) {\n      const manualMock = this._resolver.getMockModule(from, moduleName);\n\n      if (manualMock) {\n        this._shouldMockModuleCache.set(moduleID, true);\n\n        return true;\n      }\n\n      throw e;\n    }\n\n    if (this._unmockList && this._unmockList.test(modulePath)) {\n      this._shouldMockModuleCache.set(moduleID, false);\n\n      return false;\n    } // transitive unmocking for package managers that store flat packages (npm3)\n\n    const currentModuleID = this._resolver.getModuleID(\n      this._virtualMocks,\n      from,\n      undefined,\n      options\n    );\n\n    if (\n      this._transitiveShouldMock.get(currentModuleID) === false ||\n      (from.includes(NODE_MODULES) &&\n        modulePath.includes(NODE_MODULES) &&\n        ((this._unmockList && this._unmockList.test(from)) ||\n          explicitShouldMock.get(currentModuleID) === false))\n    ) {\n      this._transitiveShouldMock.set(moduleID, false);\n\n      this._shouldUnmockTransitiveDependenciesCache.set(key, true);\n\n      return false;\n    }\n\n    this._shouldMockModuleCache.set(moduleID, true);\n\n    return true;\n  }\n\n  async _shouldMockModule(from, moduleName, explicitShouldMock, options) {\n    const moduleID = await this._resolver.getModuleIDAsync(\n      this._virtualMocks,\n      from,\n      moduleName,\n      options\n    );\n    const key = from + path().delimiter + moduleID;\n\n    if (explicitShouldMock.has(moduleID)) {\n      // guaranteed by `has` above\n      return explicitShouldMock.get(moduleID);\n    }\n\n    if (\n      !this._shouldAutoMock ||\n      this._resolver.isCoreModule(moduleName) ||\n      this._shouldUnmockTransitiveDependenciesCache.get(key)\n    ) {\n      return false;\n    }\n\n    if (this._shouldMockModuleCache.has(moduleID)) {\n      // guaranteed by `has` above\n      return this._shouldMockModuleCache.get(moduleID);\n    }\n\n    let modulePath;\n\n    try {\n      modulePath = await this._resolveModule(from, moduleName, options);\n    } catch (e) {\n      const manualMock = await this._resolver.getMockModuleAsync(\n        from,\n        moduleName\n      );\n\n      if (manualMock) {\n        this._shouldMockModuleCache.set(moduleID, true);\n\n        return true;\n      }\n\n      throw e;\n    }\n\n    if (this._unmockList && this._unmockList.test(modulePath)) {\n      this._shouldMockModuleCache.set(moduleID, false);\n\n      return false;\n    } // transitive unmocking for package managers that store flat packages (npm3)\n\n    const currentModuleID = await this._resolver.getModuleIDAsync(\n      this._virtualMocks,\n      from,\n      undefined,\n      options\n    );\n\n    if (\n      this._transitiveShouldMock.get(currentModuleID) === false ||\n      (from.includes(NODE_MODULES) &&\n        modulePath.includes(NODE_MODULES) &&\n        ((this._unmockList && this._unmockList.test(from)) ||\n          explicitShouldMock.get(currentModuleID) === false))\n    ) {\n      this._transitiveShouldMock.set(moduleID, false);\n\n      this._shouldUnmockTransitiveDependenciesCache.set(key, true);\n\n      return false;\n    }\n\n    this._shouldMockModuleCache.set(moduleID, true);\n\n    return true;\n  }\n\n  _createRequireImplementation(from, options) {\n    const resolve = (moduleName, resolveOptions) => {\n      const resolved = this._requireResolve(\n        from.filename,\n        moduleName,\n        resolveOptions\n      );\n\n      if (\n        resolveOptions !== null &&\n        resolveOptions !== void 0 &&\n        resolveOptions[JEST_RESOLVE_OUTSIDE_VM_OPTION] &&\n        options !== null &&\n        options !== void 0 &&\n        options.isInternalModule\n      ) {\n        return (0, _helpers.createOutsideJestVmPath)(resolved);\n      }\n\n      return resolved;\n    };\n\n    resolve.paths = moduleName =>\n      this._requireResolvePaths(from.filename, moduleName);\n\n    const moduleRequire =\n      options !== null && options !== void 0 && options.isInternalModule\n        ? moduleName => this.requireInternalModule(from.filename, moduleName)\n        : this.requireModuleOrMock.bind(this, from.filename);\n    moduleRequire.extensions = Object.create(null);\n    moduleRequire.resolve = resolve;\n\n    moduleRequire.cache = (() => {\n      // TODO: consider warning somehow that this does nothing. We should support deletions, anyways\n      const notPermittedMethod = () => true;\n\n      return new Proxy(Object.create(null), {\n        defineProperty: notPermittedMethod,\n        deleteProperty: notPermittedMethod,\n        get: (_target, key) =>\n          typeof key === 'string' ? this._moduleRegistry.get(key) : undefined,\n\n        getOwnPropertyDescriptor() {\n          return {\n            configurable: true,\n            enumerable: true\n          };\n        },\n\n        has: (_target, key) =>\n          typeof key === 'string' && this._moduleRegistry.has(key),\n        ownKeys: () => Array.from(this._moduleRegistry.keys()),\n        set: notPermittedMethod\n      });\n    })();\n\n    Object.defineProperty(moduleRequire, 'main', {\n      enumerable: true,\n      value: this._mainModule\n    });\n    return moduleRequire;\n  }\n\n  _createJestObjectFor(from) {\n    var _this$_moduleMocker$m, _this$_moduleMocker$m2;\n\n    const disableAutomock = () => {\n      this._shouldAutoMock = false;\n      return jestObject;\n    };\n\n    const enableAutomock = () => {\n      this._shouldAutoMock = true;\n      return jestObject;\n    };\n\n    const unmock = moduleName => {\n      const moduleID = this._resolver.getModuleID(\n        this._virtualMocks,\n        from,\n        moduleName,\n        {\n          conditions: this.cjsConditions\n        }\n      );\n\n      this._explicitShouldMock.set(moduleID, false);\n\n      return jestObject;\n    };\n\n    const deepUnmock = moduleName => {\n      const moduleID = this._resolver.getModuleID(\n        this._virtualMocks,\n        from,\n        moduleName,\n        {\n          conditions: this.cjsConditions\n        }\n      );\n\n      this._explicitShouldMock.set(moduleID, false);\n\n      this._transitiveShouldMock.set(moduleID, false);\n\n      return jestObject;\n    };\n\n    const mock = (moduleName, mockFactory, options) => {\n      if (mockFactory !== undefined) {\n        return setMockFactory(moduleName, mockFactory, options);\n      }\n\n      const moduleID = this._resolver.getModuleID(\n        this._virtualMocks,\n        from,\n        moduleName,\n        {\n          conditions: this.cjsConditions\n        }\n      );\n\n      this._explicitShouldMock.set(moduleID, true);\n\n      return jestObject;\n    };\n\n    const setMockFactory = (moduleName, mockFactory, options) => {\n      this.setMock(from, moduleName, mockFactory, options);\n      return jestObject;\n    };\n\n    const mockModule = (moduleName, mockFactory, options) => {\n      if (typeof mockFactory !== 'function') {\n        throw new Error('`unstable_mockModule` must be passed a mock factory');\n      }\n\n      this.setModuleMock(from, moduleName, mockFactory, options);\n      return jestObject;\n    };\n\n    const clearAllMocks = () => {\n      this.clearAllMocks();\n      return jestObject;\n    };\n\n    const resetAllMocks = () => {\n      this.resetAllMocks();\n      return jestObject;\n    };\n\n    const restoreAllMocks = () => {\n      this.restoreAllMocks();\n      return jestObject;\n    };\n\n    const _getFakeTimers = () => {\n      if (\n        this.isTornDown ||\n        !(this._environment.fakeTimers || this._environment.fakeTimersModern)\n      ) {\n        this._logFormattedReferenceError(\n          'You are trying to access a property or method of the Jest environment after it has been torn down.'\n        );\n\n        process.exitCode = 1;\n      }\n\n      return this._fakeTimersImplementation;\n    };\n\n    const useFakeTimers = fakeTimersConfig => {\n      var _fakeTimersConfig;\n\n      fakeTimersConfig = {...this._config.fakeTimers, ...fakeTimersConfig};\n\n      if (\n        (_fakeTimersConfig = fakeTimersConfig) !== null &&\n        _fakeTimersConfig !== void 0 &&\n        _fakeTimersConfig.legacyFakeTimers\n      ) {\n        this._fakeTimersImplementation = this._environment.fakeTimers;\n      } else {\n        this._fakeTimersImplementation = this._environment.fakeTimersModern;\n      }\n\n      this._fakeTimersImplementation.useFakeTimers(fakeTimersConfig);\n\n      return jestObject;\n    };\n\n    const useRealTimers = () => {\n      _getFakeTimers().useRealTimers();\n\n      return jestObject;\n    };\n\n    const resetModules = () => {\n      this.resetModules();\n      return jestObject;\n    };\n\n    const isolateModules = fn => {\n      this.isolateModules(fn);\n      return jestObject;\n    };\n\n    const fn = this._moduleMocker.fn.bind(this._moduleMocker);\n\n    const spyOn = this._moduleMocker.spyOn.bind(this._moduleMocker);\n\n    const mocked =\n      (_this$_moduleMocker$m =\n        (_this$_moduleMocker$m2 = this._moduleMocker.mocked) === null ||\n        _this$_moduleMocker$m2 === void 0\n          ? void 0\n          : _this$_moduleMocker$m2.bind(this._moduleMocker)) !== null &&\n      _this$_moduleMocker$m !== void 0\n        ? _this$_moduleMocker$m\n        : () => {\n            throw new Error(\n              'Your test environment does not support `mocked`, please update it.'\n            );\n          };\n\n    const setTimeout = timeout => {\n      this._environment.global[testTimeoutSymbol] = timeout;\n      return jestObject;\n    };\n\n    const retryTimes = (numTestRetries, options) => {\n      this._environment.global[retryTimesSymbol] = numTestRetries;\n      this._environment.global[logErrorsBeforeRetrySymbol] =\n        options === null || options === void 0\n          ? void 0\n          : options.logErrorsBeforeRetry;\n      return jestObject;\n    };\n\n    const jestObject = {\n      advanceTimersByTime: msToRun =>\n        _getFakeTimers().advanceTimersByTime(msToRun),\n      advanceTimersToNextTimer: steps =>\n        _getFakeTimers().advanceTimersToNextTimer(steps),\n      autoMockOff: disableAutomock,\n      autoMockOn: enableAutomock,\n      clearAllMocks,\n      clearAllTimers: () => _getFakeTimers().clearAllTimers(),\n      createMockFromModule: moduleName => this._generateMock(from, moduleName),\n      deepUnmock,\n      disableAutomock,\n      doMock: mock,\n      dontMock: unmock,\n      enableAutomock,\n      fn,\n      genMockFromModule: moduleName => this._generateMock(from, moduleName),\n      getRealSystemTime: () => {\n        const fakeTimers = _getFakeTimers();\n\n        if (fakeTimers === this._environment.fakeTimersModern) {\n          return fakeTimers.getRealSystemTime();\n        } else {\n          throw new TypeError(\n            '`jest.getRealSystemTime()` is not available when using legacy fake timers.'\n          );\n        }\n      },\n      getTimerCount: () => _getFakeTimers().getTimerCount(),\n      isMockFunction: this._moduleMocker.isMockFunction,\n      isolateModules,\n      mock,\n      mocked,\n      requireActual: this.requireActual.bind(this, from),\n      requireMock: this.requireMock.bind(this, from),\n      resetAllMocks,\n      resetModules,\n      restoreAllMocks,\n      retryTimes,\n      runAllImmediates: () => {\n        const fakeTimers = _getFakeTimers();\n\n        if (fakeTimers === this._environment.fakeTimers) {\n          fakeTimers.runAllImmediates();\n        } else {\n          throw new TypeError(\n            '`jest.runAllImmediates()` is only available when using legacy fake timers.'\n          );\n        }\n      },\n      runAllTicks: () => _getFakeTimers().runAllTicks(),\n      runAllTimers: () => _getFakeTimers().runAllTimers(),\n      runOnlyPendingTimers: () => _getFakeTimers().runOnlyPendingTimers(),\n      setMock: (moduleName, mock) => setMockFactory(moduleName, () => mock),\n      setSystemTime: now => {\n        const fakeTimers = _getFakeTimers();\n\n        if (fakeTimers === this._environment.fakeTimersModern) {\n          fakeTimers.setSystemTime(now);\n        } else {\n          throw new TypeError(\n            '`jest.setSystemTime()` is not available when using legacy fake timers.'\n          );\n        }\n      },\n      setTimeout,\n      spyOn,\n      unmock,\n      unstable_mockModule: mockModule,\n      useFakeTimers,\n      useRealTimers\n    };\n    return jestObject;\n  }\n\n  _logFormattedReferenceError(errorMessage) {\n    const testPath = this._testPath\n      ? ` From ${(0, _slash().default)(\n          path().relative(this._config.rootDir, this._testPath)\n        )}.`\n      : '';\n    const originalStack = new ReferenceError(`${errorMessage}${testPath}`).stack\n      .split('\\n') // Remove this file from the stack (jest-message-utils will keep one line)\n      .filter(line => line.indexOf(__filename) === -1)\n      .join('\\n');\n    const {message, stack} = (0, _jestMessageUtil().separateMessageFromStack)(\n      originalStack\n    );\n    console.error(\n      `\\n${message}\\n${(0, _jestMessageUtil().formatStackTrace)(\n        stack,\n        this._config,\n        {\n          noStackTrace: false\n        }\n      )}`\n    );\n  }\n\n  wrapCodeInModuleWrapper(content) {\n    return `${this.constructModuleWrapperStart() + content}\\n}});`;\n  }\n\n  constructModuleWrapperStart() {\n    const args = this.constructInjectedModuleParameters();\n    return `({\"${EVAL_RESULT_VARIABLE}\":function(${args.join(',')}){`;\n  }\n\n  constructInjectedModuleParameters() {\n    return [\n      'module',\n      'exports',\n      'require',\n      '__dirname',\n      '__filename',\n      this._config.injectGlobals ? 'jest' : undefined,\n      ...this._config.sandboxInjectedGlobals\n    ].filter(notEmpty);\n  }\n\n  handleExecutionError(e, module) {\n    const moduleNotFoundError =\n      _jestResolve().default.tryCastModuleNotFoundError(e);\n\n    if (moduleNotFoundError) {\n      if (!moduleNotFoundError.requireStack) {\n        moduleNotFoundError.requireStack = [module.filename || module.id];\n\n        for (let cursor = module.parent; cursor; cursor = cursor.parent) {\n          moduleNotFoundError.requireStack.push(cursor.filename || cursor.id);\n        }\n\n        moduleNotFoundError.buildMessage(this._config.rootDir);\n      }\n\n      throw moduleNotFoundError;\n    }\n\n    throw e;\n  }\n\n  getGlobalsForCjs(from) {\n    const jest = this.jestObjectCaches.get(from);\n    invariant(jest, 'There should always be a Jest object already');\n    return {...this.getGlobalsFromEnvironment(), jest};\n  }\n\n  getGlobalsForEsm(from, context) {\n    let jest = this.jestObjectCaches.get(from);\n\n    if (!jest) {\n      jest = this._createJestObjectFor(from);\n      this.jestObjectCaches.set(from, jest);\n    }\n\n    const globals = {...this.getGlobalsFromEnvironment(), jest};\n    const module = new (_vm().SyntheticModule)(\n      Object.keys(globals),\n      function () {\n        Object.entries(globals).forEach(([key, value]) => {\n          // @ts-expect-error: TS doesn't know what `this` is\n          this.setExport(key, value);\n        });\n      },\n      {\n        context,\n        identifier: '@jest/globals'\n      }\n    );\n    return evaluateSyntheticModule(module);\n  }\n\n  getGlobalsFromEnvironment() {\n    if (this.jestGlobals) {\n      return {...this.jestGlobals};\n    }\n\n    return {\n      afterAll: this._environment.global.afterAll,\n      afterEach: this._environment.global.afterEach,\n      beforeAll: this._environment.global.beforeAll,\n      beforeEach: this._environment.global.beforeEach,\n      describe: this._environment.global.describe,\n      expect: this._environment.global.expect,\n      fdescribe: this._environment.global.fdescribe,\n      fit: this._environment.global.fit,\n      it: this._environment.global.it,\n      test: this._environment.global.test,\n      xdescribe: this._environment.global.xdescribe,\n      xit: this._environment.global.xit,\n      xtest: this._environment.global.xtest\n    };\n  }\n\n  readFile(filename) {\n    let source = this._cacheFS.get(filename);\n\n    if (!source) {\n      source = fs().readFileSync(filename, 'utf8');\n\n      this._cacheFS.set(filename, source);\n    }\n\n    return source;\n  }\n\n  setGlobalsForRuntime(globals) {\n    this.jestGlobals = globals;\n  }\n}\n\nexports.default = Runtime;\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nfunction notEmpty(value) {\n  return value !== null && value !== undefined;\n}\n\nasync function evaluateSyntheticModule(module) {\n  await module.link(() => {\n    throw new Error('This should never happen');\n  });\n  await module.evaluate();\n  return module;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}