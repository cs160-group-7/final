{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = wrapAnsiString;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// word-wrap a string that contains ANSI escape sequences.\n// ANSI escape sequences do not add to the string length.\n\nfunction wrapAnsiString(string, terminalWidth) {\n  if (terminalWidth === 0) {\n    // if the terminal width is zero, don't bother word-wrapping\n    return string;\n  }\n\n  const ANSI_REGEXP = /[\\u001b\\u009b]\\[\\d{1,2}m/gu;\n  const tokens = [];\n  let lastIndex = 0;\n  let match;\n\n  while (match = ANSI_REGEXP.exec(string)) {\n    const ansi = match[0];\n    const index = match['index'];\n\n    if (index != lastIndex) {\n      tokens.push(['string', string.slice(lastIndex, index)]);\n    }\n\n    tokens.push(['ansi', ansi]);\n    lastIndex = index + ansi.length;\n  }\n\n  if (lastIndex != string.length - 1) {\n    tokens.push(['string', string.slice(lastIndex, string.length)]);\n  }\n\n  let lastLineLength = 0;\n  return tokens.reduce((lines, _ref) => {\n    let [kind, token] = _ref;\n\n    if (kind === 'string') {\n      if (lastLineLength + token.length > terminalWidth) {\n        while (token.length) {\n          const chunk = token.slice(0, terminalWidth - lastLineLength);\n          const remaining = token.slice(terminalWidth - lastLineLength, token.length);\n          lines[lines.length - 1] += chunk;\n          lastLineLength += chunk.length;\n          token = remaining;\n\n          if (token.length) {\n            lines.push('');\n            lastLineLength = 0;\n          }\n        }\n      } else {\n        lines[lines.length - 1] += token;\n        lastLineLength += token.length;\n      }\n    } else {\n      lines[lines.length - 1] += token;\n    }\n\n    return lines;\n  }, ['']).join('\\n');\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","wrapAnsiString","string","terminalWidth","ANSI_REGEXP","tokens","lastIndex","match","exec","ansi","index","push","slice","length","lastLineLength","reduce","lines","kind","token","chunk","remaining","join"],"sources":["/Users/wonjaelee/Desktop/final/node_modules/@jest/reporters/build/wrapAnsiString.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = wrapAnsiString;\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// word-wrap a string that contains ANSI escape sequences.\n// ANSI escape sequences do not add to the string length.\nfunction wrapAnsiString(string, terminalWidth) {\n  if (terminalWidth === 0) {\n    // if the terminal width is zero, don't bother word-wrapping\n    return string;\n  }\n\n  const ANSI_REGEXP = /[\\u001b\\u009b]\\[\\d{1,2}m/gu;\n  const tokens = [];\n  let lastIndex = 0;\n  let match;\n\n  while ((match = ANSI_REGEXP.exec(string))) {\n    const ansi = match[0];\n    const index = match['index'];\n\n    if (index != lastIndex) {\n      tokens.push(['string', string.slice(lastIndex, index)]);\n    }\n\n    tokens.push(['ansi', ansi]);\n    lastIndex = index + ansi.length;\n  }\n\n  if (lastIndex != string.length - 1) {\n    tokens.push(['string', string.slice(lastIndex, string.length)]);\n  }\n\n  let lastLineLength = 0;\n  return tokens\n    .reduce(\n      (lines, [kind, token]) => {\n        if (kind === 'string') {\n          if (lastLineLength + token.length > terminalWidth) {\n            while (token.length) {\n              const chunk = token.slice(0, terminalWidth - lastLineLength);\n              const remaining = token.slice(\n                terminalWidth - lastLineLength,\n                token.length\n              );\n              lines[lines.length - 1] += chunk;\n              lastLineLength += chunk.length;\n              token = remaining;\n\n              if (token.length) {\n                lines.push('');\n                lastLineLength = 0;\n              }\n            }\n          } else {\n            lines[lines.length - 1] += token;\n            lastLineLength += token.length;\n          }\n        } else {\n          lines[lines.length - 1] += token;\n        }\n\n        return lines;\n      },\n      ['']\n    )\n    .join('\\n');\n}\n"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAC3CC,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkBC,cAAlB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,cAAT,CAAwBC,MAAxB,EAAgCC,aAAhC,EAA+C;EAC7C,IAAIA,aAAa,KAAK,CAAtB,EAAyB;IACvB;IACA,OAAOD,MAAP;EACD;;EAED,MAAME,WAAW,GAAG,4BAApB;EACA,MAAMC,MAAM,GAAG,EAAf;EACA,IAAIC,SAAS,GAAG,CAAhB;EACA,IAAIC,KAAJ;;EAEA,OAAQA,KAAK,GAAGH,WAAW,CAACI,IAAZ,CAAiBN,MAAjB,CAAhB,EAA2C;IACzC,MAAMO,IAAI,GAAGF,KAAK,CAAC,CAAD,CAAlB;IACA,MAAMG,KAAK,GAAGH,KAAK,CAAC,OAAD,CAAnB;;IAEA,IAAIG,KAAK,IAAIJ,SAAb,EAAwB;MACtBD,MAAM,CAACM,IAAP,CAAY,CAAC,QAAD,EAAWT,MAAM,CAACU,KAAP,CAAaN,SAAb,EAAwBI,KAAxB,CAAX,CAAZ;IACD;;IAEDL,MAAM,CAACM,IAAP,CAAY,CAAC,MAAD,EAASF,IAAT,CAAZ;IACAH,SAAS,GAAGI,KAAK,GAAGD,IAAI,CAACI,MAAzB;EACD;;EAED,IAAIP,SAAS,IAAIJ,MAAM,CAACW,MAAP,GAAgB,CAAjC,EAAoC;IAClCR,MAAM,CAACM,IAAP,CAAY,CAAC,QAAD,EAAWT,MAAM,CAACU,KAAP,CAAaN,SAAb,EAAwBJ,MAAM,CAACW,MAA/B,CAAX,CAAZ;EACD;;EAED,IAAIC,cAAc,GAAG,CAArB;EACA,OAAOT,MAAM,CACVU,MADI,CAEH,CAACC,KAAD,WAA0B;IAAA,IAAlB,CAACC,IAAD,EAAOC,KAAP,CAAkB;;IACxB,IAAID,IAAI,KAAK,QAAb,EAAuB;MACrB,IAAIH,cAAc,GAAGI,KAAK,CAACL,MAAvB,GAAgCV,aAApC,EAAmD;QACjD,OAAOe,KAAK,CAACL,MAAb,EAAqB;UACnB,MAAMM,KAAK,GAAGD,KAAK,CAACN,KAAN,CAAY,CAAZ,EAAeT,aAAa,GAAGW,cAA/B,CAAd;UACA,MAAMM,SAAS,GAAGF,KAAK,CAACN,KAAN,CAChBT,aAAa,GAAGW,cADA,EAEhBI,KAAK,CAACL,MAFU,CAAlB;UAIAG,KAAK,CAACA,KAAK,CAACH,MAAN,GAAe,CAAhB,CAAL,IAA2BM,KAA3B;UACAL,cAAc,IAAIK,KAAK,CAACN,MAAxB;UACAK,KAAK,GAAGE,SAAR;;UAEA,IAAIF,KAAK,CAACL,MAAV,EAAkB;YAChBG,KAAK,CAACL,IAAN,CAAW,EAAX;YACAG,cAAc,GAAG,CAAjB;UACD;QACF;MACF,CAhBD,MAgBO;QACLE,KAAK,CAACA,KAAK,CAACH,MAAN,GAAe,CAAhB,CAAL,IAA2BK,KAA3B;QACAJ,cAAc,IAAII,KAAK,CAACL,MAAxB;MACD;IACF,CArBD,MAqBO;MACLG,KAAK,CAACA,KAAK,CAACH,MAAN,GAAe,CAAhB,CAAL,IAA2BK,KAA3B;IACD;;IAED,OAAOF,KAAP;EACD,CA7BE,EA8BH,CAAC,EAAD,CA9BG,EAgCJK,IAhCI,CAgCC,IAhCD,CAAP;AAiCD"},"metadata":{},"sourceType":"script"}