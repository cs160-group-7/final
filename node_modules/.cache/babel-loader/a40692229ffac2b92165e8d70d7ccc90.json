{"ast":null,"code":"/**\n * ...something resembling a binary search, to find the lowest line within the range.\n * And then you could break as soon as the line is longer than the range...\n */\nmodule.exports.sliceRange = function (lines, startCol, endCol) {\n  let inclusive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let start = 0;\n  let end = lines.length;\n\n  if (inclusive) {\n    // I consider this a temporary solution until I find an alternaive way to fix the \"off by one issue\"\n    --startCol;\n  }\n\n  while (start < end) {\n    let mid = start + end >> 1;\n\n    if (startCol >= lines[mid].endCol) {\n      start = mid + 1;\n    } else if (endCol < lines[mid].startCol) {\n      end = mid - 1;\n    } else {\n      end = mid;\n\n      while (mid >= 0 && startCol < lines[mid].endCol && endCol >= lines[mid].startCol) {\n        --mid;\n      }\n\n      start = mid + 1;\n      break;\n    }\n  }\n\n  while (end < lines.length && startCol < lines[end].endCol && endCol >= lines[end].startCol) {\n    ++end;\n  }\n\n  return lines.slice(start, end);\n};","map":{"version":3,"names":["module","exports","sliceRange","lines","startCol","endCol","inclusive","start","end","length","mid","slice"],"sources":["/Users/wonjaelee/Desktop/final/node_modules/v8-to-istanbul/lib/range.js"],"sourcesContent":["/**\n * ...something resembling a binary search, to find the lowest line within the range.\n * And then you could break as soon as the line is longer than the range...\n */\nmodule.exports.sliceRange = (lines, startCol, endCol, inclusive = false) => {\n  let start = 0\n  let end = lines.length\n\n  if (inclusive) {\n    // I consider this a temporary solution until I find an alternaive way to fix the \"off by one issue\"\n    --startCol\n  }\n\n  while (start < end) {\n    let mid = (start + end) >> 1\n    if (startCol >= lines[mid].endCol) {\n      start = mid + 1\n    } else if (endCol < lines[mid].startCol) {\n      end = mid - 1\n    } else {\n      end = mid\n      while (mid >= 0 && startCol < lines[mid].endCol && endCol >= lines[mid].startCol) {\n        --mid\n      }\n      start = mid + 1\n      break\n    }\n  }\n\n  while (end < lines.length && startCol < lines[end].endCol && endCol >= lines[end].startCol) {\n    ++end\n  }\n\n  return lines.slice(start, end)\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACAA,MAAM,CAACC,OAAP,CAAeC,UAAf,GAA4B,UAACC,KAAD,EAAQC,QAAR,EAAkBC,MAAlB,EAAgD;EAAA,IAAtBC,SAAsB,uEAAV,KAAU;EAC1E,IAAIC,KAAK,GAAG,CAAZ;EACA,IAAIC,GAAG,GAAGL,KAAK,CAACM,MAAhB;;EAEA,IAAIH,SAAJ,EAAe;IACb;IACA,EAAEF,QAAF;EACD;;EAED,OAAOG,KAAK,GAAGC,GAAf,EAAoB;IAClB,IAAIE,GAAG,GAAIH,KAAK,GAAGC,GAAT,IAAiB,CAA3B;;IACA,IAAIJ,QAAQ,IAAID,KAAK,CAACO,GAAD,CAAL,CAAWL,MAA3B,EAAmC;MACjCE,KAAK,GAAGG,GAAG,GAAG,CAAd;IACD,CAFD,MAEO,IAAIL,MAAM,GAAGF,KAAK,CAACO,GAAD,CAAL,CAAWN,QAAxB,EAAkC;MACvCI,GAAG,GAAGE,GAAG,GAAG,CAAZ;IACD,CAFM,MAEA;MACLF,GAAG,GAAGE,GAAN;;MACA,OAAOA,GAAG,IAAI,CAAP,IAAYN,QAAQ,GAAGD,KAAK,CAACO,GAAD,CAAL,CAAWL,MAAlC,IAA4CA,MAAM,IAAIF,KAAK,CAACO,GAAD,CAAL,CAAWN,QAAxE,EAAkF;QAChF,EAAEM,GAAF;MACD;;MACDH,KAAK,GAAGG,GAAG,GAAG,CAAd;MACA;IACD;EACF;;EAED,OAAOF,GAAG,GAAGL,KAAK,CAACM,MAAZ,IAAsBL,QAAQ,GAAGD,KAAK,CAACK,GAAD,CAAL,CAAWH,MAA5C,IAAsDA,MAAM,IAAIF,KAAK,CAACK,GAAD,CAAL,CAAWJ,QAAlF,EAA4F;IAC1F,EAAEI,GAAF;EACD;;EAED,OAAOL,KAAK,CAACQ,KAAN,CAAYJ,KAAZ,EAAmBC,GAAnB,CAAP;AACD,CA9BD"},"metadata":{},"sourceType":"script"}