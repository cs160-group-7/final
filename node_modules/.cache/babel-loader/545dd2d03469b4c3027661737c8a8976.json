{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _slash() {\n  const data = _interopRequireDefault(require('slash'));\n\n  _slash = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _ModuleNotFoundError = _interopRequireDefault(require('./ModuleNotFoundError'));\n\nvar _defaultResolver = _interopRequireDefault(require('./defaultResolver'));\n\nvar _fileWalkers = require('./fileWalkers');\n\nvar _isBuiltinModule = _interopRequireDefault(require('./isBuiltinModule'));\n\nvar _nodeModulesPaths = _interopRequireDefault(require('./nodeModulesPaths'));\n\nvar _shouldLoadAsEsm = _interopRequireWildcard(require('./shouldLoadAsEsm'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable local/prefer-spread-eventually */\n\n\nconst NATIVE_PLATFORM = 'native'; // We might be inside a symlink.\n\nconst resolvedCwd = (0, _jestUtil().tryRealpath)(process.cwd());\nconst {\n  NODE_PATH\n} = process.env;\nconst nodePaths = NODE_PATH ? NODE_PATH.split(path().delimiter).filter(Boolean) // The resolver expects absolute paths.\n.map(p => path().resolve(resolvedCwd, p)) : undefined;\n\nclass Resolver {\n  _options;\n  _moduleMap;\n  _moduleIDCache;\n  _moduleNameCache;\n  _modulePathCache;\n  _supportsNativePlatform;\n\n  constructor(moduleMap, options) {\n    this._options = {\n      defaultPlatform: options.defaultPlatform,\n      extensions: options.extensions,\n      hasCoreModules: options.hasCoreModules === undefined ? true : options.hasCoreModules,\n      moduleDirectories: options.moduleDirectories || ['node_modules'],\n      moduleNameMapper: options.moduleNameMapper,\n      modulePaths: options.modulePaths,\n      platforms: options.platforms,\n      resolver: options.resolver,\n      rootDir: options.rootDir\n    };\n    this._supportsNativePlatform = options.platforms ? options.platforms.includes(NATIVE_PLATFORM) : false;\n    this._moduleMap = moduleMap;\n    this._moduleIDCache = new Map();\n    this._moduleNameCache = new Map();\n    this._modulePathCache = new Map();\n  }\n\n  static ModuleNotFoundError = _ModuleNotFoundError.default;\n\n  static tryCastModuleNotFoundError(error) {\n    if (error instanceof _ModuleNotFoundError.default) {\n      return error;\n    }\n\n    const casted = error;\n\n    if (casted.code === 'MODULE_NOT_FOUND') {\n      return _ModuleNotFoundError.default.duckType(casted);\n    }\n\n    return null;\n  }\n\n  static clearDefaultResolverCache() {\n    (0, _fileWalkers.clearFsCache)();\n    (0, _shouldLoadAsEsm.clearCachedLookups)();\n  }\n\n  static findNodeModule(path, options) {\n    const resolverModule = loadResolver(options.resolver);\n    let resolver = _defaultResolver.default;\n\n    if (typeof resolverModule === 'function') {\n      resolver = resolverModule;\n    } else if (typeof resolverModule.sync === 'function') {\n      resolver = resolverModule.sync;\n    }\n\n    const paths = options.paths;\n\n    try {\n      return resolver(path, {\n        basedir: options.basedir,\n        conditions: options.conditions,\n        defaultResolver: _defaultResolver.default,\n        extensions: options.extensions,\n        moduleDirectory: options.moduleDirectory,\n        paths: paths ? (nodePaths || []).concat(paths) : nodePaths,\n        rootDir: options.rootDir\n      });\n    } catch (e) {\n      if (options.throwIfNotFound) {\n        throw e;\n      }\n    }\n\n    return null;\n  }\n\n  static async findNodeModuleAsync(path, options) {\n    const resolverModule = loadResolver(options.resolver);\n    let resolver = _defaultResolver.default;\n\n    if (typeof resolverModule === 'function') {\n      resolver = resolverModule;\n    } else if (typeof resolverModule.async === 'function' || typeof resolverModule.sync === 'function') {\n      const asyncOrSync = resolverModule.async || resolverModule.sync;\n\n      if (asyncOrSync == null) {\n        throw new Error(`Unable to load resolver at ${options.resolver}`);\n      }\n\n      resolver = asyncOrSync;\n    }\n\n    const paths = options.paths;\n\n    try {\n      const result = await resolver(path, {\n        basedir: options.basedir,\n        conditions: options.conditions,\n        defaultResolver: _defaultResolver.default,\n        extensions: options.extensions,\n        moduleDirectory: options.moduleDirectory,\n        paths: paths ? (nodePaths || []).concat(paths) : nodePaths,\n        rootDir: options.rootDir\n      });\n      return result;\n    } catch (e) {\n      if (options.throwIfNotFound) {\n        throw e;\n      }\n    }\n\n    return null;\n  } // unstable as it should be replaced by https://github.com/nodejs/modules/issues/393, and we don't want people to use it\n\n\n  static unstable_shouldLoadAsEsm = _shouldLoadAsEsm.default;\n\n  resolveModuleFromDirIfExists(dirname, moduleName, options) {\n    var _this = this;\n\n    const {\n      extensions,\n      key,\n      moduleDirectory,\n      paths,\n      skipResolution\n    } = this._prepareForResolution(dirname, moduleName, options);\n\n    let module; // 1. If we have already resolved this module for this directory name,\n    // return a value from the cache.\n\n    const cacheResult = this._moduleNameCache.get(key);\n\n    if (cacheResult) {\n      return cacheResult;\n    } // 2. Check if the module is a haste module.\n\n\n    module = this.getModule(moduleName);\n\n    if (module) {\n      this._moduleNameCache.set(key, module);\n\n      return module;\n    } // 3. Check if the module is a node module and resolve it based on\n    // the node module resolution algorithm. If skipNodeResolution is given we\n    // ignore all modules that look like node modules (ie. are not relative\n    // requires). This enables us to speed up resolution when we build a\n    // dependency graph because we don't have to look at modules that may not\n    // exist and aren't mocked.\n\n\n    const resolveNodeModule = function (name) {\n      let throwIfNotFound = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      // Only skip default resolver\n      if (_this.isCoreModule(name) && !_this._options.resolver) {\n        return name;\n      }\n\n      return Resolver.findNodeModule(name, {\n        basedir: dirname,\n        conditions: options === null || options === void 0 ? void 0 : options.conditions,\n        extensions,\n        moduleDirectory,\n        paths,\n        resolver: _this._options.resolver,\n        rootDir: _this._options.rootDir,\n        throwIfNotFound\n      });\n    };\n\n    if (!skipResolution) {\n      module = resolveNodeModule(moduleName, Boolean(process.versions.pnp));\n\n      if (module) {\n        this._moduleNameCache.set(key, module);\n\n        return module;\n      }\n    } // 4. Resolve \"haste packages\" which are `package.json` files outside of\n    // `node_modules` folders anywhere in the file system.\n\n\n    try {\n      const hasteModulePath = this._getHasteModulePath(moduleName);\n\n      if (hasteModulePath) {\n        // try resolving with custom resolver first to support extensions,\n        // then fallback to require.resolve\n        const resolvedModule = resolveNodeModule(hasteModulePath) || require.resolve(hasteModulePath);\n\n        this._moduleNameCache.set(key, resolvedModule);\n\n        return resolvedModule;\n      }\n    } catch {}\n\n    return null;\n  }\n\n  async resolveModuleFromDirIfExistsAsync(dirname, moduleName, options) {\n    var _this2 = this;\n\n    const {\n      extensions,\n      key,\n      moduleDirectory,\n      paths,\n      skipResolution\n    } = this._prepareForResolution(dirname, moduleName, options);\n\n    let module; // 1. If we have already resolved this module for this directory name,\n    // return a value from the cache.\n\n    const cacheResult = this._moduleNameCache.get(key);\n\n    if (cacheResult) {\n      return cacheResult;\n    } // 2. Check if the module is a haste module.\n\n\n    module = this.getModule(moduleName);\n\n    if (module) {\n      this._moduleNameCache.set(key, module);\n\n      return module;\n    } // 3. Check if the module is a node module and resolve it based on\n    // the node module resolution algorithm. If skipNodeResolution is given we\n    // ignore all modules that look like node modules (ie. are not relative\n    // requires). This enables us to speed up resolution when we build a\n    // dependency graph because we don't have to look at modules that may not\n    // exist and aren't mocked.\n\n\n    const resolveNodeModule = async function (name) {\n      let throwIfNotFound = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      // Only skip default resolver\n      if (_this2.isCoreModule(name) && !_this2._options.resolver) {\n        return name;\n      }\n\n      return await Resolver.findNodeModuleAsync(name, {\n        basedir: dirname,\n        conditions: options === null || options === void 0 ? void 0 : options.conditions,\n        extensions,\n        moduleDirectory,\n        paths,\n        resolver: _this2._options.resolver,\n        rootDir: _this2._options.rootDir,\n        throwIfNotFound\n      });\n    };\n\n    if (!skipResolution) {\n      module = await resolveNodeModule(moduleName, Boolean(process.versions.pnp));\n\n      if (module) {\n        this._moduleNameCache.set(key, module);\n\n        return module;\n      }\n    } // 4. Resolve \"haste packages\" which are `package.json` files outside of\n    // `node_modules` folders anywhere in the file system.\n\n\n    try {\n      const hasteModulePath = this._getHasteModulePath(moduleName);\n\n      if (hasteModulePath) {\n        // try resolving with custom resolver first to support extensions,\n        // then fallback to require.resolve\n        const resolvedModule = (await resolveNodeModule(hasteModulePath)) || // QUESTION: should this be async?\n        require.resolve(hasteModulePath);\n\n        this._moduleNameCache.set(key, resolvedModule);\n\n        return resolvedModule;\n      }\n    } catch {}\n\n    return null;\n  }\n\n  resolveModule(from, moduleName, options) {\n    const dirname = path().dirname(from);\n    const module = this.resolveStubModuleName(from, moduleName) || this.resolveModuleFromDirIfExists(dirname, moduleName, options);\n    if (module) return module; // 5. Throw an error if the module could not be found. `resolve.sync` only\n    // produces an error based on the dirname but we have the actual current\n    // module name available.\n\n    this._throwModNotFoundError(from, moduleName);\n  }\n\n  async resolveModuleAsync(from, moduleName, options) {\n    const dirname = path().dirname(from);\n    const module = (await this.resolveStubModuleNameAsync(from, moduleName)) || (await this.resolveModuleFromDirIfExistsAsync(dirname, moduleName, options));\n    if (module) return module; // 5. Throw an error if the module could not be found. `resolve` only\n    // produces an error based on the dirname but we have the actual current\n    // module name available.\n\n    this._throwModNotFoundError(from, moduleName);\n  }\n  /**\n   * _prepareForResolution is shared between the sync and async module resolution\n   * methods, to try to keep them as DRY as possible.\n   */\n\n\n  _prepareForResolution(dirname, moduleName, options) {\n    const paths = (options === null || options === void 0 ? void 0 : options.paths) || this._options.modulePaths;\n    const moduleDirectory = this._options.moduleDirectories;\n    const stringifiedOptions = options ? JSON.stringify(options) : '';\n    const key = dirname + path().delimiter + moduleName + stringifiedOptions;\n    const defaultPlatform = this._options.defaultPlatform;\n\n    const extensions = this._options.extensions.slice();\n\n    if (this._supportsNativePlatform) {\n      extensions.unshift(...this._options.extensions.map(ext => `.${NATIVE_PLATFORM}${ext}`));\n    }\n\n    if (defaultPlatform) {\n      extensions.unshift(...this._options.extensions.map(ext => `.${defaultPlatform}${ext}`));\n    }\n\n    const skipResolution = options && options.skipNodeResolution && !moduleName.includes(path().sep);\n    return {\n      extensions,\n      key,\n      moduleDirectory,\n      paths,\n      skipResolution\n    };\n  }\n  /**\n   * _getHasteModulePath attempts to return the path to a haste module.\n   */\n\n\n  _getHasteModulePath(moduleName) {\n    const parts = moduleName.split('/');\n    const hastePackage = this.getPackage(parts.shift());\n\n    if (hastePackage) {\n      return path().join.apply(path(), [path().dirname(hastePackage)].concat(parts));\n    }\n\n    return null;\n  }\n\n  _throwModNotFoundError(from, moduleName) {\n    const relativePath = (0, _slash().default)(path().relative(this._options.rootDir, from)) || '.';\n    throw new _ModuleNotFoundError.default(`Cannot find module '${moduleName}' from '${relativePath}'`, moduleName);\n  }\n\n  _getMapModuleName(matches) {\n    return matches ? moduleName => moduleName.replace(/\\$([0-9]+)/g, (_, index) => matches[parseInt(index, 10)]) : moduleName => moduleName;\n  }\n\n  _isAliasModule(moduleName) {\n    const moduleNameMapper = this._options.moduleNameMapper;\n\n    if (!moduleNameMapper) {\n      return false;\n    }\n\n    return moduleNameMapper.some(_ref => {\n      let {\n        regex\n      } = _ref;\n      return regex.test(moduleName);\n    });\n  }\n\n  isCoreModule(moduleName) {\n    return this._options.hasCoreModules && ((0, _isBuiltinModule.default)(moduleName) || moduleName.startsWith('node:') && (0, _isBuiltinModule.default)(moduleName.slice('node:'.length))) && !this._isAliasModule(moduleName);\n  }\n\n  getModule(name) {\n    return this._moduleMap.getModule(name, this._options.defaultPlatform, this._supportsNativePlatform);\n  }\n\n  getModulePath(from, moduleName) {\n    if (moduleName[0] !== '.' || path().isAbsolute(moduleName)) {\n      return moduleName;\n    }\n\n    return path().normalize(`${path().dirname(from)}/${moduleName}`);\n  }\n\n  getPackage(name) {\n    return this._moduleMap.getPackage(name, this._options.defaultPlatform, this._supportsNativePlatform);\n  }\n\n  getMockModule(from, name) {\n    const mock = this._moduleMap.getMockModule(name);\n\n    if (mock) {\n      return mock;\n    } else {\n      const moduleName = this.resolveStubModuleName(from, name);\n\n      if (moduleName) {\n        return this.getModule(moduleName) || moduleName;\n      }\n    }\n\n    return null;\n  }\n\n  async getMockModuleAsync(from, name) {\n    const mock = this._moduleMap.getMockModule(name);\n\n    if (mock) {\n      return mock;\n    } else {\n      const moduleName = await this.resolveStubModuleNameAsync(from, name);\n\n      if (moduleName) {\n        return this.getModule(moduleName) || moduleName;\n      }\n    }\n\n    return null;\n  }\n\n  getModulePaths(from) {\n    const cachedModule = this._modulePathCache.get(from);\n\n    if (cachedModule) {\n      return cachedModule;\n    }\n\n    const moduleDirectory = this._options.moduleDirectories;\n    const paths = (0, _nodeModulesPaths.default)(from, {\n      moduleDirectory\n    });\n\n    if (paths[paths.length - 1] === undefined) {\n      // circumvent node-resolve bug that adds `undefined` as last item.\n      paths.pop();\n    }\n\n    this._modulePathCache.set(from, paths);\n\n    return paths;\n  }\n\n  getModuleID(virtualMocks, from) {\n    let moduleName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    let options = arguments.length > 3 ? arguments[3] : undefined;\n    const stringifiedOptions = options ? JSON.stringify(options) : '';\n    const key = from + path().delimiter + moduleName + stringifiedOptions;\n\n    const cachedModuleID = this._moduleIDCache.get(key);\n\n    if (cachedModuleID) {\n      return cachedModuleID;\n    }\n\n    const moduleType = this._getModuleType(moduleName);\n\n    const absolutePath = this._getAbsolutePath(virtualMocks, from, moduleName, options);\n\n    const mockPath = this._getMockPath(from, moduleName);\n\n    const sep = path().delimiter;\n    const id = moduleType + sep + (absolutePath ? absolutePath + sep : '') + (mockPath ? mockPath + sep : '') + (stringifiedOptions ? stringifiedOptions + sep : '');\n\n    this._moduleIDCache.set(key, id);\n\n    return id;\n  }\n\n  async getModuleIDAsync(virtualMocks, from) {\n    let moduleName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    let options = arguments.length > 3 ? arguments[3] : undefined;\n    const stringifiedOptions = options ? JSON.stringify(options) : '';\n    const key = from + path().delimiter + moduleName + stringifiedOptions;\n\n    const cachedModuleID = this._moduleIDCache.get(key);\n\n    if (cachedModuleID) {\n      return cachedModuleID;\n    }\n\n    if (moduleName.startsWith('data:')) {\n      return moduleName;\n    }\n\n    const moduleType = this._getModuleType(moduleName);\n\n    const absolutePath = await this._getAbsolutePathAsync(virtualMocks, from, moduleName, options);\n    const mockPath = await this._getMockPathAsync(from, moduleName);\n    const sep = path().delimiter;\n    const id = moduleType + sep + (absolutePath ? absolutePath + sep : '') + (mockPath ? mockPath + sep : '') + (stringifiedOptions ? stringifiedOptions + sep : '');\n\n    this._moduleIDCache.set(key, id);\n\n    return id;\n  }\n\n  _getModuleType(moduleName) {\n    return this.isCoreModule(moduleName) ? 'node' : 'user';\n  }\n\n  _getAbsolutePath(virtualMocks, from, moduleName, options) {\n    if (this.isCoreModule(moduleName)) {\n      return moduleName;\n    }\n\n    if (moduleName.startsWith('data:')) {\n      return moduleName;\n    }\n\n    return this._isModuleResolved(from, moduleName) ? this.getModule(moduleName) : this._getVirtualMockPath(virtualMocks, from, moduleName, options);\n  }\n\n  async _getAbsolutePathAsync(virtualMocks, from, moduleName, options) {\n    if (this.isCoreModule(moduleName)) {\n      return moduleName;\n    }\n\n    if (moduleName.startsWith('data:')) {\n      return moduleName;\n    }\n\n    const isModuleResolved = await this._isModuleResolvedAsync(from, moduleName);\n    return isModuleResolved ? this.getModule(moduleName) : await this._getVirtualMockPathAsync(virtualMocks, from, moduleName, options);\n  }\n\n  _getMockPath(from, moduleName) {\n    return !this.isCoreModule(moduleName) ? this.getMockModule(from, moduleName) : null;\n  }\n\n  async _getMockPathAsync(from, moduleName) {\n    return !this.isCoreModule(moduleName) ? await this.getMockModuleAsync(from, moduleName) : null;\n  }\n\n  _getVirtualMockPath(virtualMocks, from, moduleName, options) {\n    const virtualMockPath = this.getModulePath(from, moduleName);\n    return virtualMocks.get(virtualMockPath) ? virtualMockPath : moduleName ? this.resolveModule(from, moduleName, options) : from;\n  }\n\n  async _getVirtualMockPathAsync(virtualMocks, from, moduleName, options) {\n    const virtualMockPath = this.getModulePath(from, moduleName);\n    return virtualMocks.get(virtualMockPath) ? virtualMockPath : moduleName ? await this.resolveModuleAsync(from, moduleName, options) : from;\n  }\n\n  _isModuleResolved(from, moduleName) {\n    return !!(this.getModule(moduleName) || this.getMockModule(from, moduleName));\n  }\n\n  async _isModuleResolvedAsync(from, moduleName) {\n    return !!(this.getModule(moduleName) || (await this.getMockModuleAsync(from, moduleName)));\n  }\n\n  resolveStubModuleName(from, moduleName) {\n    const dirname = path().dirname(from);\n\n    const {\n      extensions,\n      moduleDirectory,\n      paths\n    } = this._prepareForResolution(dirname, moduleName);\n\n    const moduleNameMapper = this._options.moduleNameMapper;\n    const resolver = this._options.resolver;\n\n    if (moduleNameMapper) {\n      for (const {\n        moduleName: mappedModuleName,\n        regex\n      } of moduleNameMapper) {\n        if (regex.test(moduleName)) {\n          // Note: once a moduleNameMapper matches the name, it must result\n          // in a module, or else an error is thrown.\n          const matches = moduleName.match(regex);\n\n          const mapModuleName = this._getMapModuleName(matches);\n\n          const possibleModuleNames = Array.isArray(mappedModuleName) ? mappedModuleName : [mappedModuleName];\n          let module = null;\n\n          for (const possibleModuleName of possibleModuleNames) {\n            const updatedName = mapModuleName(possibleModuleName);\n            module = this.getModule(updatedName) || Resolver.findNodeModule(updatedName, {\n              basedir: dirname,\n              extensions,\n              moduleDirectory,\n              paths,\n              resolver,\n              rootDir: this._options.rootDir\n            });\n\n            if (module) {\n              break;\n            }\n          }\n\n          if (!module) {\n            throw createNoMappedModuleFoundError(moduleName, mapModuleName, mappedModuleName, regex, resolver);\n          }\n\n          return module;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  async resolveStubModuleNameAsync(from, moduleName) {\n    const dirname = path().dirname(from);\n\n    const {\n      extensions,\n      moduleDirectory,\n      paths\n    } = this._prepareForResolution(dirname, moduleName);\n\n    const moduleNameMapper = this._options.moduleNameMapper;\n    const resolver = this._options.resolver;\n\n    if (moduleNameMapper) {\n      for (const {\n        moduleName: mappedModuleName,\n        regex\n      } of moduleNameMapper) {\n        if (regex.test(moduleName)) {\n          // Note: once a moduleNameMapper matches the name, it must result\n          // in a module, or else an error is thrown.\n          const matches = moduleName.match(regex);\n\n          const mapModuleName = this._getMapModuleName(matches);\n\n          const possibleModuleNames = Array.isArray(mappedModuleName) ? mappedModuleName : [mappedModuleName];\n          let module = null;\n\n          for (const possibleModuleName of possibleModuleNames) {\n            const updatedName = mapModuleName(possibleModuleName);\n            module = this.getModule(updatedName) || (await Resolver.findNodeModuleAsync(updatedName, {\n              basedir: dirname,\n              extensions,\n              moduleDirectory,\n              paths,\n              resolver,\n              rootDir: this._options.rootDir\n            }));\n\n            if (module) {\n              break;\n            }\n          }\n\n          if (!module) {\n            throw createNoMappedModuleFoundError(moduleName, mapModuleName, mappedModuleName, regex, resolver);\n          }\n\n          return module;\n        }\n      }\n    }\n\n    return null;\n  }\n\n}\n\nexports.default = Resolver;\n\nconst createNoMappedModuleFoundError = (moduleName, mapModuleName, mappedModuleName, regex, resolver) => {\n  const mappedAs = Array.isArray(mappedModuleName) ? JSON.stringify(mappedModuleName.map(mapModuleName), null, 2) : mappedModuleName;\n  const original = Array.isArray(mappedModuleName) ? `${JSON.stringify(mappedModuleName, null, 6) // using 6 because of misalignment when nested below\n  .slice(0, -1) + ' '.repeat(4)}]` /// align last bracket correctly as well\n  : mappedModuleName;\n  const error = new Error(_chalk().default.red(`${_chalk().default.bold('Configuration error')}:\n\nCould not locate module ${_chalk().default.bold(moduleName)} mapped as:\n${_chalk().default.bold(mappedAs)}.\n\nPlease check your configuration for these entries:\n{\n  \"moduleNameMapper\": {\n    \"${regex.toString()}\": \"${_chalk().default.bold(original)}\"\n  },\n  \"resolver\": ${_chalk().default.bold(String(resolver))}\n}`));\n  error.name = '';\n  return error;\n};\n\nfunction loadResolver(resolver) {\n  if (resolver == null) {\n    return _defaultResolver.default;\n  }\n\n  const loadedResolver = require(resolver);\n\n  if (loadedResolver == null) {\n    throw new Error(`Resolver located at ${resolver} does not export anything`);\n  }\n\n  if (typeof loadedResolver === 'function') {\n    return loadedResolver;\n  }\n\n  if (typeof loadedResolver === 'object' && (loadedResolver.sync != null || loadedResolver.async != null)) {\n    return loadedResolver;\n  }\n\n  throw new Error(`Resolver located at ${resolver} does not export a function or an object with \"sync\" and \"async\" props`);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","path","data","_interopRequireWildcard","require","_chalk","_interopRequireDefault","_slash","_jestUtil","_ModuleNotFoundError","_defaultResolver","_fileWalkers","_isBuiltinModule","_nodeModulesPaths","_shouldLoadAsEsm","obj","__esModule","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","NATIVE_PLATFORM","resolvedCwd","tryRealpath","process","cwd","NODE_PATH","env","nodePaths","split","delimiter","filter","Boolean","map","p","resolve","undefined","Resolver","_options","_moduleMap","_moduleIDCache","_moduleNameCache","_modulePathCache","_supportsNativePlatform","constructor","moduleMap","options","defaultPlatform","extensions","hasCoreModules","moduleDirectories","moduleNameMapper","modulePaths","platforms","resolver","rootDir","includes","Map","ModuleNotFoundError","tryCastModuleNotFoundError","error","casted","code","duckType","clearDefaultResolverCache","clearFsCache","clearCachedLookups","findNodeModule","resolverModule","loadResolver","sync","paths","basedir","conditions","defaultResolver","moduleDirectory","concat","e","throwIfNotFound","findNodeModuleAsync","async","asyncOrSync","Error","result","unstable_shouldLoadAsEsm","resolveModuleFromDirIfExists","dirname","moduleName","skipResolution","_prepareForResolution","module","cacheResult","getModule","resolveNodeModule","name","isCoreModule","versions","pnp","hasteModulePath","_getHasteModulePath","resolvedModule","resolveModuleFromDirIfExistsAsync","resolveModule","from","resolveStubModuleName","_throwModNotFoundError","resolveModuleAsync","resolveStubModuleNameAsync","stringifiedOptions","JSON","stringify","slice","unshift","ext","skipNodeResolution","sep","parts","hastePackage","getPackage","shift","join","apply","relativePath","relative","_getMapModuleName","matches","replace","_","index","parseInt","_isAliasModule","some","regex","test","startsWith","length","getModulePath","isAbsolute","normalize","getMockModule","mock","getMockModuleAsync","getModulePaths","cachedModule","pop","getModuleID","virtualMocks","cachedModuleID","moduleType","_getModuleType","absolutePath","_getAbsolutePath","mockPath","_getMockPath","id","getModuleIDAsync","_getAbsolutePathAsync","_getMockPathAsync","_isModuleResolved","_getVirtualMockPath","isModuleResolved","_isModuleResolvedAsync","_getVirtualMockPathAsync","virtualMockPath","mappedModuleName","match","mapModuleName","possibleModuleNames","Array","isArray","possibleModuleName","updatedName","createNoMappedModuleFoundError","mappedAs","original","repeat","red","bold","toString","String","loadedResolver"],"sources":["/Users/wonjaelee/Desktop/final/node_modules/jest-runtime/node_modules/jest-resolve/build/resolver.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _slash() {\n  const data = _interopRequireDefault(require('slash'));\n\n  _slash = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _ModuleNotFoundError = _interopRequireDefault(\n  require('./ModuleNotFoundError')\n);\n\nvar _defaultResolver = _interopRequireDefault(require('./defaultResolver'));\n\nvar _fileWalkers = require('./fileWalkers');\n\nvar _isBuiltinModule = _interopRequireDefault(require('./isBuiltinModule'));\n\nvar _nodeModulesPaths = _interopRequireDefault(require('./nodeModulesPaths'));\n\nvar _shouldLoadAsEsm = _interopRequireWildcard(require('./shouldLoadAsEsm'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable local/prefer-spread-eventually */\nconst NATIVE_PLATFORM = 'native'; // We might be inside a symlink.\n\nconst resolvedCwd = (0, _jestUtil().tryRealpath)(process.cwd());\nconst {NODE_PATH} = process.env;\nconst nodePaths = NODE_PATH\n  ? NODE_PATH.split(path().delimiter)\n      .filter(Boolean) // The resolver expects absolute paths.\n      .map(p => path().resolve(resolvedCwd, p))\n  : undefined;\n\nclass Resolver {\n  _options;\n  _moduleMap;\n  _moduleIDCache;\n  _moduleNameCache;\n  _modulePathCache;\n  _supportsNativePlatform;\n\n  constructor(moduleMap, options) {\n    this._options = {\n      defaultPlatform: options.defaultPlatform,\n      extensions: options.extensions,\n      hasCoreModules:\n        options.hasCoreModules === undefined ? true : options.hasCoreModules,\n      moduleDirectories: options.moduleDirectories || ['node_modules'],\n      moduleNameMapper: options.moduleNameMapper,\n      modulePaths: options.modulePaths,\n      platforms: options.platforms,\n      resolver: options.resolver,\n      rootDir: options.rootDir\n    };\n    this._supportsNativePlatform = options.platforms\n      ? options.platforms.includes(NATIVE_PLATFORM)\n      : false;\n    this._moduleMap = moduleMap;\n    this._moduleIDCache = new Map();\n    this._moduleNameCache = new Map();\n    this._modulePathCache = new Map();\n  }\n\n  static ModuleNotFoundError = _ModuleNotFoundError.default;\n\n  static tryCastModuleNotFoundError(error) {\n    if (error instanceof _ModuleNotFoundError.default) {\n      return error;\n    }\n\n    const casted = error;\n\n    if (casted.code === 'MODULE_NOT_FOUND') {\n      return _ModuleNotFoundError.default.duckType(casted);\n    }\n\n    return null;\n  }\n\n  static clearDefaultResolverCache() {\n    (0, _fileWalkers.clearFsCache)();\n    (0, _shouldLoadAsEsm.clearCachedLookups)();\n  }\n\n  static findNodeModule(path, options) {\n    const resolverModule = loadResolver(options.resolver);\n    let resolver = _defaultResolver.default;\n\n    if (typeof resolverModule === 'function') {\n      resolver = resolverModule;\n    } else if (typeof resolverModule.sync === 'function') {\n      resolver = resolverModule.sync;\n    }\n\n    const paths = options.paths;\n\n    try {\n      return resolver(path, {\n        basedir: options.basedir,\n        conditions: options.conditions,\n        defaultResolver: _defaultResolver.default,\n        extensions: options.extensions,\n        moduleDirectory: options.moduleDirectory,\n        paths: paths ? (nodePaths || []).concat(paths) : nodePaths,\n        rootDir: options.rootDir\n      });\n    } catch (e) {\n      if (options.throwIfNotFound) {\n        throw e;\n      }\n    }\n\n    return null;\n  }\n\n  static async findNodeModuleAsync(path, options) {\n    const resolverModule = loadResolver(options.resolver);\n    let resolver = _defaultResolver.default;\n\n    if (typeof resolverModule === 'function') {\n      resolver = resolverModule;\n    } else if (\n      typeof resolverModule.async === 'function' ||\n      typeof resolverModule.sync === 'function'\n    ) {\n      const asyncOrSync = resolverModule.async || resolverModule.sync;\n\n      if (asyncOrSync == null) {\n        throw new Error(`Unable to load resolver at ${options.resolver}`);\n      }\n\n      resolver = asyncOrSync;\n    }\n\n    const paths = options.paths;\n\n    try {\n      const result = await resolver(path, {\n        basedir: options.basedir,\n        conditions: options.conditions,\n        defaultResolver: _defaultResolver.default,\n        extensions: options.extensions,\n        moduleDirectory: options.moduleDirectory,\n        paths: paths ? (nodePaths || []).concat(paths) : nodePaths,\n        rootDir: options.rootDir\n      });\n      return result;\n    } catch (e) {\n      if (options.throwIfNotFound) {\n        throw e;\n      }\n    }\n\n    return null;\n  } // unstable as it should be replaced by https://github.com/nodejs/modules/issues/393, and we don't want people to use it\n\n  static unstable_shouldLoadAsEsm = _shouldLoadAsEsm.default;\n\n  resolveModuleFromDirIfExists(dirname, moduleName, options) {\n    const {extensions, key, moduleDirectory, paths, skipResolution} =\n      this._prepareForResolution(dirname, moduleName, options);\n\n    let module; // 1. If we have already resolved this module for this directory name,\n    // return a value from the cache.\n\n    const cacheResult = this._moduleNameCache.get(key);\n\n    if (cacheResult) {\n      return cacheResult;\n    } // 2. Check if the module is a haste module.\n\n    module = this.getModule(moduleName);\n\n    if (module) {\n      this._moduleNameCache.set(key, module);\n\n      return module;\n    } // 3. Check if the module is a node module and resolve it based on\n    // the node module resolution algorithm. If skipNodeResolution is given we\n    // ignore all modules that look like node modules (ie. are not relative\n    // requires). This enables us to speed up resolution when we build a\n    // dependency graph because we don't have to look at modules that may not\n    // exist and aren't mocked.\n\n    const resolveNodeModule = (name, throwIfNotFound = false) => {\n      // Only skip default resolver\n      if (this.isCoreModule(name) && !this._options.resolver) {\n        return name;\n      }\n\n      return Resolver.findNodeModule(name, {\n        basedir: dirname,\n        conditions:\n          options === null || options === void 0 ? void 0 : options.conditions,\n        extensions,\n        moduleDirectory,\n        paths,\n        resolver: this._options.resolver,\n        rootDir: this._options.rootDir,\n        throwIfNotFound\n      });\n    };\n\n    if (!skipResolution) {\n      module = resolveNodeModule(moduleName, Boolean(process.versions.pnp));\n\n      if (module) {\n        this._moduleNameCache.set(key, module);\n\n        return module;\n      }\n    } // 4. Resolve \"haste packages\" which are `package.json` files outside of\n    // `node_modules` folders anywhere in the file system.\n\n    try {\n      const hasteModulePath = this._getHasteModulePath(moduleName);\n\n      if (hasteModulePath) {\n        // try resolving with custom resolver first to support extensions,\n        // then fallback to require.resolve\n        const resolvedModule =\n          resolveNodeModule(hasteModulePath) ||\n          require.resolve(hasteModulePath);\n\n        this._moduleNameCache.set(key, resolvedModule);\n\n        return resolvedModule;\n      }\n    } catch {}\n\n    return null;\n  }\n\n  async resolveModuleFromDirIfExistsAsync(dirname, moduleName, options) {\n    const {extensions, key, moduleDirectory, paths, skipResolution} =\n      this._prepareForResolution(dirname, moduleName, options);\n\n    let module; // 1. If we have already resolved this module for this directory name,\n    // return a value from the cache.\n\n    const cacheResult = this._moduleNameCache.get(key);\n\n    if (cacheResult) {\n      return cacheResult;\n    } // 2. Check if the module is a haste module.\n\n    module = this.getModule(moduleName);\n\n    if (module) {\n      this._moduleNameCache.set(key, module);\n\n      return module;\n    } // 3. Check if the module is a node module and resolve it based on\n    // the node module resolution algorithm. If skipNodeResolution is given we\n    // ignore all modules that look like node modules (ie. are not relative\n    // requires). This enables us to speed up resolution when we build a\n    // dependency graph because we don't have to look at modules that may not\n    // exist and aren't mocked.\n\n    const resolveNodeModule = async (name, throwIfNotFound = false) => {\n      // Only skip default resolver\n      if (this.isCoreModule(name) && !this._options.resolver) {\n        return name;\n      }\n\n      return await Resolver.findNodeModuleAsync(name, {\n        basedir: dirname,\n        conditions:\n          options === null || options === void 0 ? void 0 : options.conditions,\n        extensions,\n        moduleDirectory,\n        paths,\n        resolver: this._options.resolver,\n        rootDir: this._options.rootDir,\n        throwIfNotFound\n      });\n    };\n\n    if (!skipResolution) {\n      module = await resolveNodeModule(\n        moduleName,\n        Boolean(process.versions.pnp)\n      );\n\n      if (module) {\n        this._moduleNameCache.set(key, module);\n\n        return module;\n      }\n    } // 4. Resolve \"haste packages\" which are `package.json` files outside of\n    // `node_modules` folders anywhere in the file system.\n\n    try {\n      const hasteModulePath = this._getHasteModulePath(moduleName);\n\n      if (hasteModulePath) {\n        // try resolving with custom resolver first to support extensions,\n        // then fallback to require.resolve\n        const resolvedModule =\n          (await resolveNodeModule(hasteModulePath)) || // QUESTION: should this be async?\n          require.resolve(hasteModulePath);\n\n        this._moduleNameCache.set(key, resolvedModule);\n\n        return resolvedModule;\n      }\n    } catch {}\n\n    return null;\n  }\n\n  resolveModule(from, moduleName, options) {\n    const dirname = path().dirname(from);\n    const module =\n      this.resolveStubModuleName(from, moduleName) ||\n      this.resolveModuleFromDirIfExists(dirname, moduleName, options);\n    if (module) return module; // 5. Throw an error if the module could not be found. `resolve.sync` only\n    // produces an error based on the dirname but we have the actual current\n    // module name available.\n\n    this._throwModNotFoundError(from, moduleName);\n  }\n\n  async resolveModuleAsync(from, moduleName, options) {\n    const dirname = path().dirname(from);\n    const module =\n      (await this.resolveStubModuleNameAsync(from, moduleName)) ||\n      (await this.resolveModuleFromDirIfExistsAsync(\n        dirname,\n        moduleName,\n        options\n      ));\n    if (module) return module; // 5. Throw an error if the module could not be found. `resolve` only\n    // produces an error based on the dirname but we have the actual current\n    // module name available.\n\n    this._throwModNotFoundError(from, moduleName);\n  }\n  /**\n   * _prepareForResolution is shared between the sync and async module resolution\n   * methods, to try to keep them as DRY as possible.\n   */\n\n  _prepareForResolution(dirname, moduleName, options) {\n    const paths =\n      (options === null || options === void 0 ? void 0 : options.paths) ||\n      this._options.modulePaths;\n    const moduleDirectory = this._options.moduleDirectories;\n    const stringifiedOptions = options ? JSON.stringify(options) : '';\n    const key = dirname + path().delimiter + moduleName + stringifiedOptions;\n    const defaultPlatform = this._options.defaultPlatform;\n\n    const extensions = this._options.extensions.slice();\n\n    if (this._supportsNativePlatform) {\n      extensions.unshift(\n        ...this._options.extensions.map(ext => `.${NATIVE_PLATFORM}${ext}`)\n      );\n    }\n\n    if (defaultPlatform) {\n      extensions.unshift(\n        ...this._options.extensions.map(ext => `.${defaultPlatform}${ext}`)\n      );\n    }\n\n    const skipResolution =\n      options && options.skipNodeResolution && !moduleName.includes(path().sep);\n    return {\n      extensions,\n      key,\n      moduleDirectory,\n      paths,\n      skipResolution\n    };\n  }\n  /**\n   * _getHasteModulePath attempts to return the path to a haste module.\n   */\n\n  _getHasteModulePath(moduleName) {\n    const parts = moduleName.split('/');\n    const hastePackage = this.getPackage(parts.shift());\n\n    if (hastePackage) {\n      return path().join.apply(\n        path(),\n        [path().dirname(hastePackage)].concat(parts)\n      );\n    }\n\n    return null;\n  }\n\n  _throwModNotFoundError(from, moduleName) {\n    const relativePath =\n      (0, _slash().default)(path().relative(this._options.rootDir, from)) ||\n      '.';\n    throw new _ModuleNotFoundError.default(\n      `Cannot find module '${moduleName}' from '${relativePath}'`,\n      moduleName\n    );\n  }\n\n  _getMapModuleName(matches) {\n    return matches\n      ? moduleName =>\n          moduleName.replace(\n            /\\$([0-9]+)/g,\n            (_, index) => matches[parseInt(index, 10)]\n          )\n      : moduleName => moduleName;\n  }\n\n  _isAliasModule(moduleName) {\n    const moduleNameMapper = this._options.moduleNameMapper;\n\n    if (!moduleNameMapper) {\n      return false;\n    }\n\n    return moduleNameMapper.some(({regex}) => regex.test(moduleName));\n  }\n\n  isCoreModule(moduleName) {\n    return (\n      this._options.hasCoreModules &&\n      ((0, _isBuiltinModule.default)(moduleName) ||\n        (moduleName.startsWith('node:') &&\n          (0, _isBuiltinModule.default)(moduleName.slice('node:'.length)))) &&\n      !this._isAliasModule(moduleName)\n    );\n  }\n\n  getModule(name) {\n    return this._moduleMap.getModule(\n      name,\n      this._options.defaultPlatform,\n      this._supportsNativePlatform\n    );\n  }\n\n  getModulePath(from, moduleName) {\n    if (moduleName[0] !== '.' || path().isAbsolute(moduleName)) {\n      return moduleName;\n    }\n\n    return path().normalize(`${path().dirname(from)}/${moduleName}`);\n  }\n\n  getPackage(name) {\n    return this._moduleMap.getPackage(\n      name,\n      this._options.defaultPlatform,\n      this._supportsNativePlatform\n    );\n  }\n\n  getMockModule(from, name) {\n    const mock = this._moduleMap.getMockModule(name);\n\n    if (mock) {\n      return mock;\n    } else {\n      const moduleName = this.resolveStubModuleName(from, name);\n\n      if (moduleName) {\n        return this.getModule(moduleName) || moduleName;\n      }\n    }\n\n    return null;\n  }\n\n  async getMockModuleAsync(from, name) {\n    const mock = this._moduleMap.getMockModule(name);\n\n    if (mock) {\n      return mock;\n    } else {\n      const moduleName = await this.resolveStubModuleNameAsync(from, name);\n\n      if (moduleName) {\n        return this.getModule(moduleName) || moduleName;\n      }\n    }\n\n    return null;\n  }\n\n  getModulePaths(from) {\n    const cachedModule = this._modulePathCache.get(from);\n\n    if (cachedModule) {\n      return cachedModule;\n    }\n\n    const moduleDirectory = this._options.moduleDirectories;\n    const paths = (0, _nodeModulesPaths.default)(from, {\n      moduleDirectory\n    });\n\n    if (paths[paths.length - 1] === undefined) {\n      // circumvent node-resolve bug that adds `undefined` as last item.\n      paths.pop();\n    }\n\n    this._modulePathCache.set(from, paths);\n\n    return paths;\n  }\n\n  getModuleID(virtualMocks, from, moduleName = '', options) {\n    const stringifiedOptions = options ? JSON.stringify(options) : '';\n    const key = from + path().delimiter + moduleName + stringifiedOptions;\n\n    const cachedModuleID = this._moduleIDCache.get(key);\n\n    if (cachedModuleID) {\n      return cachedModuleID;\n    }\n\n    const moduleType = this._getModuleType(moduleName);\n\n    const absolutePath = this._getAbsolutePath(\n      virtualMocks,\n      from,\n      moduleName,\n      options\n    );\n\n    const mockPath = this._getMockPath(from, moduleName);\n\n    const sep = path().delimiter;\n    const id =\n      moduleType +\n      sep +\n      (absolutePath ? absolutePath + sep : '') +\n      (mockPath ? mockPath + sep : '') +\n      (stringifiedOptions ? stringifiedOptions + sep : '');\n\n    this._moduleIDCache.set(key, id);\n\n    return id;\n  }\n\n  async getModuleIDAsync(virtualMocks, from, moduleName = '', options) {\n    const stringifiedOptions = options ? JSON.stringify(options) : '';\n    const key = from + path().delimiter + moduleName + stringifiedOptions;\n\n    const cachedModuleID = this._moduleIDCache.get(key);\n\n    if (cachedModuleID) {\n      return cachedModuleID;\n    }\n\n    if (moduleName.startsWith('data:')) {\n      return moduleName;\n    }\n\n    const moduleType = this._getModuleType(moduleName);\n\n    const absolutePath = await this._getAbsolutePathAsync(\n      virtualMocks,\n      from,\n      moduleName,\n      options\n    );\n    const mockPath = await this._getMockPathAsync(from, moduleName);\n    const sep = path().delimiter;\n    const id =\n      moduleType +\n      sep +\n      (absolutePath ? absolutePath + sep : '') +\n      (mockPath ? mockPath + sep : '') +\n      (stringifiedOptions ? stringifiedOptions + sep : '');\n\n    this._moduleIDCache.set(key, id);\n\n    return id;\n  }\n\n  _getModuleType(moduleName) {\n    return this.isCoreModule(moduleName) ? 'node' : 'user';\n  }\n\n  _getAbsolutePath(virtualMocks, from, moduleName, options) {\n    if (this.isCoreModule(moduleName)) {\n      return moduleName;\n    }\n\n    if (moduleName.startsWith('data:')) {\n      return moduleName;\n    }\n\n    return this._isModuleResolved(from, moduleName)\n      ? this.getModule(moduleName)\n      : this._getVirtualMockPath(virtualMocks, from, moduleName, options);\n  }\n\n  async _getAbsolutePathAsync(virtualMocks, from, moduleName, options) {\n    if (this.isCoreModule(moduleName)) {\n      return moduleName;\n    }\n\n    if (moduleName.startsWith('data:')) {\n      return moduleName;\n    }\n\n    const isModuleResolved = await this._isModuleResolvedAsync(\n      from,\n      moduleName\n    );\n    return isModuleResolved\n      ? this.getModule(moduleName)\n      : await this._getVirtualMockPathAsync(\n          virtualMocks,\n          from,\n          moduleName,\n          options\n        );\n  }\n\n  _getMockPath(from, moduleName) {\n    return !this.isCoreModule(moduleName)\n      ? this.getMockModule(from, moduleName)\n      : null;\n  }\n\n  async _getMockPathAsync(from, moduleName) {\n    return !this.isCoreModule(moduleName)\n      ? await this.getMockModuleAsync(from, moduleName)\n      : null;\n  }\n\n  _getVirtualMockPath(virtualMocks, from, moduleName, options) {\n    const virtualMockPath = this.getModulePath(from, moduleName);\n    return virtualMocks.get(virtualMockPath)\n      ? virtualMockPath\n      : moduleName\n      ? this.resolveModule(from, moduleName, options)\n      : from;\n  }\n\n  async _getVirtualMockPathAsync(virtualMocks, from, moduleName, options) {\n    const virtualMockPath = this.getModulePath(from, moduleName);\n    return virtualMocks.get(virtualMockPath)\n      ? virtualMockPath\n      : moduleName\n      ? await this.resolveModuleAsync(from, moduleName, options)\n      : from;\n  }\n\n  _isModuleResolved(from, moduleName) {\n    return !!(\n      this.getModule(moduleName) || this.getMockModule(from, moduleName)\n    );\n  }\n\n  async _isModuleResolvedAsync(from, moduleName) {\n    return !!(\n      this.getModule(moduleName) ||\n      (await this.getMockModuleAsync(from, moduleName))\n    );\n  }\n\n  resolveStubModuleName(from, moduleName) {\n    const dirname = path().dirname(from);\n\n    const {extensions, moduleDirectory, paths} = this._prepareForResolution(\n      dirname,\n      moduleName\n    );\n\n    const moduleNameMapper = this._options.moduleNameMapper;\n    const resolver = this._options.resolver;\n\n    if (moduleNameMapper) {\n      for (const {moduleName: mappedModuleName, regex} of moduleNameMapper) {\n        if (regex.test(moduleName)) {\n          // Note: once a moduleNameMapper matches the name, it must result\n          // in a module, or else an error is thrown.\n          const matches = moduleName.match(regex);\n\n          const mapModuleName = this._getMapModuleName(matches);\n\n          const possibleModuleNames = Array.isArray(mappedModuleName)\n            ? mappedModuleName\n            : [mappedModuleName];\n          let module = null;\n\n          for (const possibleModuleName of possibleModuleNames) {\n            const updatedName = mapModuleName(possibleModuleName);\n            module =\n              this.getModule(updatedName) ||\n              Resolver.findNodeModule(updatedName, {\n                basedir: dirname,\n                extensions,\n                moduleDirectory,\n                paths,\n                resolver,\n                rootDir: this._options.rootDir\n              });\n\n            if (module) {\n              break;\n            }\n          }\n\n          if (!module) {\n            throw createNoMappedModuleFoundError(\n              moduleName,\n              mapModuleName,\n              mappedModuleName,\n              regex,\n              resolver\n            );\n          }\n\n          return module;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  async resolveStubModuleNameAsync(from, moduleName) {\n    const dirname = path().dirname(from);\n\n    const {extensions, moduleDirectory, paths} = this._prepareForResolution(\n      dirname,\n      moduleName\n    );\n\n    const moduleNameMapper = this._options.moduleNameMapper;\n    const resolver = this._options.resolver;\n\n    if (moduleNameMapper) {\n      for (const {moduleName: mappedModuleName, regex} of moduleNameMapper) {\n        if (regex.test(moduleName)) {\n          // Note: once a moduleNameMapper matches the name, it must result\n          // in a module, or else an error is thrown.\n          const matches = moduleName.match(regex);\n\n          const mapModuleName = this._getMapModuleName(matches);\n\n          const possibleModuleNames = Array.isArray(mappedModuleName)\n            ? mappedModuleName\n            : [mappedModuleName];\n          let module = null;\n\n          for (const possibleModuleName of possibleModuleNames) {\n            const updatedName = mapModuleName(possibleModuleName);\n            module =\n              this.getModule(updatedName) ||\n              (await Resolver.findNodeModuleAsync(updatedName, {\n                basedir: dirname,\n                extensions,\n                moduleDirectory,\n                paths,\n                resolver,\n                rootDir: this._options.rootDir\n              }));\n\n            if (module) {\n              break;\n            }\n          }\n\n          if (!module) {\n            throw createNoMappedModuleFoundError(\n              moduleName,\n              mapModuleName,\n              mappedModuleName,\n              regex,\n              resolver\n            );\n          }\n\n          return module;\n        }\n      }\n    }\n\n    return null;\n  }\n}\n\nexports.default = Resolver;\n\nconst createNoMappedModuleFoundError = (\n  moduleName,\n  mapModuleName,\n  mappedModuleName,\n  regex,\n  resolver\n) => {\n  const mappedAs = Array.isArray(mappedModuleName)\n    ? JSON.stringify(mappedModuleName.map(mapModuleName), null, 2)\n    : mappedModuleName;\n  const original = Array.isArray(mappedModuleName)\n    ? `${\n        JSON.stringify(mappedModuleName, null, 6) // using 6 because of misalignment when nested below\n          .slice(0, -1) + ' '.repeat(4)\n      }]` /// align last bracket correctly as well\n    : mappedModuleName;\n  const error = new Error(\n    _chalk().default.red(`${_chalk().default.bold('Configuration error')}:\n\nCould not locate module ${_chalk().default.bold(moduleName)} mapped as:\n${_chalk().default.bold(mappedAs)}.\n\nPlease check your configuration for these entries:\n{\n  \"moduleNameMapper\": {\n    \"${regex.toString()}\": \"${_chalk().default.bold(original)}\"\n  },\n  \"resolver\": ${_chalk().default.bold(String(resolver))}\n}`)\n  );\n  error.name = '';\n  return error;\n};\n\nfunction loadResolver(resolver) {\n  if (resolver == null) {\n    return _defaultResolver.default;\n  }\n\n  const loadedResolver = require(resolver);\n\n  if (loadedResolver == null) {\n    throw new Error(`Resolver located at ${resolver} does not export anything`);\n  }\n\n  if (typeof loadedResolver === 'function') {\n    return loadedResolver;\n  }\n\n  if (\n    typeof loadedResolver === 'object' &&\n    (loadedResolver.sync != null || loadedResolver.async != null)\n  ) {\n    return loadedResolver;\n  }\n\n  throw new Error(\n    `Resolver located at ${resolver} does not export a function or an object with \"sync\" and \"async\" props`\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}