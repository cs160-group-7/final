{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _cleanupSemantic = require('./cleanupSemantic');\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// Given change op and array of diffs, return concatenated string:\n// * include common strings\n// * include change strings which have argument op with changeColor\n// * exclude change strings which have opposite op\n\n\nconst concatenateRelevantDiffs = (op, diffs, changeColor) => diffs.reduce((reduced, diff) => reduced + (diff[0] === _cleanupSemantic.DIFF_EQUAL ? diff[1] : diff[0] === op && diff[1].length !== 0 // empty if change is newline\n? changeColor(diff[1]) : ''), ''); // Encapsulate change lines until either a common newline or the end.\n\n\nclass ChangeBuffer {\n  op;\n  line; // incomplete line\n\n  lines; // complete lines\n\n  changeColor;\n\n  constructor(op, changeColor) {\n    this.op = op;\n    this.line = [];\n    this.lines = [];\n    this.changeColor = changeColor;\n  }\n\n  pushSubstring(substring) {\n    this.pushDiff(new _cleanupSemantic.Diff(this.op, substring));\n  }\n\n  pushLine() {\n    // Assume call only if line has at least one diff,\n    // therefore an empty line must have a diff which has an empty string.\n    // If line has multiple diffs, then assume it has a common diff,\n    // therefore change diffs have change color;\n    // otherwise then it has line color only.\n    this.lines.push(this.line.length !== 1 ? new _cleanupSemantic.Diff(this.op, concatenateRelevantDiffs(this.op, this.line, this.changeColor)) : this.line[0][0] === this.op ? this.line[0] // can use instance\n    : new _cleanupSemantic.Diff(this.op, this.line[0][1]) // was common diff\n    );\n    this.line.length = 0;\n  }\n\n  isLineEmpty() {\n    return this.line.length === 0;\n  } // Minor input to buffer.\n\n\n  pushDiff(diff) {\n    this.line.push(diff);\n  } // Main input to buffer.\n\n\n  align(diff) {\n    const string = diff[1];\n\n    if (string.includes('\\n')) {\n      const substrings = string.split('\\n');\n      const iLast = substrings.length - 1;\n      substrings.forEach((substring, i) => {\n        if (i < iLast) {\n          // The first substring completes the current change line.\n          // A middle substring is a change line.\n          this.pushSubstring(substring);\n          this.pushLine();\n        } else if (substring.length !== 0) {\n          // The last substring starts a change line, if it is not empty.\n          // Important: This non-empty condition also automatically omits\n          // the newline appended to the end of expected and received strings.\n          this.pushSubstring(substring);\n        }\n      });\n    } else {\n      // Append non-multiline string to current change line.\n      this.pushDiff(diff);\n    }\n  } // Output from buffer.\n\n\n  moveLinesTo(lines) {\n    if (!this.isLineEmpty()) {\n      this.pushLine();\n    }\n\n    lines.push(...this.lines);\n    this.lines.length = 0;\n  }\n\n} // Encapsulate common and change lines.\n\n\nclass CommonBuffer {\n  deleteBuffer;\n  insertBuffer;\n  lines;\n\n  constructor(deleteBuffer, insertBuffer) {\n    this.deleteBuffer = deleteBuffer;\n    this.insertBuffer = insertBuffer;\n    this.lines = [];\n  }\n\n  pushDiffCommonLine(diff) {\n    this.lines.push(diff);\n  }\n\n  pushDiffChangeLines(diff) {\n    const isDiffEmpty = diff[1].length === 0; // An empty diff string is redundant, unless a change line is empty.\n\n    if (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) {\n      this.deleteBuffer.pushDiff(diff);\n    }\n\n    if (!isDiffEmpty || this.insertBuffer.isLineEmpty()) {\n      this.insertBuffer.pushDiff(diff);\n    }\n  }\n\n  flushChangeLines() {\n    this.deleteBuffer.moveLinesTo(this.lines);\n    this.insertBuffer.moveLinesTo(this.lines);\n  } // Input to buffer.\n\n\n  align(diff) {\n    const op = diff[0];\n    const string = diff[1];\n\n    if (string.includes('\\n')) {\n      const substrings = string.split('\\n');\n      const iLast = substrings.length - 1;\n      substrings.forEach((substring, i) => {\n        if (i === 0) {\n          const subdiff = new _cleanupSemantic.Diff(op, substring);\n\n          if (this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty()) {\n            // If both current change lines are empty,\n            // then the first substring is a common line.\n            this.flushChangeLines();\n            this.pushDiffCommonLine(subdiff);\n          } else {\n            // If either current change line is non-empty,\n            // then the first substring completes the change lines.\n            this.pushDiffChangeLines(subdiff);\n            this.flushChangeLines();\n          }\n        } else if (i < iLast) {\n          // A middle substring is a common line.\n          this.pushDiffCommonLine(new _cleanupSemantic.Diff(op, substring));\n        } else if (substring.length !== 0) {\n          // The last substring starts a change line, if it is not empty.\n          // Important: This non-empty condition also automatically omits\n          // the newline appended to the end of expected and received strings.\n          this.pushDiffChangeLines(new _cleanupSemantic.Diff(op, substring));\n        }\n      });\n    } else {\n      // Append non-multiline string to current change lines.\n      // Important: It cannot be at the end following empty change lines,\n      // because newline appended to the end of expected and received strings.\n      this.pushDiffChangeLines(diff);\n    }\n  } // Output from buffer.\n\n\n  getLines() {\n    this.flushChangeLines();\n    return this.lines;\n  }\n\n} // Given diffs from expected and received strings,\n// return new array of diffs split or joined into lines.\n//\n// To correctly align a change line at the end, the algorithm:\n// * assumes that a newline was appended to the strings\n// * omits the last newline from the output array\n//\n// Assume the function is not called:\n// * if either expected or received is empty string\n// * if neither expected nor received is multiline string\n\n\nconst getAlignedDiffs = (diffs, changeColor) => {\n  const deleteBuffer = new ChangeBuffer(_cleanupSemantic.DIFF_DELETE, changeColor);\n  const insertBuffer = new ChangeBuffer(_cleanupSemantic.DIFF_INSERT, changeColor);\n  const commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);\n  diffs.forEach(diff => {\n    switch (diff[0]) {\n      case _cleanupSemantic.DIFF_DELETE:\n        deleteBuffer.align(diff);\n        break;\n\n      case _cleanupSemantic.DIFF_INSERT:\n        insertBuffer.align(diff);\n        break;\n\n      default:\n        commonBuffer.align(diff);\n    }\n  });\n  return commonBuffer.getLines();\n};\n\nvar _default = getAlignedDiffs;\nexports.default = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_cleanupSemantic","require","concatenateRelevantDiffs","op","diffs","changeColor","reduce","reduced","diff","DIFF_EQUAL","length","ChangeBuffer","line","lines","constructor","pushSubstring","substring","pushDiff","Diff","pushLine","push","isLineEmpty","align","string","includes","substrings","split","iLast","forEach","i","moveLinesTo","CommonBuffer","deleteBuffer","insertBuffer","pushDiffCommonLine","pushDiffChangeLines","isDiffEmpty","flushChangeLines","subdiff","getLines","getAlignedDiffs","DIFF_DELETE","DIFF_INSERT","commonBuffer","_default"],"sources":["/Users/wonjaelee/Desktop/final/node_modules/jest-diff/build/getAlignedDiffs.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _cleanupSemantic = require('./cleanupSemantic');\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// Given change op and array of diffs, return concatenated string:\n// * include common strings\n// * include change strings which have argument op with changeColor\n// * exclude change strings which have opposite op\nconst concatenateRelevantDiffs = (op, diffs, changeColor) =>\n  diffs.reduce(\n    (reduced, diff) =>\n      reduced +\n      (diff[0] === _cleanupSemantic.DIFF_EQUAL\n        ? diff[1]\n        : diff[0] === op && diff[1].length !== 0 // empty if change is newline\n        ? changeColor(diff[1])\n        : ''),\n    ''\n  ); // Encapsulate change lines until either a common newline or the end.\n\nclass ChangeBuffer {\n  op;\n  line; // incomplete line\n\n  lines; // complete lines\n\n  changeColor;\n\n  constructor(op, changeColor) {\n    this.op = op;\n    this.line = [];\n    this.lines = [];\n    this.changeColor = changeColor;\n  }\n\n  pushSubstring(substring) {\n    this.pushDiff(new _cleanupSemantic.Diff(this.op, substring));\n  }\n\n  pushLine() {\n    // Assume call only if line has at least one diff,\n    // therefore an empty line must have a diff which has an empty string.\n    // If line has multiple diffs, then assume it has a common diff,\n    // therefore change diffs have change color;\n    // otherwise then it has line color only.\n    this.lines.push(\n      this.line.length !== 1\n        ? new _cleanupSemantic.Diff(\n            this.op,\n            concatenateRelevantDiffs(this.op, this.line, this.changeColor)\n          )\n        : this.line[0][0] === this.op\n        ? this.line[0] // can use instance\n        : new _cleanupSemantic.Diff(this.op, this.line[0][1]) // was common diff\n    );\n    this.line.length = 0;\n  }\n\n  isLineEmpty() {\n    return this.line.length === 0;\n  } // Minor input to buffer.\n\n  pushDiff(diff) {\n    this.line.push(diff);\n  } // Main input to buffer.\n\n  align(diff) {\n    const string = diff[1];\n\n    if (string.includes('\\n')) {\n      const substrings = string.split('\\n');\n      const iLast = substrings.length - 1;\n      substrings.forEach((substring, i) => {\n        if (i < iLast) {\n          // The first substring completes the current change line.\n          // A middle substring is a change line.\n          this.pushSubstring(substring);\n          this.pushLine();\n        } else if (substring.length !== 0) {\n          // The last substring starts a change line, if it is not empty.\n          // Important: This non-empty condition also automatically omits\n          // the newline appended to the end of expected and received strings.\n          this.pushSubstring(substring);\n        }\n      });\n    } else {\n      // Append non-multiline string to current change line.\n      this.pushDiff(diff);\n    }\n  } // Output from buffer.\n\n  moveLinesTo(lines) {\n    if (!this.isLineEmpty()) {\n      this.pushLine();\n    }\n\n    lines.push(...this.lines);\n    this.lines.length = 0;\n  }\n} // Encapsulate common and change lines.\n\nclass CommonBuffer {\n  deleteBuffer;\n  insertBuffer;\n  lines;\n\n  constructor(deleteBuffer, insertBuffer) {\n    this.deleteBuffer = deleteBuffer;\n    this.insertBuffer = insertBuffer;\n    this.lines = [];\n  }\n\n  pushDiffCommonLine(diff) {\n    this.lines.push(diff);\n  }\n\n  pushDiffChangeLines(diff) {\n    const isDiffEmpty = diff[1].length === 0; // An empty diff string is redundant, unless a change line is empty.\n\n    if (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) {\n      this.deleteBuffer.pushDiff(diff);\n    }\n\n    if (!isDiffEmpty || this.insertBuffer.isLineEmpty()) {\n      this.insertBuffer.pushDiff(diff);\n    }\n  }\n\n  flushChangeLines() {\n    this.deleteBuffer.moveLinesTo(this.lines);\n    this.insertBuffer.moveLinesTo(this.lines);\n  } // Input to buffer.\n\n  align(diff) {\n    const op = diff[0];\n    const string = diff[1];\n\n    if (string.includes('\\n')) {\n      const substrings = string.split('\\n');\n      const iLast = substrings.length - 1;\n      substrings.forEach((substring, i) => {\n        if (i === 0) {\n          const subdiff = new _cleanupSemantic.Diff(op, substring);\n\n          if (\n            this.deleteBuffer.isLineEmpty() &&\n            this.insertBuffer.isLineEmpty()\n          ) {\n            // If both current change lines are empty,\n            // then the first substring is a common line.\n            this.flushChangeLines();\n            this.pushDiffCommonLine(subdiff);\n          } else {\n            // If either current change line is non-empty,\n            // then the first substring completes the change lines.\n            this.pushDiffChangeLines(subdiff);\n            this.flushChangeLines();\n          }\n        } else if (i < iLast) {\n          // A middle substring is a common line.\n          this.pushDiffCommonLine(new _cleanupSemantic.Diff(op, substring));\n        } else if (substring.length !== 0) {\n          // The last substring starts a change line, if it is not empty.\n          // Important: This non-empty condition also automatically omits\n          // the newline appended to the end of expected and received strings.\n          this.pushDiffChangeLines(new _cleanupSemantic.Diff(op, substring));\n        }\n      });\n    } else {\n      // Append non-multiline string to current change lines.\n      // Important: It cannot be at the end following empty change lines,\n      // because newline appended to the end of expected and received strings.\n      this.pushDiffChangeLines(diff);\n    }\n  } // Output from buffer.\n\n  getLines() {\n    this.flushChangeLines();\n    return this.lines;\n  }\n} // Given diffs from expected and received strings,\n// return new array of diffs split or joined into lines.\n//\n// To correctly align a change line at the end, the algorithm:\n// * assumes that a newline was appended to the strings\n// * omits the last newline from the output array\n//\n// Assume the function is not called:\n// * if either expected or received is empty string\n// * if neither expected nor received is multiline string\n\nconst getAlignedDiffs = (diffs, changeColor) => {\n  const deleteBuffer = new ChangeBuffer(\n    _cleanupSemantic.DIFF_DELETE,\n    changeColor\n  );\n  const insertBuffer = new ChangeBuffer(\n    _cleanupSemantic.DIFF_INSERT,\n    changeColor\n  );\n  const commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);\n  diffs.forEach(diff => {\n    switch (diff[0]) {\n      case _cleanupSemantic.DIFF_DELETE:\n        deleteBuffer.align(diff);\n        break;\n\n      case _cleanupSemantic.DIFF_INSERT:\n        insertBuffer.align(diff);\n        break;\n\n      default:\n        commonBuffer.align(diff);\n    }\n  });\n  return commonBuffer.getLines();\n};\n\nvar _default = getAlignedDiffs;\nexports.default = _default;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}