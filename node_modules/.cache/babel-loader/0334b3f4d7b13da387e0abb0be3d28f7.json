{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.saveInlineSnapshots = saveInlineSnapshots;\n\nvar path = _interopRequireWildcard(require('path'));\n\nvar _types = require('@babel/types');\n\nvar fs = _interopRequireWildcard(require('graceful-fs'));\n\nvar _semver = _interopRequireDefault(require('semver'));\n\nvar _utils = require('./utils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nvar Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;\nvar Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;\nvar jestWriteFile = globalThis[Symbol.for('jest-native-write-file')] || fs.writeFileSync;\nvar Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;\nvar jestReadFile = globalThis[Symbol.for('jest-native-read-file')] || fs.readFileSync; // prettier-ignore\n\nconst babelTraverse = // @ts-expect-error requireOutside Babel transform\nrequire(require.resolve('@babel/traverse', {\n  [(globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol).for('jest-resolve-outside-vm-option')]: true\n})).default; // prettier-ignore\n\n\nconst generate = // @ts-expect-error requireOutside Babel transform\nrequire(require.resolve('@babel/generator', {\n  [(globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol).for('jest-resolve-outside-vm-option')]: true\n})).default; // @ts-expect-error requireOutside Babel transform\n\n\nconst {\n  file,\n  templateElement,\n  templateLiteral\n} = require(require.resolve('@babel/types', {\n  [(globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol).for('jest-resolve-outside-vm-option')]: true\n})); // @ts-expect-error requireOutside Babel transform\n\n\nconst {\n  parseSync\n} = require(require.resolve('@babel/core', {\n  [(globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol).for('jest-resolve-outside-vm-option')]: true\n}));\n\nfunction saveInlineSnapshots(snapshots, prettierPath) {\n  let prettier = null;\n\n  if (prettierPath) {\n    try {\n      // @ts-expect-error requireOutside Babel transform\n      prettier = require(require.resolve(prettierPath, {\n        [(globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol).for('jest-resolve-outside-vm-option')]: true\n      }));\n    } catch {// Continue even if prettier is not installed.\n    }\n  }\n\n  const snapshotsByFile = groupSnapshotsByFile(snapshots);\n\n  for (const sourceFilePath of Object.keys(snapshotsByFile)) {\n    saveSnapshotsForFile(snapshotsByFile[sourceFilePath], sourceFilePath, prettier && _semver.default.gte(prettier.version, '1.5.0') ? prettier : undefined);\n  }\n}\n\nconst saveSnapshotsForFile = (snapshots, sourceFilePath, prettier) => {\n  const sourceFile = jestReadFile(sourceFilePath, 'utf8'); // TypeScript projects may not have a babel config; make sure they can be parsed anyway.\n\n  const presets = [require.resolve('babel-preset-current-node-syntax')];\n  const plugins = [];\n\n  if (/\\.tsx?$/.test(sourceFilePath)) {\n    plugins.push([require.resolve('@babel/plugin-syntax-typescript'), {\n      isTSX: sourceFilePath.endsWith('x')\n    }, // unique name to make sure Babel does not complain about a possible duplicate plugin.\n    'TypeScript syntax plugin added by Jest snapshot']);\n  } // Record the matcher names seen during traversal and pass them down one\n  // by one to formatting parser.\n\n\n  const snapshotMatcherNames = [];\n  const ast = parseSync(sourceFile, {\n    filename: sourceFilePath,\n    plugins,\n    presets,\n    root: path.dirname(sourceFilePath)\n  });\n\n  if (!ast) {\n    throw new Error(`jest-snapshot: Failed to parse ${sourceFilePath}`);\n  }\n\n  traverseAst(snapshots, ast, snapshotMatcherNames); // substitute in the snapshots in reverse order, so slice calculations aren't thrown off.\n\n  const sourceFileWithSnapshots = snapshots.reduceRight((sourceSoFar, nextSnapshot) => {\n    if (!nextSnapshot.node || typeof nextSnapshot.node.start !== 'number' || typeof nextSnapshot.node.end !== 'number') {\n      throw new Error('Jest: no snapshot insert location found');\n    }\n\n    return sourceSoFar.slice(0, nextSnapshot.node.start) + generate(nextSnapshot.node, {\n      retainLines: true\n    }).code.trim() + sourceSoFar.slice(nextSnapshot.node.end);\n  }, sourceFile);\n  const newSourceFile = prettier ? runPrettier(prettier, sourceFilePath, sourceFileWithSnapshots, snapshotMatcherNames) : sourceFileWithSnapshots;\n\n  if (newSourceFile !== sourceFile) {\n    jestWriteFile(sourceFilePath, newSourceFile);\n  }\n};\n\nconst groupSnapshotsBy = createKey => snapshots => snapshots.reduce((object, inlineSnapshot) => {\n  const key = createKey(inlineSnapshot);\n  return { ...object,\n    [key]: (object[key] || []).concat(inlineSnapshot)\n  };\n}, {});\n\nconst groupSnapshotsByFrame = groupSnapshotsBy(_ref => {\n  let {\n    frame: {\n      line,\n      column\n    }\n  } = _ref;\n  return typeof line === 'number' && typeof column === 'number' ? `${line}:${column - 1}` : '';\n});\nconst groupSnapshotsByFile = groupSnapshotsBy(_ref2 => {\n  let {\n    frame: {\n      file\n    }\n  } = _ref2;\n  return file;\n});\n\nconst indent = (snapshot, numIndents, indentation) => {\n  const lines = snapshot.split('\\n'); // Prevent re-indentation of inline snapshots.\n\n  if (lines.length >= 2 && lines[1].startsWith(indentation.repeat(numIndents + 1))) {\n    return snapshot;\n  }\n\n  return lines.map((line, index) => {\n    if (index === 0) {\n      // First line is either a 1-line snapshot or a blank line.\n      return line;\n    } else if (index !== lines.length - 1) {\n      // Do not indent empty lines.\n      if (line === '') {\n        return line;\n      } // Not last line, indent one level deeper than expect call.\n\n\n      return indentation.repeat(numIndents + 1) + line;\n    } else {\n      // The last line should be placed on the same level as the expect call.\n      return indentation.repeat(numIndents) + line;\n    }\n  }).join('\\n');\n};\n\nconst resolveAst = fileOrProgram => {\n  // Flow uses a 'Program' parent node, babel expects a 'File'.\n  let ast = fileOrProgram;\n\n  if (ast.type !== 'File') {\n    ast = file(ast, ast.comments, ast.tokens);\n    delete ast.program.comments;\n  }\n\n  return ast;\n};\n\nconst traverseAst = (snapshots, fileOrProgram, snapshotMatcherNames) => {\n  const ast = resolveAst(fileOrProgram);\n  const groupedSnapshots = groupSnapshotsByFrame(snapshots);\n  const remainingSnapshots = new Set(snapshots.map(_ref3 => {\n    let {\n      snapshot\n    } = _ref3;\n    return snapshot;\n  }));\n  babelTraverse(ast, {\n    CallExpression(_ref4) {\n      let {\n        node\n      } = _ref4;\n      const {\n        arguments: args,\n        callee\n      } = node;\n\n      if (callee.type !== 'MemberExpression' || callee.property.type !== 'Identifier' || callee.property.loc == null) {\n        return;\n      }\n\n      const {\n        line,\n        column\n      } = callee.property.loc.start;\n      const snapshotsForFrame = groupedSnapshots[`${line}:${column}`];\n\n      if (!snapshotsForFrame) {\n        return;\n      }\n\n      if (snapshotsForFrame.length > 1) {\n        throw new Error('Jest: Multiple inline snapshots for the same call are not supported.');\n      }\n\n      snapshotMatcherNames.push(callee.property.name);\n      const snapshotIndex = args.findIndex(_ref5 => {\n        let {\n          type\n        } = _ref5;\n        return type === 'TemplateLiteral';\n      });\n      const values = snapshotsForFrame.map(inlineSnapshot => {\n        inlineSnapshot.node = node;\n        const {\n          snapshot\n        } = inlineSnapshot;\n        remainingSnapshots.delete(snapshot);\n        return templateLiteral([templateElement({\n          raw: (0, _utils.escapeBacktickString)(snapshot)\n        })], []);\n      });\n      const replacementNode = values[0];\n\n      if (snapshotIndex > -1) {\n        args[snapshotIndex] = replacementNode;\n      } else {\n        args.push(replacementNode);\n      }\n    }\n\n  });\n\n  if (remainingSnapshots.size) {\n    throw new Error(\"Jest: Couldn't locate all inline snapshots.\");\n  }\n};\n\nconst runPrettier = (prettier, sourceFilePath, sourceFileWithSnapshots, snapshotMatcherNames) => {\n  // Resolve project configuration.\n  // For older versions of Prettier, do not load configuration.\n  const config = prettier.resolveConfig ? prettier.resolveConfig.sync(sourceFilePath, {\n    editorconfig: true\n  }) : null; // Detect the parser for the test file.\n  // For older versions of Prettier, fallback to a simple parser detection.\n  // @ts-expect-error - `inferredParser` is `string`\n\n  const inferredParser = prettier.getFileInfo ? prettier.getFileInfo.sync(sourceFilePath).inferredParser : config && typeof config.parser === 'string' && config.parser || simpleDetectParser(sourceFilePath);\n\n  if (!inferredParser) {\n    throw new Error(`Could not infer Prettier parser for file ${sourceFilePath}`);\n  } // Snapshots have now been inserted. Run prettier to make sure that the code is\n  // formatted, except snapshot indentation. Snapshots cannot be formatted until\n  // after the initial format because we don't know where the call expression\n  // will be placed (specifically its indentation), so we have to do two\n  // prettier.format calls back-to-back.\n\n\n  return prettier.format(prettier.format(sourceFileWithSnapshots, { ...config,\n    filepath: sourceFilePath\n  }), { ...config,\n    filepath: sourceFilePath,\n    parser: createFormattingParser(snapshotMatcherNames, inferredParser)\n  });\n}; // This parser formats snapshots to the correct indentation.\n\n\nconst createFormattingParser = (snapshotMatcherNames, inferredParser) => (text, parsers, options) => {\n  // Workaround for https://github.com/prettier/prettier/issues/3150\n  options.parser = inferredParser;\n  const ast = resolveAst(parsers[inferredParser](text, options));\n  babelTraverse(ast, {\n    CallExpression(_ref6) {\n      let {\n        node: {\n          arguments: args,\n          callee\n        },\n        parent\n      } = _ref6;\n\n      var _options$tabWidth, _options$tabWidth2;\n\n      if (callee.type !== 'MemberExpression' || callee.property.type !== 'Identifier' || !snapshotMatcherNames.includes(callee.property.name) || !callee.loc || callee.computed) {\n        return;\n      }\n\n      let snapshotIndex;\n      let snapshot;\n\n      for (let i = 0; i < args.length; i++) {\n        const node = args[i];\n\n        if (node.type === 'TemplateLiteral') {\n          snapshotIndex = i;\n          snapshot = node.quasis[0].value.raw;\n        }\n      }\n\n      if (snapshot === undefined || snapshotIndex === undefined) {\n        return;\n      }\n\n      const startColumn = (0, _types.isAwaitExpression)(parent) && parent.loc ? parent.loc.start.column : callee.loc.start.column;\n      const useSpaces = !options.useTabs;\n      snapshot = indent(snapshot, Math.ceil(useSpaces ? startColumn / ((_options$tabWidth = options.tabWidth) !== null && _options$tabWidth !== void 0 ? _options$tabWidth : 1) // Each tab is 2 characters.\n      : startColumn / 2), useSpaces ? ' '.repeat((_options$tabWidth2 = options.tabWidth) !== null && _options$tabWidth2 !== void 0 ? _options$tabWidth2 : 1) : '\\t');\n      const replacementNode = templateLiteral([templateElement({\n        raw: snapshot\n      })], []);\n      args[snapshotIndex] = replacementNode;\n    }\n\n  });\n  return ast;\n};\n\nconst simpleDetectParser = filePath => {\n  const extname = path.extname(filePath);\n\n  if (/\\.tsx?$/.test(extname)) {\n    return 'typescript';\n  }\n\n  return 'babel';\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","saveInlineSnapshots","path","_interopRequireWildcard","require","_types","fs","_semver","_interopRequireDefault","_utils","obj","__esModule","default","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","Symbol","globalThis","jestWriteFile","for","writeFileSync","jestReadFile","readFileSync","babelTraverse","resolve","generate","file","templateElement","templateLiteral","parseSync","snapshots","prettierPath","prettier","snapshotsByFile","groupSnapshotsByFile","sourceFilePath","keys","saveSnapshotsForFile","gte","version","undefined","sourceFile","presets","plugins","test","push","isTSX","endsWith","snapshotMatcherNames","ast","filename","root","dirname","Error","traverseAst","sourceFileWithSnapshots","reduceRight","sourceSoFar","nextSnapshot","node","start","end","slice","retainLines","code","trim","newSourceFile","runPrettier","groupSnapshotsBy","createKey","reduce","object","inlineSnapshot","concat","groupSnapshotsByFrame","frame","line","column","indent","snapshot","numIndents","indentation","lines","split","length","startsWith","repeat","map","index","join","resolveAst","fileOrProgram","type","comments","tokens","program","groupedSnapshots","remainingSnapshots","Set","CallExpression","arguments","args","callee","property","loc","snapshotsForFrame","name","snapshotIndex","findIndex","values","delete","raw","escapeBacktickString","replacementNode","size","config","resolveConfig","sync","editorconfig","inferredParser","getFileInfo","parser","simpleDetectParser","format","filepath","createFormattingParser","text","parsers","options","parent","_options$tabWidth","_options$tabWidth2","includes","computed","i","quasis","startColumn","isAwaitExpression","useSpaces","useTabs","Math","ceil","tabWidth","filePath","extname"],"sources":["/Users/wonjaelee/Desktop/final/node_modules/jest-snapshot/build/InlineSnapshots.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.saveInlineSnapshots = saveInlineSnapshots;\n\nvar path = _interopRequireWildcard(require('path'));\n\nvar _types = require('@babel/types');\n\nvar fs = _interopRequireWildcard(require('graceful-fs'));\n\nvar _semver = _interopRequireDefault(require('semver'));\n\nvar _utils = require('./utils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\nvar Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;\nvar Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;\nvar jestWriteFile =\n  globalThis[Symbol.for('jest-native-write-file')] || fs.writeFileSync;\nvar Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;\nvar jestReadFile =\n  globalThis[Symbol.for('jest-native-read-file')] || fs.readFileSync;\n\n// prettier-ignore\nconst babelTraverse = // @ts-expect-error requireOutside Babel transform\nrequire(require.resolve('@babel/traverse', {\n  [(globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol).for('jest-resolve-outside-vm-option')]: true\n})).default; // prettier-ignore\n\nconst generate = // @ts-expect-error requireOutside Babel transform\n  require(require.resolve('@babel/generator', {\n    [(globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol).for(\n      'jest-resolve-outside-vm-option'\n    )]: true\n  })).default; // @ts-expect-error requireOutside Babel transform\n\nconst {file, templateElement, templateLiteral} = require(require.resolve(\n  '@babel/types',\n  {\n    [(globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol).for(\n      'jest-resolve-outside-vm-option'\n    )]: true\n  }\n)); // @ts-expect-error requireOutside Babel transform\n\nconst {parseSync} = require(require.resolve('@babel/core', {\n  [(globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol).for(\n    'jest-resolve-outside-vm-option'\n  )]: true\n}));\n\nfunction saveInlineSnapshots(snapshots, prettierPath) {\n  let prettier = null;\n\n  if (prettierPath) {\n    try {\n      // @ts-expect-error requireOutside Babel transform\n      prettier = require(require.resolve(prettierPath, {\n        [(globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol).for(\n          'jest-resolve-outside-vm-option'\n        )]: true\n      }));\n    } catch {\n      // Continue even if prettier is not installed.\n    }\n  }\n\n  const snapshotsByFile = groupSnapshotsByFile(snapshots);\n\n  for (const sourceFilePath of Object.keys(snapshotsByFile)) {\n    saveSnapshotsForFile(\n      snapshotsByFile[sourceFilePath],\n      sourceFilePath,\n      prettier && _semver.default.gte(prettier.version, '1.5.0')\n        ? prettier\n        : undefined\n    );\n  }\n}\n\nconst saveSnapshotsForFile = (snapshots, sourceFilePath, prettier) => {\n  const sourceFile = jestReadFile(sourceFilePath, 'utf8'); // TypeScript projects may not have a babel config; make sure they can be parsed anyway.\n\n  const presets = [require.resolve('babel-preset-current-node-syntax')];\n  const plugins = [];\n\n  if (/\\.tsx?$/.test(sourceFilePath)) {\n    plugins.push([\n      require.resolve('@babel/plugin-syntax-typescript'),\n      {\n        isTSX: sourceFilePath.endsWith('x')\n      }, // unique name to make sure Babel does not complain about a possible duplicate plugin.\n      'TypeScript syntax plugin added by Jest snapshot'\n    ]);\n  } // Record the matcher names seen during traversal and pass them down one\n  // by one to formatting parser.\n\n  const snapshotMatcherNames = [];\n  const ast = parseSync(sourceFile, {\n    filename: sourceFilePath,\n    plugins,\n    presets,\n    root: path.dirname(sourceFilePath)\n  });\n\n  if (!ast) {\n    throw new Error(`jest-snapshot: Failed to parse ${sourceFilePath}`);\n  }\n\n  traverseAst(snapshots, ast, snapshotMatcherNames); // substitute in the snapshots in reverse order, so slice calculations aren't thrown off.\n\n  const sourceFileWithSnapshots = snapshots.reduceRight(\n    (sourceSoFar, nextSnapshot) => {\n      if (\n        !nextSnapshot.node ||\n        typeof nextSnapshot.node.start !== 'number' ||\n        typeof nextSnapshot.node.end !== 'number'\n      ) {\n        throw new Error('Jest: no snapshot insert location found');\n      }\n\n      return (\n        sourceSoFar.slice(0, nextSnapshot.node.start) +\n        generate(nextSnapshot.node, {\n          retainLines: true\n        }).code.trim() +\n        sourceSoFar.slice(nextSnapshot.node.end)\n      );\n    },\n    sourceFile\n  );\n  const newSourceFile = prettier\n    ? runPrettier(\n        prettier,\n        sourceFilePath,\n        sourceFileWithSnapshots,\n        snapshotMatcherNames\n      )\n    : sourceFileWithSnapshots;\n\n  if (newSourceFile !== sourceFile) {\n    jestWriteFile(sourceFilePath, newSourceFile);\n  }\n};\n\nconst groupSnapshotsBy = createKey => snapshots =>\n  snapshots.reduce((object, inlineSnapshot) => {\n    const key = createKey(inlineSnapshot);\n    return {...object, [key]: (object[key] || []).concat(inlineSnapshot)};\n  }, {});\n\nconst groupSnapshotsByFrame = groupSnapshotsBy(({frame: {line, column}}) =>\n  typeof line === 'number' && typeof column === 'number'\n    ? `${line}:${column - 1}`\n    : ''\n);\nconst groupSnapshotsByFile = groupSnapshotsBy(({frame: {file}}) => file);\n\nconst indent = (snapshot, numIndents, indentation) => {\n  const lines = snapshot.split('\\n'); // Prevent re-indentation of inline snapshots.\n\n  if (\n    lines.length >= 2 &&\n    lines[1].startsWith(indentation.repeat(numIndents + 1))\n  ) {\n    return snapshot;\n  }\n\n  return lines\n    .map((line, index) => {\n      if (index === 0) {\n        // First line is either a 1-line snapshot or a blank line.\n        return line;\n      } else if (index !== lines.length - 1) {\n        // Do not indent empty lines.\n        if (line === '') {\n          return line;\n        } // Not last line, indent one level deeper than expect call.\n\n        return indentation.repeat(numIndents + 1) + line;\n      } else {\n        // The last line should be placed on the same level as the expect call.\n        return indentation.repeat(numIndents) + line;\n      }\n    })\n    .join('\\n');\n};\n\nconst resolveAst = fileOrProgram => {\n  // Flow uses a 'Program' parent node, babel expects a 'File'.\n  let ast = fileOrProgram;\n\n  if (ast.type !== 'File') {\n    ast = file(ast, ast.comments, ast.tokens);\n    delete ast.program.comments;\n  }\n\n  return ast;\n};\n\nconst traverseAst = (snapshots, fileOrProgram, snapshotMatcherNames) => {\n  const ast = resolveAst(fileOrProgram);\n  const groupedSnapshots = groupSnapshotsByFrame(snapshots);\n  const remainingSnapshots = new Set(snapshots.map(({snapshot}) => snapshot));\n  babelTraverse(ast, {\n    CallExpression({node}) {\n      const {arguments: args, callee} = node;\n\n      if (\n        callee.type !== 'MemberExpression' ||\n        callee.property.type !== 'Identifier' ||\n        callee.property.loc == null\n      ) {\n        return;\n      }\n\n      const {line, column} = callee.property.loc.start;\n      const snapshotsForFrame = groupedSnapshots[`${line}:${column}`];\n\n      if (!snapshotsForFrame) {\n        return;\n      }\n\n      if (snapshotsForFrame.length > 1) {\n        throw new Error(\n          'Jest: Multiple inline snapshots for the same call are not supported.'\n        );\n      }\n\n      snapshotMatcherNames.push(callee.property.name);\n      const snapshotIndex = args.findIndex(\n        ({type}) => type === 'TemplateLiteral'\n      );\n      const values = snapshotsForFrame.map(inlineSnapshot => {\n        inlineSnapshot.node = node;\n        const {snapshot} = inlineSnapshot;\n        remainingSnapshots.delete(snapshot);\n        return templateLiteral(\n          [\n            templateElement({\n              raw: (0, _utils.escapeBacktickString)(snapshot)\n            })\n          ],\n          []\n        );\n      });\n      const replacementNode = values[0];\n\n      if (snapshotIndex > -1) {\n        args[snapshotIndex] = replacementNode;\n      } else {\n        args.push(replacementNode);\n      }\n    }\n  });\n\n  if (remainingSnapshots.size) {\n    throw new Error(\"Jest: Couldn't locate all inline snapshots.\");\n  }\n};\n\nconst runPrettier = (\n  prettier,\n  sourceFilePath,\n  sourceFileWithSnapshots,\n  snapshotMatcherNames\n) => {\n  // Resolve project configuration.\n  // For older versions of Prettier, do not load configuration.\n  const config = prettier.resolveConfig\n    ? prettier.resolveConfig.sync(sourceFilePath, {\n        editorconfig: true\n      })\n    : null; // Detect the parser for the test file.\n  // For older versions of Prettier, fallback to a simple parser detection.\n  // @ts-expect-error - `inferredParser` is `string`\n\n  const inferredParser = prettier.getFileInfo\n    ? prettier.getFileInfo.sync(sourceFilePath).inferredParser\n    : (config && typeof config.parser === 'string' && config.parser) ||\n      simpleDetectParser(sourceFilePath);\n\n  if (!inferredParser) {\n    throw new Error(\n      `Could not infer Prettier parser for file ${sourceFilePath}`\n    );\n  } // Snapshots have now been inserted. Run prettier to make sure that the code is\n  // formatted, except snapshot indentation. Snapshots cannot be formatted until\n  // after the initial format because we don't know where the call expression\n  // will be placed (specifically its indentation), so we have to do two\n  // prettier.format calls back-to-back.\n\n  return prettier.format(\n    prettier.format(sourceFileWithSnapshots, {\n      ...config,\n      filepath: sourceFilePath\n    }),\n    {\n      ...config,\n      filepath: sourceFilePath,\n      parser: createFormattingParser(snapshotMatcherNames, inferredParser)\n    }\n  );\n}; // This parser formats snapshots to the correct indentation.\n\nconst createFormattingParser =\n  (snapshotMatcherNames, inferredParser) => (text, parsers, options) => {\n    // Workaround for https://github.com/prettier/prettier/issues/3150\n    options.parser = inferredParser;\n    const ast = resolveAst(parsers[inferredParser](text, options));\n    babelTraverse(ast, {\n      CallExpression({node: {arguments: args, callee}, parent}) {\n        var _options$tabWidth, _options$tabWidth2;\n\n        if (\n          callee.type !== 'MemberExpression' ||\n          callee.property.type !== 'Identifier' ||\n          !snapshotMatcherNames.includes(callee.property.name) ||\n          !callee.loc ||\n          callee.computed\n        ) {\n          return;\n        }\n\n        let snapshotIndex;\n        let snapshot;\n\n        for (let i = 0; i < args.length; i++) {\n          const node = args[i];\n\n          if (node.type === 'TemplateLiteral') {\n            snapshotIndex = i;\n            snapshot = node.quasis[0].value.raw;\n          }\n        }\n\n        if (snapshot === undefined || snapshotIndex === undefined) {\n          return;\n        }\n\n        const startColumn =\n          (0, _types.isAwaitExpression)(parent) && parent.loc\n            ? parent.loc.start.column\n            : callee.loc.start.column;\n        const useSpaces = !options.useTabs;\n        snapshot = indent(\n          snapshot,\n          Math.ceil(\n            useSpaces\n              ? startColumn /\n                  ((_options$tabWidth = options.tabWidth) !== null &&\n                  _options$tabWidth !== void 0\n                    ? _options$tabWidth\n                    : 1) // Each tab is 2 characters.\n              : startColumn / 2\n          ),\n          useSpaces\n            ? ' '.repeat(\n                (_options$tabWidth2 = options.tabWidth) !== null &&\n                  _options$tabWidth2 !== void 0\n                  ? _options$tabWidth2\n                  : 1\n              )\n            : '\\t'\n        );\n        const replacementNode = templateLiteral(\n          [\n            templateElement({\n              raw: snapshot\n            })\n          ],\n          []\n        );\n        args[snapshotIndex] = replacementNode;\n      }\n    });\n    return ast;\n  };\n\nconst simpleDetectParser = filePath => {\n  const extname = path.extname(filePath);\n\n  if (/\\.tsx?$/.test(extname)) {\n    return 'typescript';\n  }\n\n  return 'babel';\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}