{"ast":null,"code":"const CovLine = require('./line');\n\nconst {\n  sliceRange\n} = require('./range');\n\nconst {\n  originalPositionFor,\n  generatedPositionFor,\n  GREATEST_LOWER_BOUND,\n  LEAST_UPPER_BOUND\n} = require('@jridgewell/trace-mapping');\n\nmodule.exports = class CovSource {\n  constructor(sourceRaw, wrapperLength) {\n    sourceRaw = sourceRaw ? sourceRaw.trimEnd() : '';\n    this.lines = [];\n    this.eof = sourceRaw.length;\n    this.shebangLength = getShebangLength(sourceRaw);\n    this.wrapperLength = wrapperLength - this.shebangLength;\n\n    this._buildLines(sourceRaw);\n  }\n\n  _buildLines(source) {\n    let position = 0;\n    let ignoreCount = 0;\n    let ignoreAll = false;\n\n    for (const [i, lineStr] of source.split(/(?<=\\r?\\n)/u).entries()) {\n      const line = new CovLine(i + 1, position, lineStr);\n\n      if (ignoreCount > 0) {\n        line.ignore = true;\n        ignoreCount--;\n      } else if (ignoreAll) {\n        line.ignore = true;\n      }\n\n      this.lines.push(line);\n      position += lineStr.length;\n\n      const ignoreToken = this._parseIgnore(lineStr);\n\n      if (!ignoreToken) continue;\n      line.ignore = true;\n\n      if (ignoreToken.count !== undefined) {\n        ignoreCount = ignoreToken.count;\n      }\n\n      if (ignoreToken.start || ignoreToken.stop) {\n        ignoreAll = ignoreToken.start;\n        ignoreCount = 0;\n      }\n    }\n  }\n  /**\n   * Parses for comments:\n   *    c8 ignore next\n   *    c8 ignore next 3\n   *    c8 ignore start\n   *    c8 ignore stop\n   * @param {string} lineStr\n   * @return {{count?: number, start?: boolean, stop?: boolean}|undefined}\n   */\n\n\n  _parseIgnore(lineStr) {\n    const testIgnoreNextLines = lineStr.match(/^\\W*\\/\\* c8 ignore next (?<count>[0-9]+) *\\*\\/\\W*$/);\n\n    if (testIgnoreNextLines) {\n      return {\n        count: Number(testIgnoreNextLines.groups.count)\n      };\n    } // Check if comment is on its own line.\n\n\n    if (lineStr.match(/^\\W*\\/\\* c8 ignore next *\\*\\/\\W*$/)) {\n      return {\n        count: 1\n      };\n    }\n\n    if (lineStr.match(/\\/\\* c8 ignore next \\*\\//)) {\n      // Won't ignore successive lines, but the current line will be ignored.\n      return {\n        count: 0\n      };\n    }\n\n    const testIgnoreStartStop = lineStr.match(/\\/\\* c8 ignore (?<mode>start|stop) *\\*\\//);\n\n    if (testIgnoreStartStop) {\n      if (testIgnoreStartStop.groups.mode === 'start') return {\n        start: true\n      };\n      if (testIgnoreStartStop.groups.mode === 'stop') return {\n        stop: true\n      };\n    }\n  } // given a start column and end column in absolute offsets within\n  // a source file (0 - EOF), returns the relative line column positions.\n\n\n  offsetToOriginalRelative(sourceMap, startCol, endCol) {\n    const lines = sliceRange(this.lines, startCol, endCol, true);\n    if (!lines.length) return {};\n    const start = originalPositionTryBoth(sourceMap, lines[0].line, Math.max(0, startCol - lines[0].startCol));\n\n    if (!(start && start.source)) {\n      return {};\n    }\n\n    let end = originalEndPositionFor(sourceMap, lines[lines.length - 1].line, endCol - lines[lines.length - 1].startCol);\n\n    if (!(end && end.source)) {\n      return {};\n    }\n\n    if (start.source !== end.source) {\n      return {};\n    }\n\n    if (start.line === end.line && start.column === end.column) {\n      end = originalPositionFor(sourceMap, {\n        line: lines[lines.length - 1].line,\n        column: endCol - lines[lines.length - 1].startCol,\n        bias: LEAST_UPPER_BOUND\n      });\n      end.column -= 1;\n    }\n\n    return {\n      source: start.source,\n      startLine: start.line,\n      relStartCol: start.column,\n      endLine: end.line,\n      relEndCol: end.column\n    };\n  }\n\n  relativeToOffset(line, relCol) {\n    line = Math.max(line, 1);\n    if (this.lines[line - 1] === undefined) return this.eof;\n    return Math.min(this.lines[line - 1].startCol + relCol, this.lines[line - 1].endCol);\n  }\n\n}; // this implementation is pulled over from istanbul-lib-sourcemap:\n// https://github.com/istanbuljs/istanbuljs/blob/master/packages/istanbul-lib-source-maps/lib/get-mapping.js\n//\n\n/**\n * AST ranges are inclusive for start positions and exclusive for end positions.\n * Source maps are also logically ranges over text, though interacting with\n * them is generally achieved by working with explicit positions.\n *\n * When finding the _end_ location of an AST item, the range behavior is\n * important because what we're asking for is the _end_ of whatever range\n * corresponds to the end location we seek.\n *\n * This boils down to the following steps, conceptually, though the source-map\n * library doesn't expose primitives to do this nicely:\n *\n * 1. Find the range on the generated file that ends at, or exclusively\n *    contains the end position of the AST node.\n * 2. Find the range on the original file that corresponds to\n *    that generated range.\n * 3. Find the _end_ location of that original range.\n */\n\nfunction originalEndPositionFor(sourceMap, line, column) {\n  // Given the generated location, find the original location of the mapping\n  // that corresponds to a range on the generated file that overlaps the\n  // generated file end location. Note however that this position on its\n  // own is not useful because it is the position of the _start_ of the range\n  // on the original file, and we want the _end_ of the range.\n  const beforeEndMapping = originalPositionTryBoth(sourceMap, line, Math.max(column - 1, 1));\n\n  if (beforeEndMapping.source === null) {\n    return null;\n  } // Convert that original position back to a generated one, with a bump\n  // to the right, and a rightward bias. Since 'generatedPositionFor' searches\n  // for mappings in the original-order sorted list, this will find the\n  // mapping that corresponds to the one immediately after the\n  // beforeEndMapping mapping.\n\n\n  const afterEndMapping = generatedPositionFor(sourceMap, {\n    source: beforeEndMapping.source,\n    line: beforeEndMapping.line,\n    column: beforeEndMapping.column + 1,\n    bias: LEAST_UPPER_BOUND\n  });\n\n  if ( // If this is null, it means that we've hit the end of the file,\n  // so we can use Infinity as the end column.\n  afterEndMapping.line === null || // If these don't match, it means that the call to\n  // 'generatedPositionFor' didn't find any other original mappings on\n  // the line we gave, so consider the binding to extend to infinity.\n  originalPositionFor(sourceMap, afterEndMapping).line !== beforeEndMapping.line) {\n    return {\n      source: beforeEndMapping.source,\n      line: beforeEndMapping.line,\n      column: Infinity\n    };\n  } // Convert the end mapping into the real original position.\n\n\n  return originalPositionFor(sourceMap, afterEndMapping);\n}\n\nfunction originalPositionTryBoth(sourceMap, line, column) {\n  let original = originalPositionFor(sourceMap, {\n    line,\n    column,\n    bias: GREATEST_LOWER_BOUND\n  });\n\n  if (original.line === null) {\n    original = originalPositionFor(sourceMap, {\n      line,\n      column,\n      bias: LEAST_UPPER_BOUND\n    });\n  } // The source maps generated by https://github.com/istanbuljs/istanbuljs\n  // (using @babel/core 7.7.5) have behavior, such that a mapping\n  // mid-way through a line maps to an earlier line than a mapping\n  // at position 0. Using the line at positon 0 seems to provide better reports:\n  //\n  //     if (true) {\n  //        cov_y5divc6zu().b[1][0]++;\n  //        cov_y5divc6zu().s[3]++;\n  //        console.info('reachable');\n  //     }  else { ... }\n  //  ^  ^\n  // l5  l3\n\n\n  const min = originalPositionFor(sourceMap, {\n    line,\n    column: 0,\n    bias: GREATEST_LOWER_BOUND\n  });\n\n  if (min.line > original.line) {\n    original = min;\n  }\n\n  return original;\n} // Not required since Node 12, see: https://github.com/nodejs/node/pull/27375\n\n\nconst isPreNode12 = /^v1[0-1]\\./u.test(process.version);\n\nfunction getShebangLength(source) {\n  if (isPreNode12 && source.indexOf('#!') === 0) {\n    const match = source.match(/(?<shebang>#!.*)/);\n\n    if (match) {\n      return match.groups.shebang.length;\n    }\n  } else {\n    return 0;\n  }\n}","map":{"version":3,"names":["CovLine","require","sliceRange","originalPositionFor","generatedPositionFor","GREATEST_LOWER_BOUND","LEAST_UPPER_BOUND","module","exports","CovSource","constructor","sourceRaw","wrapperLength","trimEnd","lines","eof","length","shebangLength","getShebangLength","_buildLines","source","position","ignoreCount","ignoreAll","i","lineStr","split","entries","line","ignore","push","ignoreToken","_parseIgnore","count","undefined","start","stop","testIgnoreNextLines","match","Number","groups","testIgnoreStartStop","mode","offsetToOriginalRelative","sourceMap","startCol","endCol","originalPositionTryBoth","Math","max","end","originalEndPositionFor","column","bias","startLine","relStartCol","endLine","relEndCol","relativeToOffset","relCol","min","beforeEndMapping","afterEndMapping","Infinity","original","isPreNode12","test","process","version","indexOf","shebang"],"sources":["/Users/wonjaelee/Desktop/final/node_modules/v8-to-istanbul/lib/source.js"],"sourcesContent":["const CovLine = require('./line')\nconst { sliceRange } = require('./range')\nconst { originalPositionFor, generatedPositionFor, GREATEST_LOWER_BOUND, LEAST_UPPER_BOUND } = require('@jridgewell/trace-mapping')\n\nmodule.exports = class CovSource {\n  constructor (sourceRaw, wrapperLength) {\n    sourceRaw = sourceRaw ? sourceRaw.trimEnd() : ''\n    this.lines = []\n    this.eof = sourceRaw.length\n    this.shebangLength = getShebangLength(sourceRaw)\n    this.wrapperLength = wrapperLength - this.shebangLength\n    this._buildLines(sourceRaw)\n  }\n\n  _buildLines (source) {\n    let position = 0\n    let ignoreCount = 0\n    let ignoreAll = false\n    for (const [i, lineStr] of source.split(/(?<=\\r?\\n)/u).entries()) {\n      const line = new CovLine(i + 1, position, lineStr)\n      if (ignoreCount > 0) {\n        line.ignore = true\n        ignoreCount--\n      } else if (ignoreAll) {\n        line.ignore = true\n      }\n      this.lines.push(line)\n      position += lineStr.length\n\n      const ignoreToken = this._parseIgnore(lineStr)\n      if (!ignoreToken) continue\n\n      line.ignore = true\n      if (ignoreToken.count !== undefined) {\n        ignoreCount = ignoreToken.count\n      }\n      if (ignoreToken.start || ignoreToken.stop) {\n        ignoreAll = ignoreToken.start\n        ignoreCount = 0\n      }\n    }\n  }\n\n  /**\n   * Parses for comments:\n   *    c8 ignore next\n   *    c8 ignore next 3\n   *    c8 ignore start\n   *    c8 ignore stop\n   * @param {string} lineStr\n   * @return {{count?: number, start?: boolean, stop?: boolean}|undefined}\n   */\n  _parseIgnore (lineStr) {\n    const testIgnoreNextLines = lineStr.match(/^\\W*\\/\\* c8 ignore next (?<count>[0-9]+) *\\*\\/\\W*$/)\n    if (testIgnoreNextLines) {\n      return { count: Number(testIgnoreNextLines.groups.count) }\n    }\n\n    // Check if comment is on its own line.\n    if (lineStr.match(/^\\W*\\/\\* c8 ignore next *\\*\\/\\W*$/)) {\n      return { count: 1 }\n    }\n\n    if (lineStr.match(/\\/\\* c8 ignore next \\*\\//)) {\n      // Won't ignore successive lines, but the current line will be ignored.\n      return { count: 0 }\n    }\n\n    const testIgnoreStartStop = lineStr.match(/\\/\\* c8 ignore (?<mode>start|stop) *\\*\\//)\n    if (testIgnoreStartStop) {\n      if (testIgnoreStartStop.groups.mode === 'start') return { start: true }\n      if (testIgnoreStartStop.groups.mode === 'stop') return { stop: true }\n    }\n  }\n\n  // given a start column and end column in absolute offsets within\n  // a source file (0 - EOF), returns the relative line column positions.\n  offsetToOriginalRelative (sourceMap, startCol, endCol) {\n    const lines = sliceRange(this.lines, startCol, endCol, true)\n    if (!lines.length) return {}\n\n    const start = originalPositionTryBoth(\n      sourceMap,\n      lines[0].line,\n      Math.max(0, startCol - lines[0].startCol)\n    )\n    if (!(start && start.source)) {\n      return {}\n    }\n\n    let end = originalEndPositionFor(\n      sourceMap,\n      lines[lines.length - 1].line,\n      endCol - lines[lines.length - 1].startCol\n    )\n    if (!(end && end.source)) {\n      return {}\n    }\n\n    if (start.source !== end.source) {\n      return {}\n    }\n\n    if (start.line === end.line && start.column === end.column) {\n      end = originalPositionFor(sourceMap, {\n        line: lines[lines.length - 1].line,\n        column: endCol - lines[lines.length - 1].startCol,\n        bias: LEAST_UPPER_BOUND\n      })\n      end.column -= 1\n    }\n\n    return {\n      source: start.source,\n      startLine: start.line,\n      relStartCol: start.column,\n      endLine: end.line,\n      relEndCol: end.column\n    }\n  }\n\n  relativeToOffset (line, relCol) {\n    line = Math.max(line, 1)\n    if (this.lines[line - 1] === undefined) return this.eof\n    return Math.min(this.lines[line - 1].startCol + relCol, this.lines[line - 1].endCol)\n  }\n}\n\n// this implementation is pulled over from istanbul-lib-sourcemap:\n// https://github.com/istanbuljs/istanbuljs/blob/master/packages/istanbul-lib-source-maps/lib/get-mapping.js\n//\n/**\n * AST ranges are inclusive for start positions and exclusive for end positions.\n * Source maps are also logically ranges over text, though interacting with\n * them is generally achieved by working with explicit positions.\n *\n * When finding the _end_ location of an AST item, the range behavior is\n * important because what we're asking for is the _end_ of whatever range\n * corresponds to the end location we seek.\n *\n * This boils down to the following steps, conceptually, though the source-map\n * library doesn't expose primitives to do this nicely:\n *\n * 1. Find the range on the generated file that ends at, or exclusively\n *    contains the end position of the AST node.\n * 2. Find the range on the original file that corresponds to\n *    that generated range.\n * 3. Find the _end_ location of that original range.\n */\nfunction originalEndPositionFor (sourceMap, line, column) {\n  // Given the generated location, find the original location of the mapping\n  // that corresponds to a range on the generated file that overlaps the\n  // generated file end location. Note however that this position on its\n  // own is not useful because it is the position of the _start_ of the range\n  // on the original file, and we want the _end_ of the range.\n  const beforeEndMapping = originalPositionTryBoth(\n    sourceMap,\n    line,\n    Math.max(column - 1, 1)\n  )\n\n  if (beforeEndMapping.source === null) {\n    return null\n  }\n\n  // Convert that original position back to a generated one, with a bump\n  // to the right, and a rightward bias. Since 'generatedPositionFor' searches\n  // for mappings in the original-order sorted list, this will find the\n  // mapping that corresponds to the one immediately after the\n  // beforeEndMapping mapping.\n  const afterEndMapping = generatedPositionFor(sourceMap, {\n    source: beforeEndMapping.source,\n    line: beforeEndMapping.line,\n    column: beforeEndMapping.column + 1,\n    bias: LEAST_UPPER_BOUND\n  })\n  if (\n  // If this is null, it means that we've hit the end of the file,\n  // so we can use Infinity as the end column.\n    afterEndMapping.line === null ||\n      // If these don't match, it means that the call to\n      // 'generatedPositionFor' didn't find any other original mappings on\n      // the line we gave, so consider the binding to extend to infinity.\n      originalPositionFor(sourceMap, afterEndMapping).line !==\n          beforeEndMapping.line\n  ) {\n    return {\n      source: beforeEndMapping.source,\n      line: beforeEndMapping.line,\n      column: Infinity\n    }\n  }\n\n  // Convert the end mapping into the real original position.\n  return originalPositionFor(sourceMap, afterEndMapping)\n}\n\nfunction originalPositionTryBoth (sourceMap, line, column) {\n  let original = originalPositionFor(sourceMap, {\n    line,\n    column,\n    bias: GREATEST_LOWER_BOUND\n  })\n  if (original.line === null) {\n    original = originalPositionFor(sourceMap, {\n      line,\n      column,\n      bias: LEAST_UPPER_BOUND\n    })\n  }\n  // The source maps generated by https://github.com/istanbuljs/istanbuljs\n  // (using @babel/core 7.7.5) have behavior, such that a mapping\n  // mid-way through a line maps to an earlier line than a mapping\n  // at position 0. Using the line at positon 0 seems to provide better reports:\n  //\n  //     if (true) {\n  //        cov_y5divc6zu().b[1][0]++;\n  //        cov_y5divc6zu().s[3]++;\n  //        console.info('reachable');\n  //     }  else { ... }\n  //  ^  ^\n  // l5  l3\n  const min = originalPositionFor(sourceMap, {\n    line,\n    column: 0,\n    bias: GREATEST_LOWER_BOUND\n  })\n  if (min.line > original.line) {\n    original = min\n  }\n  return original\n}\n\n// Not required since Node 12, see: https://github.com/nodejs/node/pull/27375\nconst isPreNode12 = /^v1[0-1]\\./u.test(process.version)\nfunction getShebangLength (source) {\n  if (isPreNode12 && source.indexOf('#!') === 0) {\n    const match = source.match(/(?<shebang>#!.*)/)\n    if (match) {\n      return match.groups.shebang.length\n    }\n  } else {\n    return 0\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}