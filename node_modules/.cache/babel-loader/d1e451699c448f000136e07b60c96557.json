{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.separateMessageFromStack = exports.indentAllLines = exports.getTopFrame = exports.getStackTraceLines = exports.formatStackTrace = exports.formatResultsErrors = exports.formatPath = exports.formatExecError = void 0;\n\nvar path = _interopRequireWildcard(require('path'));\n\nvar _url = require('url');\n\nvar _codeFrame = require('@babel/code-frame');\n\nvar _chalk = _interopRequireDefault(require('chalk'));\n\nvar fs = _interopRequireWildcard(require('graceful-fs'));\n\nvar _micromatch = _interopRequireDefault(require('micromatch'));\n\nvar _slash = _interopRequireDefault(require('slash'));\n\nvar _stackUtils = _interopRequireDefault(require('stack-utils'));\n\nvar _prettyFormat = require('pretty-format');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nvar Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;\nvar Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;\nvar jestReadFile = globalThis[Symbol.for('jest-native-read-file')] || fs.readFileSync; // stack utils tries to create pretty stack by making paths relative.\n\nconst stackUtils = new _stackUtils.default({\n  cwd: 'something which does not exist'\n});\nlet nodeInternals = [];\n\ntry {\n  nodeInternals = _stackUtils.default.nodeInternals();\n} catch {// `StackUtils.nodeInternals()` fails in browsers. We don't need to remove\n  // node internals in the browser though, so no issue.\n}\n\nconst PATH_NODE_MODULES = `${path.sep}node_modules${path.sep}`;\nconst PATH_JEST_PACKAGES = `${path.sep}jest${path.sep}packages${path.sep}`; // filter for noisy stack trace lines\n\nconst JASMINE_IGNORE = /^\\s+at(?:(?:.jasmine-)|\\s+jasmine\\.buildExpectationResult)/;\nconst JEST_INTERNALS_IGNORE = /^\\s+at.*?jest(-.*?)?(\\/|\\\\)(build|node_modules|packages)(\\/|\\\\)/;\nconst ANONYMOUS_FN_IGNORE = /^\\s+at <anonymous>.*$/;\nconst ANONYMOUS_PROMISE_IGNORE = /^\\s+at (new )?Promise \\(<anonymous>\\).*$/;\nconst ANONYMOUS_GENERATOR_IGNORE = /^\\s+at Generator.next \\(<anonymous>\\).*$/;\nconst NATIVE_NEXT_IGNORE = /^\\s+at next \\(native\\).*$/;\nconst TITLE_INDENT = '  ';\nconst MESSAGE_INDENT = '    ';\nconst STACK_INDENT = '      ';\nconst ANCESTRY_SEPARATOR = ' \\u203A ';\n\nconst TITLE_BULLET = _chalk.default.bold('\\u25cf ');\n\nconst STACK_TRACE_COLOR = _chalk.default.dim;\nconst STACK_PATH_REGEXP = /\\s*at.*\\(?(:\\d*:\\d*|native)\\)?/;\nconst EXEC_ERROR_MESSAGE = 'Test suite failed to run';\nconst NOT_EMPTY_LINE_REGEXP = /^(?!$)/gm;\n\nconst indentAllLines = lines => lines.replace(NOT_EMPTY_LINE_REGEXP, MESSAGE_INDENT);\n\nexports.indentAllLines = indentAllLines;\n\nconst trim = string => (string || '').trim(); // Some errors contain not only line numbers in stack traces\n// e.g. SyntaxErrors can contain snippets of code, and we don't\n// want to trim those, because they may have pointers to the column/character\n// which will get misaligned.\n\n\nconst trimPaths = string => string.match(STACK_PATH_REGEXP) ? trim(string) : string;\n\nconst getRenderedCallsite = (fileContent, line, column) => {\n  let renderedCallsite = (0, _codeFrame.codeFrameColumns)(fileContent, {\n    start: {\n      column,\n      line\n    }\n  }, {\n    highlightCode: true\n  });\n  renderedCallsite = indentAllLines(renderedCallsite);\n  renderedCallsite = `\\n${renderedCallsite}\\n`;\n  return renderedCallsite;\n};\n\nconst blankStringRegexp = /^\\s*$/;\n\nfunction checkForCommonEnvironmentErrors(error) {\n  if (error.includes('ReferenceError: document is not defined') || error.includes('ReferenceError: window is not defined') || error.includes('ReferenceError: navigator is not defined')) {\n    return warnAboutWrongTestEnvironment(error, 'jsdom');\n  } else if (error.includes('.unref is not a function')) {\n    return warnAboutWrongTestEnvironment(error, 'node');\n  }\n\n  return error;\n}\n\nfunction warnAboutWrongTestEnvironment(error, env) {\n  return _chalk.default.bold.red(`The error below may be caused by using the wrong test environment, see ${_chalk.default.dim.underline('https://jestjs.io/docs/configuration#testenvironment-string')}.\\nConsider using the \"${env}\" test environment.\\n\\n`) + error;\n} // ExecError is an error thrown outside of the test suite (not inside an `it` or\n// `before/after each` hooks). If it's thrown, none of the tests in the file\n// are executed.\n\n\nconst formatExecError = (error, config, options, testPath, reuseMessage) => {\n  if (!error || typeof error === 'number') {\n    error = new Error(`Expected an Error, but \"${String(error)}\" was thrown`);\n    error.stack = '';\n  }\n\n  let message, stack;\n\n  if (typeof error === 'string' || !error) {\n    error || (error = 'EMPTY ERROR');\n    message = '';\n    stack = error;\n  } else {\n    message = error.message;\n    stack = typeof error.stack === 'string' ? error.stack : `thrown: ${(0, _prettyFormat.format)(error, {\n      maxDepth: 3\n    })}`;\n  }\n\n  const separated = separateMessageFromStack(stack || '');\n  stack = separated.stack;\n\n  if (separated.message.includes(trim(message))) {\n    // Often stack trace already contains the duplicate of the message\n    message = separated.message;\n  }\n\n  message = checkForCommonEnvironmentErrors(message);\n  message = indentAllLines(message);\n  stack = stack && !options.noStackTrace ? `\\n${formatStackTrace(stack, config, options, testPath)}` : '';\n\n  if (typeof stack !== 'string' || blankStringRegexp.test(message) && blankStringRegexp.test(stack)) {\n    // this can happen if an empty object is thrown.\n    message = `thrown: ${(0, _prettyFormat.format)(error, {\n      maxDepth: 3\n    })}`;\n  }\n\n  let messageToUse;\n\n  if (reuseMessage) {\n    messageToUse = ` ${message.trim()}`;\n  } else {\n    messageToUse = `${EXEC_ERROR_MESSAGE}\\n\\n${message}`;\n  }\n\n  return `${TITLE_INDENT + TITLE_BULLET + messageToUse + stack}\\n`;\n};\n\nexports.formatExecError = formatExecError;\n\nconst removeInternalStackEntries = (lines, options) => {\n  let pathCounter = 0;\n  return lines.filter(line => {\n    if (ANONYMOUS_FN_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (ANONYMOUS_PROMISE_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (ANONYMOUS_GENERATOR_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (NATIVE_NEXT_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (nodeInternals.some(internal => internal.test(line))) {\n      return false;\n    }\n\n    if (!STACK_PATH_REGEXP.test(line)) {\n      return true;\n    }\n\n    if (JASMINE_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (++pathCounter === 1) {\n      return true; // always keep the first line even if it's from Jest\n    }\n\n    if (options.noStackTrace) {\n      return false;\n    }\n\n    if (JEST_INTERNALS_IGNORE.test(line)) {\n      return false;\n    }\n\n    return true;\n  });\n};\n\nconst formatPath = function (line, config) {\n  let relativeTestPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  // Extract the file path from the trace line.\n  const match = line.match(/(^\\s*at .*?\\(?)([^()]+)(:[0-9]+:[0-9]+\\)?.*$)/);\n\n  if (!match) {\n    return line;\n  }\n\n  let filePath = (0, _slash.default)(path.relative(config.rootDir, match[2])); // highlight paths from the current test file\n\n  if (config.testMatch && config.testMatch.length && (0, _micromatch.default)([filePath], config.testMatch).length > 0 || filePath === relativeTestPath) {\n    filePath = _chalk.default.reset.cyan(filePath);\n  }\n\n  return STACK_TRACE_COLOR(match[1]) + filePath + STACK_TRACE_COLOR(match[3]);\n};\n\nexports.formatPath = formatPath;\n\nconst getStackTraceLines = function (stack) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    noCodeFrame: false,\n    noStackTrace: false\n  };\n  return removeInternalStackEntries(stack.split(/\\n/), options);\n};\n\nexports.getStackTraceLines = getStackTraceLines;\n\nconst getTopFrame = lines => {\n  for (const line of lines) {\n    if (line.includes(PATH_NODE_MODULES) || line.includes(PATH_JEST_PACKAGES)) {\n      continue;\n    }\n\n    const parsedFrame = stackUtils.parseLine(line.trim());\n\n    if (parsedFrame && parsedFrame.file) {\n      if (parsedFrame.file.startsWith('file://')) {\n        parsedFrame.file = (0, _slash.default)((0, _url.fileURLToPath)(parsedFrame.file));\n      }\n\n      return parsedFrame;\n    }\n  }\n\n  return null;\n};\n\nexports.getTopFrame = getTopFrame;\n\nconst formatStackTrace = (stack, config, options, testPath) => {\n  const lines = getStackTraceLines(stack, options);\n  let renderedCallsite = '';\n  const relativeTestPath = testPath ? (0, _slash.default)(path.relative(config.rootDir, testPath)) : null;\n\n  if (!options.noStackTrace && !options.noCodeFrame) {\n    const topFrame = getTopFrame(lines);\n\n    if (topFrame) {\n      const {\n        column,\n        file: filename,\n        line\n      } = topFrame;\n\n      if (line && filename && path.isAbsolute(filename)) {\n        let fileContent;\n\n        try {\n          // TODO: check & read HasteFS instead of reading the filesystem:\n          // see: https://github.com/facebook/jest/pull/5405#discussion_r164281696\n          fileContent = jestReadFile(filename, 'utf8');\n          renderedCallsite = getRenderedCallsite(fileContent, line, column);\n        } catch {// the file does not exist or is inaccessible, we ignore\n        }\n      }\n    }\n  }\n\n  const stacktrace = lines.filter(Boolean).map(line => STACK_INDENT + formatPath(trimPaths(line), config, relativeTestPath)).join('\\n');\n  return renderedCallsite ? `${renderedCallsite}\\n${stacktrace}` : `\\n${stacktrace}`;\n};\n\nexports.formatStackTrace = formatStackTrace;\n\nconst formatResultsErrors = (testResults, config, options, testPath) => {\n  const failedResults = testResults.reduce((errors, result) => {\n    result.failureMessages.forEach(item => {\n      errors.push({\n        content: checkForCommonEnvironmentErrors(item),\n        result\n      });\n    });\n    return errors;\n  }, []);\n\n  if (!failedResults.length) {\n    return null;\n  }\n\n  return failedResults.map(_ref => {\n    let {\n      result,\n      content\n    } = _ref;\n    let {\n      message,\n      stack\n    } = separateMessageFromStack(content);\n    stack = options.noStackTrace ? '' : `${STACK_TRACE_COLOR(formatStackTrace(stack, config, options, testPath))}\\n`;\n    message = indentAllLines(message);\n    const title = `${_chalk.default.bold.red(TITLE_INDENT + TITLE_BULLET + result.ancestorTitles.join(ANCESTRY_SEPARATOR) + (result.ancestorTitles.length ? ANCESTRY_SEPARATOR : '') + result.title)}\\n`;\n    return `${title}\\n${message}\\n${stack}`;\n  }).join('\\n');\n};\n\nexports.formatResultsErrors = formatResultsErrors;\nconst errorRegexp = /^Error:?\\s*$/;\n\nconst removeBlankErrorLine = str => str.split('\\n') // Lines saying just `Error:` are useless\n.filter(line => !errorRegexp.test(line)).join('\\n').trimRight(); // jasmine and worker farm sometimes don't give us access to the actual\n// Error object, so we have to regexp out the message from the stack string\n// to format it.\n\n\nconst separateMessageFromStack = content => {\n  if (!content) {\n    return {\n      message: '',\n      stack: ''\n    };\n  } // All lines up to what looks like a stack -- or if nothing looks like a stack\n  // (maybe it's a code frame instead), just the first non-empty line.\n  // If the error is a plain \"Error:\" instead of a SyntaxError or TypeError we\n  // remove the prefix from the message because it is generally not useful.\n\n\n  const messageMatch = content.match(/^(?:Error: )?([\\s\\S]*?(?=\\n\\s*at\\s.*:\\d*:\\d*)|\\s*.*)([\\s\\S]*)$/);\n\n  if (!messageMatch) {\n    // For typescript\n    throw new Error('If you hit this error, the regex above is buggy.');\n  }\n\n  const message = removeBlankErrorLine(messageMatch[1]);\n  const stack = removeBlankErrorLine(messageMatch[2]);\n  return {\n    message,\n    stack\n  };\n};\n\nexports.separateMessageFromStack = separateMessageFromStack;","map":{"version":3,"names":["Object","defineProperty","exports","value","separateMessageFromStack","indentAllLines","getTopFrame","getStackTraceLines","formatStackTrace","formatResultsErrors","formatPath","formatExecError","path","_interopRequireWildcard","require","_url","_codeFrame","_chalk","_interopRequireDefault","fs","_micromatch","_slash","_stackUtils","_prettyFormat","obj","__esModule","default","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","Symbol","globalThis","jestReadFile","for","readFileSync","stackUtils","cwd","nodeInternals","PATH_NODE_MODULES","sep","PATH_JEST_PACKAGES","JASMINE_IGNORE","JEST_INTERNALS_IGNORE","ANONYMOUS_FN_IGNORE","ANONYMOUS_PROMISE_IGNORE","ANONYMOUS_GENERATOR_IGNORE","NATIVE_NEXT_IGNORE","TITLE_INDENT","MESSAGE_INDENT","STACK_INDENT","ANCESTRY_SEPARATOR","TITLE_BULLET","bold","STACK_TRACE_COLOR","dim","STACK_PATH_REGEXP","EXEC_ERROR_MESSAGE","NOT_EMPTY_LINE_REGEXP","lines","replace","trim","string","trimPaths","match","getRenderedCallsite","fileContent","line","column","renderedCallsite","codeFrameColumns","start","highlightCode","blankStringRegexp","checkForCommonEnvironmentErrors","error","includes","warnAboutWrongTestEnvironment","env","red","underline","config","options","testPath","reuseMessage","Error","String","stack","message","format","maxDepth","separated","noStackTrace","test","messageToUse","removeInternalStackEntries","pathCounter","filter","some","internal","relativeTestPath","filePath","relative","rootDir","testMatch","length","reset","cyan","noCodeFrame","split","parsedFrame","parseLine","file","startsWith","fileURLToPath","topFrame","filename","isAbsolute","stacktrace","Boolean","map","join","testResults","failedResults","reduce","errors","result","failureMessages","forEach","item","push","content","title","ancestorTitles","errorRegexp","removeBlankErrorLine","str","trimRight","messageMatch"],"sources":["/Users/wonjaelee/Desktop/final/node_modules/jest-message-util/build/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.separateMessageFromStack =\n  exports.indentAllLines =\n  exports.getTopFrame =\n  exports.getStackTraceLines =\n  exports.formatStackTrace =\n  exports.formatResultsErrors =\n  exports.formatPath =\n  exports.formatExecError =\n    void 0;\n\nvar path = _interopRequireWildcard(require('path'));\n\nvar _url = require('url');\n\nvar _codeFrame = require('@babel/code-frame');\n\nvar _chalk = _interopRequireDefault(require('chalk'));\n\nvar fs = _interopRequireWildcard(require('graceful-fs'));\n\nvar _micromatch = _interopRequireDefault(require('micromatch'));\n\nvar _slash = _interopRequireDefault(require('slash'));\n\nvar _stackUtils = _interopRequireDefault(require('stack-utils'));\n\nvar _prettyFormat = require('pretty-format');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\nvar Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;\nvar Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;\nvar jestReadFile =\n  globalThis[Symbol.for('jest-native-read-file')] || fs.readFileSync;\n// stack utils tries to create pretty stack by making paths relative.\nconst stackUtils = new _stackUtils.default({\n  cwd: 'something which does not exist'\n});\nlet nodeInternals = [];\n\ntry {\n  nodeInternals = _stackUtils.default.nodeInternals();\n} catch {\n  // `StackUtils.nodeInternals()` fails in browsers. We don't need to remove\n  // node internals in the browser though, so no issue.\n}\n\nconst PATH_NODE_MODULES = `${path.sep}node_modules${path.sep}`;\nconst PATH_JEST_PACKAGES = `${path.sep}jest${path.sep}packages${path.sep}`; // filter for noisy stack trace lines\n\nconst JASMINE_IGNORE =\n  /^\\s+at(?:(?:.jasmine-)|\\s+jasmine\\.buildExpectationResult)/;\nconst JEST_INTERNALS_IGNORE =\n  /^\\s+at.*?jest(-.*?)?(\\/|\\\\)(build|node_modules|packages)(\\/|\\\\)/;\nconst ANONYMOUS_FN_IGNORE = /^\\s+at <anonymous>.*$/;\nconst ANONYMOUS_PROMISE_IGNORE = /^\\s+at (new )?Promise \\(<anonymous>\\).*$/;\nconst ANONYMOUS_GENERATOR_IGNORE = /^\\s+at Generator.next \\(<anonymous>\\).*$/;\nconst NATIVE_NEXT_IGNORE = /^\\s+at next \\(native\\).*$/;\nconst TITLE_INDENT = '  ';\nconst MESSAGE_INDENT = '    ';\nconst STACK_INDENT = '      ';\nconst ANCESTRY_SEPARATOR = ' \\u203A ';\n\nconst TITLE_BULLET = _chalk.default.bold('\\u25cf ');\n\nconst STACK_TRACE_COLOR = _chalk.default.dim;\nconst STACK_PATH_REGEXP = /\\s*at.*\\(?(:\\d*:\\d*|native)\\)?/;\nconst EXEC_ERROR_MESSAGE = 'Test suite failed to run';\nconst NOT_EMPTY_LINE_REGEXP = /^(?!$)/gm;\n\nconst indentAllLines = lines =>\n  lines.replace(NOT_EMPTY_LINE_REGEXP, MESSAGE_INDENT);\n\nexports.indentAllLines = indentAllLines;\n\nconst trim = string => (string || '').trim(); // Some errors contain not only line numbers in stack traces\n// e.g. SyntaxErrors can contain snippets of code, and we don't\n// want to trim those, because they may have pointers to the column/character\n// which will get misaligned.\n\nconst trimPaths = string =>\n  string.match(STACK_PATH_REGEXP) ? trim(string) : string;\n\nconst getRenderedCallsite = (fileContent, line, column) => {\n  let renderedCallsite = (0, _codeFrame.codeFrameColumns)(\n    fileContent,\n    {\n      start: {\n        column,\n        line\n      }\n    },\n    {\n      highlightCode: true\n    }\n  );\n  renderedCallsite = indentAllLines(renderedCallsite);\n  renderedCallsite = `\\n${renderedCallsite}\\n`;\n  return renderedCallsite;\n};\n\nconst blankStringRegexp = /^\\s*$/;\n\nfunction checkForCommonEnvironmentErrors(error) {\n  if (\n    error.includes('ReferenceError: document is not defined') ||\n    error.includes('ReferenceError: window is not defined') ||\n    error.includes('ReferenceError: navigator is not defined')\n  ) {\n    return warnAboutWrongTestEnvironment(error, 'jsdom');\n  } else if (error.includes('.unref is not a function')) {\n    return warnAboutWrongTestEnvironment(error, 'node');\n  }\n\n  return error;\n}\n\nfunction warnAboutWrongTestEnvironment(error, env) {\n  return (\n    _chalk.default.bold.red(\n      `The error below may be caused by using the wrong test environment, see ${_chalk.default.dim.underline(\n        'https://jestjs.io/docs/configuration#testenvironment-string'\n      )}.\\nConsider using the \"${env}\" test environment.\\n\\n`\n    ) + error\n  );\n} // ExecError is an error thrown outside of the test suite (not inside an `it` or\n// `before/after each` hooks). If it's thrown, none of the tests in the file\n// are executed.\n\nconst formatExecError = (error, config, options, testPath, reuseMessage) => {\n  if (!error || typeof error === 'number') {\n    error = new Error(`Expected an Error, but \"${String(error)}\" was thrown`);\n    error.stack = '';\n  }\n\n  let message, stack;\n\n  if (typeof error === 'string' || !error) {\n    error || (error = 'EMPTY ERROR');\n    message = '';\n    stack = error;\n  } else {\n    message = error.message;\n    stack =\n      typeof error.stack === 'string'\n        ? error.stack\n        : `thrown: ${(0, _prettyFormat.format)(error, {\n            maxDepth: 3\n          })}`;\n  }\n\n  const separated = separateMessageFromStack(stack || '');\n  stack = separated.stack;\n\n  if (separated.message.includes(trim(message))) {\n    // Often stack trace already contains the duplicate of the message\n    message = separated.message;\n  }\n\n  message = checkForCommonEnvironmentErrors(message);\n  message = indentAllLines(message);\n  stack =\n    stack && !options.noStackTrace\n      ? `\\n${formatStackTrace(stack, config, options, testPath)}`\n      : '';\n\n  if (\n    typeof stack !== 'string' ||\n    (blankStringRegexp.test(message) && blankStringRegexp.test(stack))\n  ) {\n    // this can happen if an empty object is thrown.\n    message = `thrown: ${(0, _prettyFormat.format)(error, {\n      maxDepth: 3\n    })}`;\n  }\n\n  let messageToUse;\n\n  if (reuseMessage) {\n    messageToUse = ` ${message.trim()}`;\n  } else {\n    messageToUse = `${EXEC_ERROR_MESSAGE}\\n\\n${message}`;\n  }\n\n  return `${TITLE_INDENT + TITLE_BULLET + messageToUse + stack}\\n`;\n};\n\nexports.formatExecError = formatExecError;\n\nconst removeInternalStackEntries = (lines, options) => {\n  let pathCounter = 0;\n  return lines.filter(line => {\n    if (ANONYMOUS_FN_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (ANONYMOUS_PROMISE_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (ANONYMOUS_GENERATOR_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (NATIVE_NEXT_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (nodeInternals.some(internal => internal.test(line))) {\n      return false;\n    }\n\n    if (!STACK_PATH_REGEXP.test(line)) {\n      return true;\n    }\n\n    if (JASMINE_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (++pathCounter === 1) {\n      return true; // always keep the first line even if it's from Jest\n    }\n\n    if (options.noStackTrace) {\n      return false;\n    }\n\n    if (JEST_INTERNALS_IGNORE.test(line)) {\n      return false;\n    }\n\n    return true;\n  });\n};\n\nconst formatPath = (line, config, relativeTestPath = null) => {\n  // Extract the file path from the trace line.\n  const match = line.match(/(^\\s*at .*?\\(?)([^()]+)(:[0-9]+:[0-9]+\\)?.*$)/);\n\n  if (!match) {\n    return line;\n  }\n\n  let filePath = (0, _slash.default)(path.relative(config.rootDir, match[2])); // highlight paths from the current test file\n\n  if (\n    (config.testMatch &&\n      config.testMatch.length &&\n      (0, _micromatch.default)([filePath], config.testMatch).length > 0) ||\n    filePath === relativeTestPath\n  ) {\n    filePath = _chalk.default.reset.cyan(filePath);\n  }\n\n  return STACK_TRACE_COLOR(match[1]) + filePath + STACK_TRACE_COLOR(match[3]);\n};\n\nexports.formatPath = formatPath;\n\nconst getStackTraceLines = (\n  stack,\n  options = {\n    noCodeFrame: false,\n    noStackTrace: false\n  }\n) => removeInternalStackEntries(stack.split(/\\n/), options);\n\nexports.getStackTraceLines = getStackTraceLines;\n\nconst getTopFrame = lines => {\n  for (const line of lines) {\n    if (line.includes(PATH_NODE_MODULES) || line.includes(PATH_JEST_PACKAGES)) {\n      continue;\n    }\n\n    const parsedFrame = stackUtils.parseLine(line.trim());\n\n    if (parsedFrame && parsedFrame.file) {\n      if (parsedFrame.file.startsWith('file://')) {\n        parsedFrame.file = (0, _slash.default)(\n          (0, _url.fileURLToPath)(parsedFrame.file)\n        );\n      }\n\n      return parsedFrame;\n    }\n  }\n\n  return null;\n};\n\nexports.getTopFrame = getTopFrame;\n\nconst formatStackTrace = (stack, config, options, testPath) => {\n  const lines = getStackTraceLines(stack, options);\n  let renderedCallsite = '';\n  const relativeTestPath = testPath\n    ? (0, _slash.default)(path.relative(config.rootDir, testPath))\n    : null;\n\n  if (!options.noStackTrace && !options.noCodeFrame) {\n    const topFrame = getTopFrame(lines);\n\n    if (topFrame) {\n      const {column, file: filename, line} = topFrame;\n\n      if (line && filename && path.isAbsolute(filename)) {\n        let fileContent;\n\n        try {\n          // TODO: check & read HasteFS instead of reading the filesystem:\n          // see: https://github.com/facebook/jest/pull/5405#discussion_r164281696\n          fileContent = jestReadFile(filename, 'utf8');\n          renderedCallsite = getRenderedCallsite(fileContent, line, column);\n        } catch {\n          // the file does not exist or is inaccessible, we ignore\n        }\n      }\n    }\n  }\n\n  const stacktrace = lines\n    .filter(Boolean)\n    .map(\n      line =>\n        STACK_INDENT + formatPath(trimPaths(line), config, relativeTestPath)\n    )\n    .join('\\n');\n  return renderedCallsite\n    ? `${renderedCallsite}\\n${stacktrace}`\n    : `\\n${stacktrace}`;\n};\n\nexports.formatStackTrace = formatStackTrace;\n\nconst formatResultsErrors = (testResults, config, options, testPath) => {\n  const failedResults = testResults.reduce((errors, result) => {\n    result.failureMessages.forEach(item => {\n      errors.push({\n        content: checkForCommonEnvironmentErrors(item),\n        result\n      });\n    });\n    return errors;\n  }, []);\n\n  if (!failedResults.length) {\n    return null;\n  }\n\n  return failedResults\n    .map(({result, content}) => {\n      let {message, stack} = separateMessageFromStack(content);\n      stack = options.noStackTrace\n        ? ''\n        : `${STACK_TRACE_COLOR(\n            formatStackTrace(stack, config, options, testPath)\n          )}\\n`;\n      message = indentAllLines(message);\n      const title = `${_chalk.default.bold.red(\n        TITLE_INDENT +\n          TITLE_BULLET +\n          result.ancestorTitles.join(ANCESTRY_SEPARATOR) +\n          (result.ancestorTitles.length ? ANCESTRY_SEPARATOR : '') +\n          result.title\n      )}\\n`;\n      return `${title}\\n${message}\\n${stack}`;\n    })\n    .join('\\n');\n};\n\nexports.formatResultsErrors = formatResultsErrors;\nconst errorRegexp = /^Error:?\\s*$/;\n\nconst removeBlankErrorLine = str =>\n  str\n    .split('\\n') // Lines saying just `Error:` are useless\n    .filter(line => !errorRegexp.test(line))\n    .join('\\n')\n    .trimRight(); // jasmine and worker farm sometimes don't give us access to the actual\n// Error object, so we have to regexp out the message from the stack string\n// to format it.\n\nconst separateMessageFromStack = content => {\n  if (!content) {\n    return {\n      message: '',\n      stack: ''\n    };\n  } // All lines up to what looks like a stack -- or if nothing looks like a stack\n  // (maybe it's a code frame instead), just the first non-empty line.\n  // If the error is a plain \"Error:\" instead of a SyntaxError or TypeError we\n  // remove the prefix from the message because it is generally not useful.\n\n  const messageMatch = content.match(\n    /^(?:Error: )?([\\s\\S]*?(?=\\n\\s*at\\s.*:\\d*:\\d*)|\\s*.*)([\\s\\S]*)$/\n  );\n\n  if (!messageMatch) {\n    // For typescript\n    throw new Error('If you hit this error, the regex above is buggy.');\n  }\n\n  const message = removeBlankErrorLine(messageMatch[1]);\n  const stack = removeBlankErrorLine(messageMatch[2]);\n  return {\n    message,\n    stack\n  };\n};\n\nexports.separateMessageFromStack = separateMessageFromStack;\n"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAC3CC,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,wBAAR,GACEF,OAAO,CAACG,cAAR,GACAH,OAAO,CAACI,WAAR,GACAJ,OAAO,CAACK,kBAAR,GACAL,OAAO,CAACM,gBAAR,GACAN,OAAO,CAACO,mBAAR,GACAP,OAAO,CAACQ,UAAR,GACAR,OAAO,CAACS,eAAR,GACE,KAAK,CART;;AAUA,IAAIC,IAAI,GAAGC,uBAAuB,CAACC,OAAO,CAAC,MAAD,CAAR,CAAlC;;AAEA,IAAIC,IAAI,GAAGD,OAAO,CAAC,KAAD,CAAlB;;AAEA,IAAIE,UAAU,GAAGF,OAAO,CAAC,mBAAD,CAAxB;;AAEA,IAAIG,MAAM,GAAGC,sBAAsB,CAACJ,OAAO,CAAC,OAAD,CAAR,CAAnC;;AAEA,IAAIK,EAAE,GAAGN,uBAAuB,CAACC,OAAO,CAAC,aAAD,CAAR,CAAhC;;AAEA,IAAIM,WAAW,GAAGF,sBAAsB,CAACJ,OAAO,CAAC,YAAD,CAAR,CAAxC;;AAEA,IAAIO,MAAM,GAAGH,sBAAsB,CAACJ,OAAO,CAAC,OAAD,CAAR,CAAnC;;AAEA,IAAIQ,WAAW,GAAGJ,sBAAsB,CAACJ,OAAO,CAAC,aAAD,CAAR,CAAxC;;AAEA,IAAIS,aAAa,GAAGT,OAAO,CAAC,eAAD,CAA3B;;AAEA,SAASI,sBAAT,CAAgCM,GAAhC,EAAqC;EACnC,OAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;IAACE,OAAO,EAAEF;EAAV,CAArC;AACD;;AAED,SAASG,wBAAT,CAAkCC,WAAlC,EAA+C;EAC7C,IAAI,OAAOC,OAAP,KAAmB,UAAvB,EAAmC,OAAO,IAAP;EACnC,IAAIC,iBAAiB,GAAG,IAAID,OAAJ,EAAxB;EACA,IAAIE,gBAAgB,GAAG,IAAIF,OAAJ,EAAvB;EACA,OAAO,CAACF,wBAAwB,GAAG,UAAUC,WAAV,EAAuB;IACxD,OAAOA,WAAW,GAAGG,gBAAH,GAAsBD,iBAAxC;EACD,CAFM,EAEJF,WAFI,CAAP;AAGD;;AAED,SAASf,uBAAT,CAAiCW,GAAjC,EAAsCI,WAAtC,EAAmD;EACjD,IAAI,CAACA,WAAD,IAAgBJ,GAAhB,IAAuBA,GAAG,CAACC,UAA/B,EAA2C;IACzC,OAAOD,GAAP;EACD;;EACD,IAAIA,GAAG,KAAK,IAAR,IAAiB,OAAOA,GAAP,KAAe,QAAf,IAA2B,OAAOA,GAAP,KAAe,UAA/D,EAA4E;IAC1E,OAAO;MAACE,OAAO,EAAEF;IAAV,CAAP;EACD;;EACD,IAAIQ,KAAK,GAAGL,wBAAwB,CAACC,WAAD,CAApC;;EACA,IAAII,KAAK,IAAIA,KAAK,CAACC,GAAN,CAAUT,GAAV,CAAb,EAA6B;IAC3B,OAAOQ,KAAK,CAACE,GAAN,CAAUV,GAAV,CAAP;EACD;;EACD,IAAIW,MAAM,GAAG,EAAb;EACA,IAAIC,qBAAqB,GACvBpC,MAAM,CAACC,cAAP,IAAyBD,MAAM,CAACqC,wBADlC;;EAEA,KAAK,IAAIC,GAAT,IAAgBd,GAAhB,EAAqB;IACnB,IAAIc,GAAG,KAAK,SAAR,IAAqBtC,MAAM,CAACuC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCjB,GAArC,EAA0Cc,GAA1C,CAAzB,EAAyE;MACvE,IAAII,IAAI,GAAGN,qBAAqB,GAC5BpC,MAAM,CAACqC,wBAAP,CAAgCb,GAAhC,EAAqCc,GAArC,CAD4B,GAE5B,IAFJ;;MAGA,IAAII,IAAI,KAAKA,IAAI,CAACR,GAAL,IAAYQ,IAAI,CAACC,GAAtB,CAAR,EAAoC;QAClC3C,MAAM,CAACC,cAAP,CAAsBkC,MAAtB,EAA8BG,GAA9B,EAAmCI,IAAnC;MACD,CAFD,MAEO;QACLP,MAAM,CAACG,GAAD,CAAN,GAAcd,GAAG,CAACc,GAAD,CAAjB;MACD;IACF;EACF;;EACDH,MAAM,CAACT,OAAP,GAAiBF,GAAjB;;EACA,IAAIQ,KAAJ,EAAW;IACTA,KAAK,CAACW,GAAN,CAAUnB,GAAV,EAAeW,MAAf;EACD;;EACD,OAAOA,MAAP;AACD;;AAED,IAAIS,MAAM,GAAGC,UAAU,CAAC,0BAAD,CAAV,IAA0CA,UAAU,CAACD,MAAlE;AACA,IAAIA,MAAM,GAAGC,UAAU,CAAC,0BAAD,CAAV,IAA0CA,UAAU,CAACD,MAAlE;AACA,IAAIE,YAAY,GACdD,UAAU,CAACD,MAAM,CAACG,GAAP,CAAW,uBAAX,CAAD,CAAV,IAAmD5B,EAAE,CAAC6B,YADxD,C,CAEA;;AACA,MAAMC,UAAU,GAAG,IAAI3B,WAAW,CAACI,OAAhB,CAAwB;EACzCwB,GAAG,EAAE;AADoC,CAAxB,CAAnB;AAGA,IAAIC,aAAa,GAAG,EAApB;;AAEA,IAAI;EACFA,aAAa,GAAG7B,WAAW,CAACI,OAAZ,CAAoByB,aAApB,EAAhB;AACD,CAFD,CAEE,MAAM,CACN;EACA;AACD;;AAED,MAAMC,iBAAiB,GAAI,GAAExC,IAAI,CAACyC,GAAI,eAAczC,IAAI,CAACyC,GAAI,EAA7D;AACA,MAAMC,kBAAkB,GAAI,GAAE1C,IAAI,CAACyC,GAAI,OAAMzC,IAAI,CAACyC,GAAI,WAAUzC,IAAI,CAACyC,GAAI,EAAzE,C,CAA4E;;AAE5E,MAAME,cAAc,GAClB,4DADF;AAEA,MAAMC,qBAAqB,GACzB,iEADF;AAEA,MAAMC,mBAAmB,GAAG,uBAA5B;AACA,MAAMC,wBAAwB,GAAG,0CAAjC;AACA,MAAMC,0BAA0B,GAAG,0CAAnC;AACA,MAAMC,kBAAkB,GAAG,2BAA3B;AACA,MAAMC,YAAY,GAAG,IAArB;AACA,MAAMC,cAAc,GAAG,MAAvB;AACA,MAAMC,YAAY,GAAG,QAArB;AACA,MAAMC,kBAAkB,GAAG,UAA3B;;AAEA,MAAMC,YAAY,GAAGhD,MAAM,CAACS,OAAP,CAAewC,IAAf,CAAoB,SAApB,CAArB;;AAEA,MAAMC,iBAAiB,GAAGlD,MAAM,CAACS,OAAP,CAAe0C,GAAzC;AACA,MAAMC,iBAAiB,GAAG,gCAA1B;AACA,MAAMC,kBAAkB,GAAG,0BAA3B;AACA,MAAMC,qBAAqB,GAAG,UAA9B;;AAEA,MAAMlE,cAAc,GAAGmE,KAAK,IAC1BA,KAAK,CAACC,OAAN,CAAcF,qBAAd,EAAqCT,cAArC,CADF;;AAGA5D,OAAO,CAACG,cAAR,GAAyBA,cAAzB;;AAEA,MAAMqE,IAAI,GAAGC,MAAM,IAAI,CAACA,MAAM,IAAI,EAAX,EAAeD,IAAf,EAAvB,C,CAA8C;AAC9C;AACA;AACA;;;AAEA,MAAME,SAAS,GAAGD,MAAM,IACtBA,MAAM,CAACE,KAAP,CAAaR,iBAAb,IAAkCK,IAAI,CAACC,MAAD,CAAtC,GAAiDA,MADnD;;AAGA,MAAMG,mBAAmB,GAAG,CAACC,WAAD,EAAcC,IAAd,EAAoBC,MAApB,KAA+B;EACzD,IAAIC,gBAAgB,GAAG,CAAC,GAAGlE,UAAU,CAACmE,gBAAf,EACrBJ,WADqB,EAErB;IACEK,KAAK,EAAE;MACLH,MADK;MAELD;IAFK;EADT,CAFqB,EAQrB;IACEK,aAAa,EAAE;EADjB,CARqB,CAAvB;EAYAH,gBAAgB,GAAG7E,cAAc,CAAC6E,gBAAD,CAAjC;EACAA,gBAAgB,GAAI,KAAIA,gBAAiB,IAAzC;EACA,OAAOA,gBAAP;AACD,CAhBD;;AAkBA,MAAMI,iBAAiB,GAAG,OAA1B;;AAEA,SAASC,+BAAT,CAAyCC,KAAzC,EAAgD;EAC9C,IACEA,KAAK,CAACC,QAAN,CAAe,yCAAf,KACAD,KAAK,CAACC,QAAN,CAAe,uCAAf,CADA,IAEAD,KAAK,CAACC,QAAN,CAAe,0CAAf,CAHF,EAIE;IACA,OAAOC,6BAA6B,CAACF,KAAD,EAAQ,OAAR,CAApC;EACD,CAND,MAMO,IAAIA,KAAK,CAACC,QAAN,CAAe,0BAAf,CAAJ,EAAgD;IACrD,OAAOC,6BAA6B,CAACF,KAAD,EAAQ,MAAR,CAApC;EACD;;EAED,OAAOA,KAAP;AACD;;AAED,SAASE,6BAAT,CAAuCF,KAAvC,EAA8CG,GAA9C,EAAmD;EACjD,OACE1E,MAAM,CAACS,OAAP,CAAewC,IAAf,CAAoB0B,GAApB,CACG,0EAAyE3E,MAAM,CAACS,OAAP,CAAe0C,GAAf,CAAmByB,SAAnB,CACxE,6DADwE,CAExE,0BAAyBF,GAAI,yBAHjC,IAIIH,KALN;AAOD,C,CAAC;AACF;AACA;;;AAEA,MAAM7E,eAAe,GAAG,CAAC6E,KAAD,EAAQM,MAAR,EAAgBC,OAAhB,EAAyBC,QAAzB,EAAmCC,YAAnC,KAAoD;EAC1E,IAAI,CAACT,KAAD,IAAU,OAAOA,KAAP,KAAiB,QAA/B,EAAyC;IACvCA,KAAK,GAAG,IAAIU,KAAJ,CAAW,2BAA0BC,MAAM,CAACX,KAAD,CAAQ,cAAnD,CAAR;IACAA,KAAK,CAACY,KAAN,GAAc,EAAd;EACD;;EAED,IAAIC,OAAJ,EAAaD,KAAb;;EAEA,IAAI,OAAOZ,KAAP,KAAiB,QAAjB,IAA6B,CAACA,KAAlC,EAAyC;IACvCA,KAAK,KAAKA,KAAK,GAAG,aAAb,CAAL;IACAa,OAAO,GAAG,EAAV;IACAD,KAAK,GAAGZ,KAAR;EACD,CAJD,MAIO;IACLa,OAAO,GAAGb,KAAK,CAACa,OAAhB;IACAD,KAAK,GACH,OAAOZ,KAAK,CAACY,KAAb,KAAuB,QAAvB,GACIZ,KAAK,CAACY,KADV,GAEK,WAAU,CAAC,GAAG7E,aAAa,CAAC+E,MAAlB,EAA0Bd,KAA1B,EAAiC;MAC1Ce,QAAQ,EAAE;IADgC,CAAjC,CAER,EALT;EAMD;;EAED,MAAMC,SAAS,GAAGpG,wBAAwB,CAACgG,KAAK,IAAI,EAAV,CAA1C;EACAA,KAAK,GAAGI,SAAS,CAACJ,KAAlB;;EAEA,IAAII,SAAS,CAACH,OAAV,CAAkBZ,QAAlB,CAA2Bf,IAAI,CAAC2B,OAAD,CAA/B,CAAJ,EAA+C;IAC7C;IACAA,OAAO,GAAGG,SAAS,CAACH,OAApB;EACD;;EAEDA,OAAO,GAAGd,+BAA+B,CAACc,OAAD,CAAzC;EACAA,OAAO,GAAGhG,cAAc,CAACgG,OAAD,CAAxB;EACAD,KAAK,GACHA,KAAK,IAAI,CAACL,OAAO,CAACU,YAAlB,GACK,KAAIjG,gBAAgB,CAAC4F,KAAD,EAAQN,MAAR,EAAgBC,OAAhB,EAAyBC,QAAzB,CAAmC,EAD5D,GAEI,EAHN;;EAKA,IACE,OAAOI,KAAP,KAAiB,QAAjB,IACCd,iBAAiB,CAACoB,IAAlB,CAAuBL,OAAvB,KAAmCf,iBAAiB,CAACoB,IAAlB,CAAuBN,KAAvB,CAFtC,EAGE;IACA;IACAC,OAAO,GAAI,WAAU,CAAC,GAAG9E,aAAa,CAAC+E,MAAlB,EAA0Bd,KAA1B,EAAiC;MACpDe,QAAQ,EAAE;IAD0C,CAAjC,CAElB,EAFH;EAGD;;EAED,IAAII,YAAJ;;EAEA,IAAIV,YAAJ,EAAkB;IAChBU,YAAY,GAAI,IAAGN,OAAO,CAAC3B,IAAR,EAAe,EAAlC;EACD,CAFD,MAEO;IACLiC,YAAY,GAAI,GAAErC,kBAAmB,OAAM+B,OAAQ,EAAnD;EACD;;EAED,OAAQ,GAAExC,YAAY,GAAGI,YAAf,GAA8B0C,YAA9B,GAA6CP,KAAM,IAA7D;AACD,CAxDD;;AA0DAlG,OAAO,CAACS,eAAR,GAA0BA,eAA1B;;AAEA,MAAMiG,0BAA0B,GAAG,CAACpC,KAAD,EAAQuB,OAAR,KAAoB;EACrD,IAAIc,WAAW,GAAG,CAAlB;EACA,OAAOrC,KAAK,CAACsC,MAAN,CAAa9B,IAAI,IAAI;IAC1B,IAAIvB,mBAAmB,CAACiD,IAApB,CAAyB1B,IAAzB,CAAJ,EAAoC;MAClC,OAAO,KAAP;IACD;;IAED,IAAItB,wBAAwB,CAACgD,IAAzB,CAA8B1B,IAA9B,CAAJ,EAAyC;MACvC,OAAO,KAAP;IACD;;IAED,IAAIrB,0BAA0B,CAAC+C,IAA3B,CAAgC1B,IAAhC,CAAJ,EAA2C;MACzC,OAAO,KAAP;IACD;;IAED,IAAIpB,kBAAkB,CAAC8C,IAAnB,CAAwB1B,IAAxB,CAAJ,EAAmC;MACjC,OAAO,KAAP;IACD;;IAED,IAAI7B,aAAa,CAAC4D,IAAd,CAAmBC,QAAQ,IAAIA,QAAQ,CAACN,IAAT,CAAc1B,IAAd,CAA/B,CAAJ,EAAyD;MACvD,OAAO,KAAP;IACD;;IAED,IAAI,CAACX,iBAAiB,CAACqC,IAAlB,CAAuB1B,IAAvB,CAAL,EAAmC;MACjC,OAAO,IAAP;IACD;;IAED,IAAIzB,cAAc,CAACmD,IAAf,CAAoB1B,IAApB,CAAJ,EAA+B;MAC7B,OAAO,KAAP;IACD;;IAED,IAAI,EAAE6B,WAAF,KAAkB,CAAtB,EAAyB;MACvB,OAAO,IAAP,CADuB,CACV;IACd;;IAED,IAAId,OAAO,CAACU,YAAZ,EAA0B;MACxB,OAAO,KAAP;IACD;;IAED,IAAIjD,qBAAqB,CAACkD,IAAtB,CAA2B1B,IAA3B,CAAJ,EAAsC;MACpC,OAAO,KAAP;IACD;;IAED,OAAO,IAAP;EACD,CA1CM,CAAP;AA2CD,CA7CD;;AA+CA,MAAMtE,UAAU,GAAG,UAACsE,IAAD,EAAOc,MAAP,EAA2C;EAAA,IAA5BmB,gBAA4B,uEAAT,IAAS;EAC5D;EACA,MAAMpC,KAAK,GAAGG,IAAI,CAACH,KAAL,CAAW,+CAAX,CAAd;;EAEA,IAAI,CAACA,KAAL,EAAY;IACV,OAAOG,IAAP;EACD;;EAED,IAAIkC,QAAQ,GAAG,CAAC,GAAG7F,MAAM,CAACK,OAAX,EAAoBd,IAAI,CAACuG,QAAL,CAAcrB,MAAM,CAACsB,OAArB,EAA8BvC,KAAK,CAAC,CAAD,CAAnC,CAApB,CAAf,CAR4D,CAQiB;;EAE7E,IACGiB,MAAM,CAACuB,SAAP,IACCvB,MAAM,CAACuB,SAAP,CAAiBC,MADlB,IAEC,CAAC,GAAGlG,WAAW,CAACM,OAAhB,EAAyB,CAACwF,QAAD,CAAzB,EAAqCpB,MAAM,CAACuB,SAA5C,EAAuDC,MAAvD,GAAgE,CAFlE,IAGAJ,QAAQ,KAAKD,gBAJf,EAKE;IACAC,QAAQ,GAAGjG,MAAM,CAACS,OAAP,CAAe6F,KAAf,CAAqBC,IAArB,CAA0BN,QAA1B,CAAX;EACD;;EAED,OAAO/C,iBAAiB,CAACU,KAAK,CAAC,CAAD,CAAN,CAAjB,GAA8BqC,QAA9B,GAAyC/C,iBAAiB,CAACU,KAAK,CAAC,CAAD,CAAN,CAAjE;AACD,CApBD;;AAsBA3E,OAAO,CAACQ,UAAR,GAAqBA,UAArB;;AAEA,MAAMH,kBAAkB,GAAG,UACzB6F,KADyB;EAAA,IAEzBL,OAFyB,uEAEf;IACR0B,WAAW,EAAE,KADL;IAERhB,YAAY,EAAE;EAFN,CAFe;EAAA,OAMtBG,0BAA0B,CAACR,KAAK,CAACsB,KAAN,CAAY,IAAZ,CAAD,EAAoB3B,OAApB,CANJ;AAAA,CAA3B;;AAQA7F,OAAO,CAACK,kBAAR,GAA6BA,kBAA7B;;AAEA,MAAMD,WAAW,GAAGkE,KAAK,IAAI;EAC3B,KAAK,MAAMQ,IAAX,IAAmBR,KAAnB,EAA0B;IACxB,IAAIQ,IAAI,CAACS,QAAL,CAAcrC,iBAAd,KAAoC4B,IAAI,CAACS,QAAL,CAAcnC,kBAAd,CAAxC,EAA2E;MACzE;IACD;;IAED,MAAMqE,WAAW,GAAG1E,UAAU,CAAC2E,SAAX,CAAqB5C,IAAI,CAACN,IAAL,EAArB,CAApB;;IAEA,IAAIiD,WAAW,IAAIA,WAAW,CAACE,IAA/B,EAAqC;MACnC,IAAIF,WAAW,CAACE,IAAZ,CAAiBC,UAAjB,CAA4B,SAA5B,CAAJ,EAA4C;QAC1CH,WAAW,CAACE,IAAZ,GAAmB,CAAC,GAAGxG,MAAM,CAACK,OAAX,EACjB,CAAC,GAAGX,IAAI,CAACgH,aAAT,EAAwBJ,WAAW,CAACE,IAApC,CADiB,CAAnB;MAGD;;MAED,OAAOF,WAAP;IACD;EACF;;EAED,OAAO,IAAP;AACD,CApBD;;AAsBAzH,OAAO,CAACI,WAAR,GAAsBA,WAAtB;;AAEA,MAAME,gBAAgB,GAAG,CAAC4F,KAAD,EAAQN,MAAR,EAAgBC,OAAhB,EAAyBC,QAAzB,KAAsC;EAC7D,MAAMxB,KAAK,GAAGjE,kBAAkB,CAAC6F,KAAD,EAAQL,OAAR,CAAhC;EACA,IAAIb,gBAAgB,GAAG,EAAvB;EACA,MAAM+B,gBAAgB,GAAGjB,QAAQ,GAC7B,CAAC,GAAG3E,MAAM,CAACK,OAAX,EAAoBd,IAAI,CAACuG,QAAL,CAAcrB,MAAM,CAACsB,OAArB,EAA8BpB,QAA9B,CAApB,CAD6B,GAE7B,IAFJ;;EAIA,IAAI,CAACD,OAAO,CAACU,YAAT,IAAyB,CAACV,OAAO,CAAC0B,WAAtC,EAAmD;IACjD,MAAMO,QAAQ,GAAG1H,WAAW,CAACkE,KAAD,CAA5B;;IAEA,IAAIwD,QAAJ,EAAc;MACZ,MAAM;QAAC/C,MAAD;QAAS4C,IAAI,EAAEI,QAAf;QAAyBjD;MAAzB,IAAiCgD,QAAvC;;MAEA,IAAIhD,IAAI,IAAIiD,QAAR,IAAoBrH,IAAI,CAACsH,UAAL,CAAgBD,QAAhB,CAAxB,EAAmD;QACjD,IAAIlD,WAAJ;;QAEA,IAAI;UACF;UACA;UACAA,WAAW,GAAGjC,YAAY,CAACmF,QAAD,EAAW,MAAX,CAA1B;UACA/C,gBAAgB,GAAGJ,mBAAmB,CAACC,WAAD,EAAcC,IAAd,EAAoBC,MAApB,CAAtC;QACD,CALD,CAKE,MAAM,CACN;QACD;MACF;IACF;EACF;;EAED,MAAMkD,UAAU,GAAG3D,KAAK,CACrBsC,MADgB,CACTsB,OADS,EAEhBC,GAFgB,CAGfrD,IAAI,IACFjB,YAAY,GAAGrD,UAAU,CAACkE,SAAS,CAACI,IAAD,CAAV,EAAkBc,MAAlB,EAA0BmB,gBAA1B,CAJZ,EAMhBqB,IANgB,CAMX,IANW,CAAnB;EAOA,OAAOpD,gBAAgB,GAClB,GAAEA,gBAAiB,KAAIiD,UAAW,EADhB,GAElB,KAAIA,UAAW,EAFpB;AAGD,CAtCD;;AAwCAjI,OAAO,CAACM,gBAAR,GAA2BA,gBAA3B;;AAEA,MAAMC,mBAAmB,GAAG,CAAC8H,WAAD,EAAczC,MAAd,EAAsBC,OAAtB,EAA+BC,QAA/B,KAA4C;EACtE,MAAMwC,aAAa,GAAGD,WAAW,CAACE,MAAZ,CAAmB,CAACC,MAAD,EAASC,MAAT,KAAoB;IAC3DA,MAAM,CAACC,eAAP,CAAuBC,OAAvB,CAA+BC,IAAI,IAAI;MACrCJ,MAAM,CAACK,IAAP,CAAY;QACVC,OAAO,EAAEzD,+BAA+B,CAACuD,IAAD,CAD9B;QAEVH;MAFU,CAAZ;IAID,CALD;IAMA,OAAOD,MAAP;EACD,CARqB,EAQnB,EARmB,CAAtB;;EAUA,IAAI,CAACF,aAAa,CAAClB,MAAnB,EAA2B;IACzB,OAAO,IAAP;EACD;;EAED,OAAOkB,aAAa,CACjBH,GADI,CACA,QAAuB;IAAA,IAAtB;MAACM,MAAD;MAASK;IAAT,CAAsB;IAC1B,IAAI;MAAC3C,OAAD;MAAUD;IAAV,IAAmBhG,wBAAwB,CAAC4I,OAAD,CAA/C;IACA5C,KAAK,GAAGL,OAAO,CAACU,YAAR,GACJ,EADI,GAEH,GAAEtC,iBAAiB,CAClB3D,gBAAgB,CAAC4F,KAAD,EAAQN,MAAR,EAAgBC,OAAhB,EAAyBC,QAAzB,CADE,CAElB,IAJN;IAKAK,OAAO,GAAGhG,cAAc,CAACgG,OAAD,CAAxB;IACA,MAAM4C,KAAK,GAAI,GAAEhI,MAAM,CAACS,OAAP,CAAewC,IAAf,CAAoB0B,GAApB,CACf/B,YAAY,GACVI,YADF,GAEE0E,MAAM,CAACO,cAAP,CAAsBZ,IAAtB,CAA2BtE,kBAA3B,CAFF,IAGG2E,MAAM,CAACO,cAAP,CAAsB5B,MAAtB,GAA+BtD,kBAA/B,GAAoD,EAHvD,IAIE2E,MAAM,CAACM,KALM,CAMf,IANF;IAOA,OAAQ,GAAEA,KAAM,KAAI5C,OAAQ,KAAID,KAAM,EAAtC;EACD,CAjBI,EAkBJkC,IAlBI,CAkBC,IAlBD,CAAP;AAmBD,CAlCD;;AAoCApI,OAAO,CAACO,mBAAR,GAA8BA,mBAA9B;AACA,MAAM0I,WAAW,GAAG,cAApB;;AAEA,MAAMC,oBAAoB,GAAGC,GAAG,IAC9BA,GAAG,CACA3B,KADH,CACS,IADT,EACe;AADf,CAEGZ,MAFH,CAEU9B,IAAI,IAAI,CAACmE,WAAW,CAACzC,IAAZ,CAAiB1B,IAAjB,CAFnB,EAGGsD,IAHH,CAGQ,IAHR,EAIGgB,SAJH,EADF,C,CAKkB;AAClB;AACA;;;AAEA,MAAMlJ,wBAAwB,GAAG4I,OAAO,IAAI;EAC1C,IAAI,CAACA,OAAL,EAAc;IACZ,OAAO;MACL3C,OAAO,EAAE,EADJ;MAELD,KAAK,EAAE;IAFF,CAAP;EAID,CANyC,CAMxC;EACF;EACA;EACA;;;EAEA,MAAMmD,YAAY,GAAGP,OAAO,CAACnE,KAAR,CACnB,gEADmB,CAArB;;EAIA,IAAI,CAAC0E,YAAL,EAAmB;IACjB;IACA,MAAM,IAAIrD,KAAJ,CAAU,kDAAV,CAAN;EACD;;EAED,MAAMG,OAAO,GAAG+C,oBAAoB,CAACG,YAAY,CAAC,CAAD,CAAb,CAApC;EACA,MAAMnD,KAAK,GAAGgD,oBAAoB,CAACG,YAAY,CAAC,CAAD,CAAb,CAAlC;EACA,OAAO;IACLlD,OADK;IAELD;EAFK,CAAP;AAID,CA1BD;;AA4BAlG,OAAO,CAACE,wBAAR,GAAmCA,wBAAnC"},"metadata":{},"sourceType":"script"}