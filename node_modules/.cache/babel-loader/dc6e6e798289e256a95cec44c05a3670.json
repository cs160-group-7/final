{"ast":null,"code":"'use strict';\n\nconst anyMap = new WeakMap();\nconst eventsMap = new WeakMap();\nconst producersMap = new WeakMap();\nconst anyProducer = Symbol('anyProducer');\nconst resolvedPromise = Promise.resolve();\nconst listenerAdded = Symbol('listenerAdded');\nconst listenerRemoved = Symbol('listenerRemoved');\nlet isGlobalDebugEnabled = false;\n\nfunction assertEventName(eventName) {\n  if (typeof eventName !== 'string' && typeof eventName !== 'symbol') {\n    throw new TypeError('eventName must be a string or a symbol');\n  }\n}\n\nfunction assertListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('listener must be a function');\n  }\n}\n\nfunction getListeners(instance, eventName) {\n  const events = eventsMap.get(instance);\n\n  if (!events.has(eventName)) {\n    events.set(eventName, new Set());\n  }\n\n  return events.get(eventName);\n}\n\nfunction getEventProducers(instance, eventName) {\n  const key = typeof eventName === 'string' || typeof eventName === 'symbol' ? eventName : anyProducer;\n  const producers = producersMap.get(instance);\n\n  if (!producers.has(key)) {\n    producers.set(key, new Set());\n  }\n\n  return producers.get(key);\n}\n\nfunction enqueueProducers(instance, eventName, eventData) {\n  const producers = producersMap.get(instance);\n\n  if (producers.has(eventName)) {\n    for (const producer of producers.get(eventName)) {\n      producer.enqueue(eventData);\n    }\n  }\n\n  if (producers.has(anyProducer)) {\n    const item = Promise.all([eventName, eventData]);\n\n    for (const producer of producers.get(anyProducer)) {\n      producer.enqueue(item);\n    }\n  }\n}\n\nfunction iterator(instance, eventNames) {\n  eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n  let isFinished = false;\n\n  let flush = () => {};\n\n  let queue = [];\n  const producer = {\n    enqueue(item) {\n      queue.push(item);\n      flush();\n    },\n\n    finish() {\n      isFinished = true;\n      flush();\n    }\n\n  };\n\n  for (const eventName of eventNames) {\n    getEventProducers(instance, eventName).add(producer);\n  }\n\n  return {\n    async next() {\n      if (!queue) {\n        return {\n          done: true\n        };\n      }\n\n      if (queue.length === 0) {\n        if (isFinished) {\n          queue = undefined;\n          return this.next();\n        }\n\n        await new Promise(resolve => {\n          flush = resolve;\n        });\n        return this.next();\n      }\n\n      return {\n        done: false,\n        value: await queue.shift()\n      };\n    },\n\n    async return(value) {\n      queue = undefined;\n\n      for (const eventName of eventNames) {\n        getEventProducers(instance, eventName).delete(producer);\n      }\n\n      flush();\n      return arguments.length > 0 ? {\n        done: true,\n        value: await value\n      } : {\n        done: true\n      };\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n\n  };\n}\n\nfunction defaultMethodNamesOrAssert(methodNames) {\n  if (methodNames === undefined) {\n    return allEmitteryMethods;\n  }\n\n  if (!Array.isArray(methodNames)) {\n    throw new TypeError('`methodNames` must be an array of strings');\n  }\n\n  for (const methodName of methodNames) {\n    if (!allEmitteryMethods.includes(methodName)) {\n      if (typeof methodName !== 'string') {\n        throw new TypeError('`methodNames` element must be a string');\n      }\n\n      throw new Error(`${methodName} is not Emittery method`);\n    }\n  }\n\n  return methodNames;\n}\n\nconst isListenerSymbol = symbol => symbol === listenerAdded || symbol === listenerRemoved;\n\nclass Emittery {\n  static mixin(emitteryPropertyName, methodNames) {\n    methodNames = defaultMethodNamesOrAssert(methodNames);\n    return target => {\n      if (typeof target !== 'function') {\n        throw new TypeError('`target` must be function');\n      }\n\n      for (const methodName of methodNames) {\n        if (target.prototype[methodName] !== undefined) {\n          throw new Error(`The property \\`${methodName}\\` already exists on \\`target\\``);\n        }\n      }\n\n      function getEmitteryProperty() {\n        Object.defineProperty(this, emitteryPropertyName, {\n          enumerable: false,\n          value: new Emittery()\n        });\n        return this[emitteryPropertyName];\n      }\n\n      Object.defineProperty(target.prototype, emitteryPropertyName, {\n        enumerable: false,\n        get: getEmitteryProperty\n      });\n\n      const emitteryMethodCaller = methodName => function () {\n        return this[emitteryPropertyName][methodName](...arguments);\n      };\n\n      for (const methodName of methodNames) {\n        Object.defineProperty(target.prototype, methodName, {\n          enumerable: false,\n          value: emitteryMethodCaller(methodName)\n        });\n      }\n\n      return target;\n    };\n  }\n\n  static get isDebugEnabled() {\n    if (typeof process !== 'object') {\n      return isGlobalDebugEnabled;\n    }\n\n    const {\n      env\n    } = process || {\n      env: {}\n    };\n    return env.DEBUG === 'emittery' || env.DEBUG === '*' || isGlobalDebugEnabled;\n  }\n\n  static set isDebugEnabled(newValue) {\n    isGlobalDebugEnabled = newValue;\n  }\n\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    anyMap.set(this, new Set());\n    eventsMap.set(this, new Map());\n    producersMap.set(this, new Map());\n    this.debug = options.debug || {};\n\n    if (this.debug.enabled === undefined) {\n      this.debug.enabled = false;\n    }\n\n    if (!this.debug.logger) {\n      this.debug.logger = (type, debugName, eventName, eventData) => {\n        try {\n          // TODO: Use https://github.com/sindresorhus/safe-stringify when the package is more mature. Just copy-paste the code.\n          eventData = JSON.stringify(eventData);\n        } catch {\n          eventData = `Object with the following keys failed to stringify: ${Object.keys(eventData).join(',')}`;\n        }\n\n        if (typeof eventName === 'symbol') {\n          eventName = eventName.toString();\n        }\n\n        const currentTime = new Date();\n        const logTime = `${currentTime.getHours()}:${currentTime.getMinutes()}:${currentTime.getSeconds()}.${currentTime.getMilliseconds()}`;\n        console.log(`[${logTime}][emittery:${type}][${debugName}] Event Name: ${eventName}\\n\\tdata: ${eventData}`);\n      };\n    }\n  }\n\n  logIfDebugEnabled(type, eventName, eventData) {\n    if (Emittery.isDebugEnabled || this.debug.enabled) {\n      this.debug.logger(type, this.debug.name, eventName, eventData);\n    }\n  }\n\n  on(eventNames, listener) {\n    assertListener(listener);\n    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n\n    for (const eventName of eventNames) {\n      assertEventName(eventName);\n      getListeners(this, eventName).add(listener);\n      this.logIfDebugEnabled('subscribe', eventName, undefined);\n\n      if (!isListenerSymbol(eventName)) {\n        this.emit(listenerAdded, {\n          eventName,\n          listener\n        });\n      }\n    }\n\n    return this.off.bind(this, eventNames, listener);\n  }\n\n  off(eventNames, listener) {\n    assertListener(listener);\n    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n\n    for (const eventName of eventNames) {\n      assertEventName(eventName);\n      getListeners(this, eventName).delete(listener);\n      this.logIfDebugEnabled('unsubscribe', eventName, undefined);\n\n      if (!isListenerSymbol(eventName)) {\n        this.emit(listenerRemoved, {\n          eventName,\n          listener\n        });\n      }\n    }\n  }\n\n  once(eventNames) {\n    return new Promise(resolve => {\n      const off = this.on(eventNames, data => {\n        off();\n        resolve(data);\n      });\n    });\n  }\n\n  events(eventNames) {\n    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n\n    for (const eventName of eventNames) {\n      assertEventName(eventName);\n    }\n\n    return iterator(this, eventNames);\n  }\n\n  async emit(eventName, eventData) {\n    assertEventName(eventName);\n    this.logIfDebugEnabled('emit', eventName, eventData);\n    enqueueProducers(this, eventName, eventData);\n    const listeners = getListeners(this, eventName);\n    const anyListeners = anyMap.get(this);\n    const staticListeners = [...listeners];\n    const staticAnyListeners = isListenerSymbol(eventName) ? [] : [...anyListeners];\n    await resolvedPromise;\n    await Promise.all([...staticListeners.map(async listener => {\n      if (listeners.has(listener)) {\n        return listener(eventData);\n      }\n    }), ...staticAnyListeners.map(async listener => {\n      if (anyListeners.has(listener)) {\n        return listener(eventName, eventData);\n      }\n    })]);\n  }\n\n  async emitSerial(eventName, eventData) {\n    assertEventName(eventName);\n    this.logIfDebugEnabled('emitSerial', eventName, eventData);\n    const listeners = getListeners(this, eventName);\n    const anyListeners = anyMap.get(this);\n    const staticListeners = [...listeners];\n    const staticAnyListeners = [...anyListeners];\n    await resolvedPromise;\n    /* eslint-disable no-await-in-loop */\n\n    for (const listener of staticListeners) {\n      if (listeners.has(listener)) {\n        await listener(eventData);\n      }\n    }\n\n    for (const listener of staticAnyListeners) {\n      if (anyListeners.has(listener)) {\n        await listener(eventName, eventData);\n      }\n    }\n    /* eslint-enable no-await-in-loop */\n\n  }\n\n  onAny(listener) {\n    assertListener(listener);\n    this.logIfDebugEnabled('subscribeAny', undefined, undefined);\n    anyMap.get(this).add(listener);\n    this.emit(listenerAdded, {\n      listener\n    });\n    return this.offAny.bind(this, listener);\n  }\n\n  anyEvent() {\n    return iterator(this);\n  }\n\n  offAny(listener) {\n    assertListener(listener);\n    this.logIfDebugEnabled('unsubscribeAny', undefined, undefined);\n    this.emit(listenerRemoved, {\n      listener\n    });\n    anyMap.get(this).delete(listener);\n  }\n\n  clearListeners(eventNames) {\n    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n\n    for (const eventName of eventNames) {\n      this.logIfDebugEnabled('clear', eventName, undefined);\n\n      if (typeof eventName === 'string' || typeof eventName === 'symbol') {\n        getListeners(this, eventName).clear();\n        const producers = getEventProducers(this, eventName);\n\n        for (const producer of producers) {\n          producer.finish();\n        }\n\n        producers.clear();\n      } else {\n        anyMap.get(this).clear();\n\n        for (const listeners of eventsMap.get(this).values()) {\n          listeners.clear();\n        }\n\n        for (const producers of producersMap.get(this).values()) {\n          for (const producer of producers) {\n            producer.finish();\n          }\n\n          producers.clear();\n        }\n      }\n    }\n  }\n\n  listenerCount(eventNames) {\n    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n    let count = 0;\n\n    for (const eventName of eventNames) {\n      if (typeof eventName === 'string') {\n        count += anyMap.get(this).size + getListeners(this, eventName).size + getEventProducers(this, eventName).size + getEventProducers(this).size;\n        continue;\n      }\n\n      if (typeof eventName !== 'undefined') {\n        assertEventName(eventName);\n      }\n\n      count += anyMap.get(this).size;\n\n      for (const value of eventsMap.get(this).values()) {\n        count += value.size;\n      }\n\n      for (const value of producersMap.get(this).values()) {\n        count += value.size;\n      }\n    }\n\n    return count;\n  }\n\n  bindMethods(target, methodNames) {\n    if (typeof target !== 'object' || target === null) {\n      throw new TypeError('`target` must be an object');\n    }\n\n    methodNames = defaultMethodNamesOrAssert(methodNames);\n\n    for (const methodName of methodNames) {\n      if (target[methodName] !== undefined) {\n        throw new Error(`The property \\`${methodName}\\` already exists on \\`target\\``);\n      }\n\n      Object.defineProperty(target, methodName, {\n        enumerable: false,\n        value: this[methodName].bind(this)\n      });\n    }\n  }\n\n}\n\nconst allEmitteryMethods = Object.getOwnPropertyNames(Emittery.prototype).filter(v => v !== 'constructor');\nObject.defineProperty(Emittery, 'listenerAdded', {\n  value: listenerAdded,\n  writable: false,\n  enumerable: true,\n  configurable: false\n});\nObject.defineProperty(Emittery, 'listenerRemoved', {\n  value: listenerRemoved,\n  writable: false,\n  enumerable: true,\n  configurable: false\n});\nmodule.exports = Emittery;","map":{"version":3,"names":["anyMap","WeakMap","eventsMap","producersMap","anyProducer","Symbol","resolvedPromise","Promise","resolve","listenerAdded","listenerRemoved","isGlobalDebugEnabled","assertEventName","eventName","TypeError","assertListener","listener","getListeners","instance","events","get","has","set","Set","getEventProducers","key","producers","enqueueProducers","eventData","producer","enqueue","item","all","iterator","eventNames","Array","isArray","isFinished","flush","queue","push","finish","add","next","done","length","undefined","value","shift","return","delete","arguments","asyncIterator","defaultMethodNamesOrAssert","methodNames","allEmitteryMethods","methodName","includes","Error","isListenerSymbol","symbol","Emittery","mixin","emitteryPropertyName","target","prototype","getEmitteryProperty","Object","defineProperty","enumerable","emitteryMethodCaller","isDebugEnabled","process","env","DEBUG","newValue","constructor","options","Map","debug","enabled","logger","type","debugName","JSON","stringify","keys","join","toString","currentTime","Date","logTime","getHours","getMinutes","getSeconds","getMilliseconds","console","log","logIfDebugEnabled","name","on","emit","off","bind","once","data","listeners","anyListeners","staticListeners","staticAnyListeners","map","emitSerial","onAny","offAny","anyEvent","clearListeners","clear","values","listenerCount","count","size","bindMethods","getOwnPropertyNames","filter","v","writable","configurable","module","exports"],"sources":["/Users/wonjaelee/Desktop/final/node_modules/emittery/index.js"],"sourcesContent":["'use strict';\n\nconst anyMap = new WeakMap();\nconst eventsMap = new WeakMap();\nconst producersMap = new WeakMap();\nconst anyProducer = Symbol('anyProducer');\nconst resolvedPromise = Promise.resolve();\n\nconst listenerAdded = Symbol('listenerAdded');\nconst listenerRemoved = Symbol('listenerRemoved');\n\nlet isGlobalDebugEnabled = false;\n\nfunction assertEventName(eventName) {\n\tif (typeof eventName !== 'string' && typeof eventName !== 'symbol') {\n\t\tthrow new TypeError('eventName must be a string or a symbol');\n\t}\n}\n\nfunction assertListener(listener) {\n\tif (typeof listener !== 'function') {\n\t\tthrow new TypeError('listener must be a function');\n\t}\n}\n\nfunction getListeners(instance, eventName) {\n\tconst events = eventsMap.get(instance);\n\tif (!events.has(eventName)) {\n\t\tevents.set(eventName, new Set());\n\t}\n\n\treturn events.get(eventName);\n}\n\nfunction getEventProducers(instance, eventName) {\n\tconst key = typeof eventName === 'string' || typeof eventName === 'symbol' ? eventName : anyProducer;\n\tconst producers = producersMap.get(instance);\n\tif (!producers.has(key)) {\n\t\tproducers.set(key, new Set());\n\t}\n\n\treturn producers.get(key);\n}\n\nfunction enqueueProducers(instance, eventName, eventData) {\n\tconst producers = producersMap.get(instance);\n\tif (producers.has(eventName)) {\n\t\tfor (const producer of producers.get(eventName)) {\n\t\t\tproducer.enqueue(eventData);\n\t\t}\n\t}\n\n\tif (producers.has(anyProducer)) {\n\t\tconst item = Promise.all([eventName, eventData]);\n\t\tfor (const producer of producers.get(anyProducer)) {\n\t\t\tproducer.enqueue(item);\n\t\t}\n\t}\n}\n\nfunction iterator(instance, eventNames) {\n\teventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n\n\tlet isFinished = false;\n\tlet flush = () => {};\n\tlet queue = [];\n\n\tconst producer = {\n\t\tenqueue(item) {\n\t\t\tqueue.push(item);\n\t\t\tflush();\n\t\t},\n\t\tfinish() {\n\t\t\tisFinished = true;\n\t\t\tflush();\n\t\t}\n\t};\n\n\tfor (const eventName of eventNames) {\n\t\tgetEventProducers(instance, eventName).add(producer);\n\t}\n\n\treturn {\n\t\tasync next() {\n\t\t\tif (!queue) {\n\t\t\t\treturn {done: true};\n\t\t\t}\n\n\t\t\tif (queue.length === 0) {\n\t\t\t\tif (isFinished) {\n\t\t\t\t\tqueue = undefined;\n\t\t\t\t\treturn this.next();\n\t\t\t\t}\n\n\t\t\t\tawait new Promise(resolve => {\n\t\t\t\t\tflush = resolve;\n\t\t\t\t});\n\n\t\t\t\treturn this.next();\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdone: false,\n\t\t\t\tvalue: await queue.shift()\n\t\t\t};\n\t\t},\n\n\t\tasync return(value) {\n\t\t\tqueue = undefined;\n\n\t\t\tfor (const eventName of eventNames) {\n\t\t\t\tgetEventProducers(instance, eventName).delete(producer);\n\t\t\t}\n\n\t\t\tflush();\n\n\t\t\treturn arguments.length > 0 ?\n\t\t\t\t{done: true, value: await value} :\n\t\t\t\t{done: true};\n\t\t},\n\n\t\t[Symbol.asyncIterator]() {\n\t\t\treturn this;\n\t\t}\n\t};\n}\n\nfunction defaultMethodNamesOrAssert(methodNames) {\n\tif (methodNames === undefined) {\n\t\treturn allEmitteryMethods;\n\t}\n\n\tif (!Array.isArray(methodNames)) {\n\t\tthrow new TypeError('`methodNames` must be an array of strings');\n\t}\n\n\tfor (const methodName of methodNames) {\n\t\tif (!allEmitteryMethods.includes(methodName)) {\n\t\t\tif (typeof methodName !== 'string') {\n\t\t\t\tthrow new TypeError('`methodNames` element must be a string');\n\t\t\t}\n\n\t\t\tthrow new Error(`${methodName} is not Emittery method`);\n\t\t}\n\t}\n\n\treturn methodNames;\n}\n\nconst isListenerSymbol = symbol => symbol === listenerAdded || symbol === listenerRemoved;\n\nclass Emittery {\n\tstatic mixin(emitteryPropertyName, methodNames) {\n\t\tmethodNames = defaultMethodNamesOrAssert(methodNames);\n\t\treturn target => {\n\t\t\tif (typeof target !== 'function') {\n\t\t\t\tthrow new TypeError('`target` must be function');\n\t\t\t}\n\n\t\t\tfor (const methodName of methodNames) {\n\t\t\t\tif (target.prototype[methodName] !== undefined) {\n\t\t\t\t\tthrow new Error(`The property \\`${methodName}\\` already exists on \\`target\\``);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction getEmitteryProperty() {\n\t\t\t\tObject.defineProperty(this, emitteryPropertyName, {\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\tvalue: new Emittery()\n\t\t\t\t});\n\t\t\t\treturn this[emitteryPropertyName];\n\t\t\t}\n\n\t\t\tObject.defineProperty(target.prototype, emitteryPropertyName, {\n\t\t\t\tenumerable: false,\n\t\t\t\tget: getEmitteryProperty\n\t\t\t});\n\n\t\t\tconst emitteryMethodCaller = methodName => function (...args) {\n\t\t\t\treturn this[emitteryPropertyName][methodName](...args);\n\t\t\t};\n\n\t\t\tfor (const methodName of methodNames) {\n\t\t\t\tObject.defineProperty(target.prototype, methodName, {\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\tvalue: emitteryMethodCaller(methodName)\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn target;\n\t\t};\n\t}\n\n\tstatic get isDebugEnabled() {\n\t\tif (typeof process !== 'object') {\n\t\t\treturn isGlobalDebugEnabled;\n\t\t}\n\n\t\tconst {env} = process || {env: {}};\n\t\treturn env.DEBUG === 'emittery' || env.DEBUG === '*' || isGlobalDebugEnabled;\n\t}\n\n\tstatic set isDebugEnabled(newValue) {\n\t\tisGlobalDebugEnabled = newValue;\n\t}\n\n\tconstructor(options = {}) {\n\t\tanyMap.set(this, new Set());\n\t\teventsMap.set(this, new Map());\n\t\tproducersMap.set(this, new Map());\n\t\tthis.debug = options.debug || {};\n\n\t\tif (this.debug.enabled === undefined) {\n\t\t\tthis.debug.enabled = false;\n\t\t}\n\n\t\tif (!this.debug.logger) {\n\t\t\tthis.debug.logger = (type, debugName, eventName, eventData) => {\n\t\t\t\ttry {\n\t\t\t\t\t// TODO: Use https://github.com/sindresorhus/safe-stringify when the package is more mature. Just copy-paste the code.\n\t\t\t\t\teventData = JSON.stringify(eventData);\n\t\t\t\t} catch {\n\t\t\t\t\teventData = `Object with the following keys failed to stringify: ${Object.keys(eventData).join(',')}`;\n\t\t\t\t}\n\n\t\t\t\tif (typeof eventName === 'symbol') {\n\t\t\t\t\teventName = eventName.toString();\n\t\t\t\t}\n\n\t\t\t\tconst currentTime = new Date();\n\t\t\t\tconst logTime = `${currentTime.getHours()}:${currentTime.getMinutes()}:${currentTime.getSeconds()}.${currentTime.getMilliseconds()}`;\n\t\t\t\tconsole.log(`[${logTime}][emittery:${type}][${debugName}] Event Name: ${eventName}\\n\\tdata: ${eventData}`);\n\t\t\t};\n\t\t}\n\t}\n\n\tlogIfDebugEnabled(type, eventName, eventData) {\n\t\tif (Emittery.isDebugEnabled || this.debug.enabled) {\n\t\t\tthis.debug.logger(type, this.debug.name, eventName, eventData);\n\t\t}\n\t}\n\n\ton(eventNames, listener) {\n\t\tassertListener(listener);\n\n\t\teventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n\t\tfor (const eventName of eventNames) {\n\t\t\tassertEventName(eventName);\n\t\t\tgetListeners(this, eventName).add(listener);\n\n\t\t\tthis.logIfDebugEnabled('subscribe', eventName, undefined);\n\n\t\t\tif (!isListenerSymbol(eventName)) {\n\t\t\t\tthis.emit(listenerAdded, {eventName, listener});\n\t\t\t}\n\t\t}\n\n\t\treturn this.off.bind(this, eventNames, listener);\n\t}\n\n\toff(eventNames, listener) {\n\t\tassertListener(listener);\n\n\t\teventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n\t\tfor (const eventName of eventNames) {\n\t\t\tassertEventName(eventName);\n\t\t\tgetListeners(this, eventName).delete(listener);\n\n\t\t\tthis.logIfDebugEnabled('unsubscribe', eventName, undefined);\n\n\t\t\tif (!isListenerSymbol(eventName)) {\n\t\t\t\tthis.emit(listenerRemoved, {eventName, listener});\n\t\t\t}\n\t\t}\n\t}\n\n\tonce(eventNames) {\n\t\treturn new Promise(resolve => {\n\t\t\tconst off = this.on(eventNames, data => {\n\t\t\t\toff();\n\t\t\t\tresolve(data);\n\t\t\t});\n\t\t});\n\t}\n\n\tevents(eventNames) {\n\t\teventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n\t\tfor (const eventName of eventNames) {\n\t\t\tassertEventName(eventName);\n\t\t}\n\n\t\treturn iterator(this, eventNames);\n\t}\n\n\tasync emit(eventName, eventData) {\n\t\tassertEventName(eventName);\n\n\t\tthis.logIfDebugEnabled('emit', eventName, eventData);\n\n\t\tenqueueProducers(this, eventName, eventData);\n\n\t\tconst listeners = getListeners(this, eventName);\n\t\tconst anyListeners = anyMap.get(this);\n\t\tconst staticListeners = [...listeners];\n\t\tconst staticAnyListeners = isListenerSymbol(eventName) ? [] : [...anyListeners];\n\n\t\tawait resolvedPromise;\n\t\tawait Promise.all([\n\t\t\t...staticListeners.map(async listener => {\n\t\t\t\tif (listeners.has(listener)) {\n\t\t\t\t\treturn listener(eventData);\n\t\t\t\t}\n\t\t\t}),\n\t\t\t...staticAnyListeners.map(async listener => {\n\t\t\t\tif (anyListeners.has(listener)) {\n\t\t\t\t\treturn listener(eventName, eventData);\n\t\t\t\t}\n\t\t\t})\n\t\t]);\n\t}\n\n\tasync emitSerial(eventName, eventData) {\n\t\tassertEventName(eventName);\n\n\t\tthis.logIfDebugEnabled('emitSerial', eventName, eventData);\n\n\t\tconst listeners = getListeners(this, eventName);\n\t\tconst anyListeners = anyMap.get(this);\n\t\tconst staticListeners = [...listeners];\n\t\tconst staticAnyListeners = [...anyListeners];\n\n\t\tawait resolvedPromise;\n\t\t/* eslint-disable no-await-in-loop */\n\t\tfor (const listener of staticListeners) {\n\t\t\tif (listeners.has(listener)) {\n\t\t\t\tawait listener(eventData);\n\t\t\t}\n\t\t}\n\n\t\tfor (const listener of staticAnyListeners) {\n\t\t\tif (anyListeners.has(listener)) {\n\t\t\t\tawait listener(eventName, eventData);\n\t\t\t}\n\t\t}\n\t\t/* eslint-enable no-await-in-loop */\n\t}\n\n\tonAny(listener) {\n\t\tassertListener(listener);\n\n\t\tthis.logIfDebugEnabled('subscribeAny', undefined, undefined);\n\n\t\tanyMap.get(this).add(listener);\n\t\tthis.emit(listenerAdded, {listener});\n\t\treturn this.offAny.bind(this, listener);\n\t}\n\n\tanyEvent() {\n\t\treturn iterator(this);\n\t}\n\n\toffAny(listener) {\n\t\tassertListener(listener);\n\n\t\tthis.logIfDebugEnabled('unsubscribeAny', undefined, undefined);\n\n\t\tthis.emit(listenerRemoved, {listener});\n\t\tanyMap.get(this).delete(listener);\n\t}\n\n\tclearListeners(eventNames) {\n\t\teventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n\n\t\tfor (const eventName of eventNames) {\n\t\t\tthis.logIfDebugEnabled('clear', eventName, undefined);\n\n\t\t\tif (typeof eventName === 'string' || typeof eventName === 'symbol') {\n\t\t\t\tgetListeners(this, eventName).clear();\n\n\t\t\t\tconst producers = getEventProducers(this, eventName);\n\n\t\t\t\tfor (const producer of producers) {\n\t\t\t\t\tproducer.finish();\n\t\t\t\t}\n\n\t\t\t\tproducers.clear();\n\t\t\t} else {\n\t\t\t\tanyMap.get(this).clear();\n\n\t\t\t\tfor (const listeners of eventsMap.get(this).values()) {\n\t\t\t\t\tlisteners.clear();\n\t\t\t\t}\n\n\t\t\t\tfor (const producers of producersMap.get(this).values()) {\n\t\t\t\t\tfor (const producer of producers) {\n\t\t\t\t\t\tproducer.finish();\n\t\t\t\t\t}\n\n\t\t\t\t\tproducers.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlistenerCount(eventNames) {\n\t\teventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n\t\tlet count = 0;\n\n\t\tfor (const eventName of eventNames) {\n\t\t\tif (typeof eventName === 'string') {\n\t\t\t\tcount += anyMap.get(this).size + getListeners(this, eventName).size +\n\t\t\t\t\tgetEventProducers(this, eventName).size + getEventProducers(this).size;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (typeof eventName !== 'undefined') {\n\t\t\t\tassertEventName(eventName);\n\t\t\t}\n\n\t\t\tcount += anyMap.get(this).size;\n\n\t\t\tfor (const value of eventsMap.get(this).values()) {\n\t\t\t\tcount += value.size;\n\t\t\t}\n\n\t\t\tfor (const value of producersMap.get(this).values()) {\n\t\t\t\tcount += value.size;\n\t\t\t}\n\t\t}\n\n\t\treturn count;\n\t}\n\n\tbindMethods(target, methodNames) {\n\t\tif (typeof target !== 'object' || target === null) {\n\t\t\tthrow new TypeError('`target` must be an object');\n\t\t}\n\n\t\tmethodNames = defaultMethodNamesOrAssert(methodNames);\n\n\t\tfor (const methodName of methodNames) {\n\t\t\tif (target[methodName] !== undefined) {\n\t\t\t\tthrow new Error(`The property \\`${methodName}\\` already exists on \\`target\\``);\n\t\t\t}\n\n\t\t\tObject.defineProperty(target, methodName, {\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: this[methodName].bind(this)\n\t\t\t});\n\t\t}\n\t}\n}\n\nconst allEmitteryMethods = Object.getOwnPropertyNames(Emittery.prototype).filter(v => v !== 'constructor');\n\nObject.defineProperty(Emittery, 'listenerAdded', {\n\tvalue: listenerAdded,\n\twritable: false,\n\tenumerable: true,\n\tconfigurable: false\n});\nObject.defineProperty(Emittery, 'listenerRemoved', {\n\tvalue: listenerRemoved,\n\twritable: false,\n\tenumerable: true,\n\tconfigurable: false\n});\n\nmodule.exports = Emittery;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}