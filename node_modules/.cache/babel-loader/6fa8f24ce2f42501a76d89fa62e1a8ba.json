{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _v8Coverage() {\n  const data = require('@bcoe/v8-coverage');\n\n  _v8Coverage = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _glob() {\n  const data = _interopRequireDefault(require('glob'));\n\n  _glob = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fs() {\n  const data = _interopRequireWildcard(require('graceful-fs'));\n\n  fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulLibCoverage() {\n  const data = _interopRequireDefault(require('istanbul-lib-coverage'));\n\n  _istanbulLibCoverage = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulLibReport() {\n  const data = _interopRequireDefault(require('istanbul-lib-report'));\n\n  _istanbulLibReport = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulLibSourceMaps() {\n  const data = _interopRequireDefault(require('istanbul-lib-source-maps'));\n\n  _istanbulLibSourceMaps = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulReports() {\n  const data = _interopRequireDefault(require('istanbul-reports'));\n\n  _istanbulReports = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _v8ToIstanbul() {\n  const data = _interopRequireDefault(require('v8-to-istanbul'));\n\n  _v8ToIstanbul = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestWorker() {\n  const data = require('jest-worker');\n\n  _jestWorker = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _BaseReporter = _interopRequireDefault(require('./BaseReporter'));\n\nvar _getWatermarks = _interopRequireDefault(require('./getWatermarks'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst FAIL_COLOR = _chalk().default.bold.red;\n\nconst RUNNING_TEST_COLOR = _chalk().default.bold.dim;\n\nclass CoverageReporter extends _BaseReporter.default {\n  _context;\n  _coverageMap;\n  _globalConfig;\n  _sourceMapStore;\n  _v8CoverageResults;\n  static filename = __filename;\n\n  constructor(globalConfig, context) {\n    super();\n    this._context = context;\n    this._coverageMap = _istanbulLibCoverage().default.createCoverageMap({});\n    this._globalConfig = globalConfig;\n    this._sourceMapStore = _istanbulLibSourceMaps().default.createSourceMapStore();\n    this._v8CoverageResults = [];\n  }\n\n  onTestResult(_test, testResult) {\n    if (testResult.v8Coverage) {\n      this._v8CoverageResults.push(testResult.v8Coverage);\n\n      return;\n    }\n\n    if (testResult.coverage) {\n      this._coverageMap.merge(testResult.coverage);\n    }\n  }\n\n  async onRunComplete(testContexts, aggregatedResults) {\n    await this._addUntestedFiles(testContexts);\n    const {\n      map,\n      reportContext\n    } = await this._getCoverageResult();\n\n    try {\n      const coverageReporters = this._globalConfig.coverageReporters || [];\n\n      if (!this._globalConfig.useStderr && coverageReporters.length < 1) {\n        coverageReporters.push('text-summary');\n      }\n\n      coverageReporters.forEach(reporter => {\n        let additionalOptions = {};\n\n        if (Array.isArray(reporter)) {\n          [reporter, additionalOptions] = reporter;\n        }\n\n        _istanbulReports().default.create(reporter, {\n          maxCols: process.stdout.columns || Infinity,\n          ...additionalOptions\n        }).execute(reportContext);\n      });\n      aggregatedResults.coverageMap = map;\n    } catch (e) {\n      console.error(_chalk().default.red(`\n        Failed to write coverage reports:\n        ERROR: ${e.toString()}\n        STACK: ${e.stack}\n      `));\n    }\n\n    this._checkThreshold(map);\n  }\n\n  async _addUntestedFiles(testContexts) {\n    const files = [];\n    testContexts.forEach(context => {\n      const config = context.config;\n\n      if (this._globalConfig.collectCoverageFrom && this._globalConfig.collectCoverageFrom.length) {\n        context.hasteFS.matchFilesWithGlob(this._globalConfig.collectCoverageFrom, config.rootDir).forEach(filePath => files.push({\n          config,\n          path: filePath\n        }));\n      }\n    });\n\n    if (!files.length) {\n      return;\n    }\n\n    if (_jestUtil().isInteractive) {\n      process.stderr.write(RUNNING_TEST_COLOR('Running coverage on untested files...'));\n    }\n\n    let worker;\n\n    if (this._globalConfig.maxWorkers <= 1) {\n      worker = require('./CoverageWorker');\n    } else {\n      worker = new (_jestWorker().Worker)(require.resolve('./CoverageWorker'), {\n        exposedMethods: ['worker'],\n        // @ts-expect-error: option does not exist on the node 12 types\n        forkOptions: {\n          serialization: 'json'\n        },\n        maxRetries: 2,\n        numWorkers: this._globalConfig.maxWorkers\n      });\n    }\n\n    const instrumentation = files.map(async fileObj => {\n      const filename = fileObj.path;\n      const config = fileObj.config;\n\n      const hasCoverageData = this._v8CoverageResults.some(v8Res => v8Res.some(innerRes => innerRes.result.url === filename));\n\n      if (!hasCoverageData && !this._coverageMap.data[filename] && 'worker' in worker) {\n        try {\n          const result = await worker.worker({\n            config,\n            context: {\n              changedFiles: this._context.changedFiles && Array.from(this._context.changedFiles),\n              sourcesRelatedToTestsInChangedFiles: this._context.sourcesRelatedToTestsInChangedFiles && Array.from(this._context.sourcesRelatedToTestsInChangedFiles)\n            },\n            globalConfig: this._globalConfig,\n            path: filename\n          });\n\n          if (result) {\n            if (result.kind === 'V8Coverage') {\n              this._v8CoverageResults.push([{\n                codeTransformResult: undefined,\n                result: result.result\n              }]);\n            } else {\n              this._coverageMap.addFileCoverage(result.coverage);\n            }\n          }\n        } catch (error) {\n          console.error(_chalk().default.red([`Failed to collect coverage from ${filename}`, `ERROR: ${error.message}`, `STACK: ${error.stack}`].join('\\n')));\n        }\n      }\n    });\n\n    try {\n      await Promise.all(instrumentation);\n    } catch {// Do nothing; errors were reported earlier to the console.\n    }\n\n    if (_jestUtil().isInteractive) {\n      (0, _jestUtil().clearLine)(process.stderr);\n    }\n\n    if (worker && 'end' in worker && typeof worker.end === 'function') {\n      await worker.end();\n    }\n  }\n\n  _checkThreshold(map) {\n    const {\n      coverageThreshold\n    } = this._globalConfig;\n\n    if (coverageThreshold) {\n      function check(name, thresholds, actuals) {\n        return ['statements', 'branches', 'lines', 'functions'].reduce((errors, key) => {\n          const actual = actuals[key].pct;\n          const actualUncovered = actuals[key].total - actuals[key].covered;\n          const threshold = thresholds[key];\n\n          if (threshold !== undefined) {\n            if (threshold < 0) {\n              if (threshold * -1 < actualUncovered) {\n                errors.push(`Jest: Uncovered count for ${key} (${actualUncovered}) ` + `exceeds ${name} threshold (${-1 * threshold})`);\n              }\n            } else if (actual < threshold) {\n              errors.push(`Jest: \"${name}\" coverage threshold for ${key} (${threshold}%) not met: ${actual}%`);\n            }\n          }\n\n          return errors;\n        }, []);\n      }\n\n      const THRESHOLD_GROUP_TYPES = {\n        GLOB: 'glob',\n        GLOBAL: 'global',\n        PATH: 'path'\n      };\n      const coveredFiles = map.files();\n      const thresholdGroups = Object.keys(coverageThreshold);\n      const groupTypeByThresholdGroup = {};\n      const filesByGlob = {};\n      const coveredFilesSortedIntoThresholdGroup = coveredFiles.reduce((files, file) => {\n        const pathOrGlobMatches = thresholdGroups.reduce((agg, thresholdGroup) => {\n          // Preserve trailing slash, but not required if root dir\n          // See https://github.com/facebook/jest/issues/12703\n          const resolvedThresholdGroup = path().resolve(thresholdGroup);\n          const suffix = (thresholdGroup.endsWith(path().sep) || process.platform === 'win32' && thresholdGroup.endsWith('/')) && !resolvedThresholdGroup.endsWith(path().sep) ? path().sep : '';\n          const absoluteThresholdGroup = `${resolvedThresholdGroup}${suffix}`; // The threshold group might be a path:\n\n          if (file.indexOf(absoluteThresholdGroup) === 0) {\n            groupTypeByThresholdGroup[thresholdGroup] = THRESHOLD_GROUP_TYPES.PATH;\n            return agg.concat([[file, thresholdGroup]]);\n          } // If the threshold group is not a path it might be a glob:\n          // Note: glob.sync is slow. By memoizing the files matching each glob\n          // (rather than recalculating it for each covered file) we save a tonne\n          // of execution time.\n\n\n          if (filesByGlob[absoluteThresholdGroup] === undefined) {\n            filesByGlob[absoluteThresholdGroup] = _glob().default.sync(absoluteThresholdGroup).map(filePath => path().resolve(filePath));\n          }\n\n          if (filesByGlob[absoluteThresholdGroup].indexOf(file) > -1) {\n            groupTypeByThresholdGroup[thresholdGroup] = THRESHOLD_GROUP_TYPES.GLOB;\n            return agg.concat([[file, thresholdGroup]]);\n          }\n\n          return agg;\n        }, []);\n\n        if (pathOrGlobMatches.length > 0) {\n          return files.concat(pathOrGlobMatches);\n        } // Neither a glob or a path? Toss it in global if there's a global threshold:\n\n\n        if (thresholdGroups.indexOf(THRESHOLD_GROUP_TYPES.GLOBAL) > -1) {\n          groupTypeByThresholdGroup[THRESHOLD_GROUP_TYPES.GLOBAL] = THRESHOLD_GROUP_TYPES.GLOBAL;\n          return files.concat([[file, THRESHOLD_GROUP_TYPES.GLOBAL]]);\n        } // A covered file that doesn't have a threshold:\n\n\n        return files.concat([[file, undefined]]);\n      }, []);\n\n      const getFilesInThresholdGroup = thresholdGroup => coveredFilesSortedIntoThresholdGroup.filter(fileAndGroup => fileAndGroup[1] === thresholdGroup).map(fileAndGroup => fileAndGroup[0]);\n\n      function combineCoverage(filePaths) {\n        return filePaths.map(filePath => map.fileCoverageFor(filePath)).reduce((combinedCoverage, nextFileCoverage) => {\n          if (combinedCoverage === undefined || combinedCoverage === null) {\n            return nextFileCoverage.toSummary();\n          }\n\n          return combinedCoverage.merge(nextFileCoverage.toSummary());\n        }, undefined);\n      }\n\n      let errors = [];\n      thresholdGroups.forEach(thresholdGroup => {\n        switch (groupTypeByThresholdGroup[thresholdGroup]) {\n          case THRESHOLD_GROUP_TYPES.GLOBAL:\n            {\n              const coverage = combineCoverage(getFilesInThresholdGroup(THRESHOLD_GROUP_TYPES.GLOBAL));\n\n              if (coverage) {\n                errors = errors.concat(check(thresholdGroup, coverageThreshold[thresholdGroup], coverage));\n              }\n\n              break;\n            }\n\n          case THRESHOLD_GROUP_TYPES.PATH:\n            {\n              const coverage = combineCoverage(getFilesInThresholdGroup(thresholdGroup));\n\n              if (coverage) {\n                errors = errors.concat(check(thresholdGroup, coverageThreshold[thresholdGroup], coverage));\n              }\n\n              break;\n            }\n\n          case THRESHOLD_GROUP_TYPES.GLOB:\n            getFilesInThresholdGroup(thresholdGroup).forEach(fileMatchingGlob => {\n              errors = errors.concat(check(fileMatchingGlob, coverageThreshold[thresholdGroup], map.fileCoverageFor(fileMatchingGlob).toSummary()));\n            });\n            break;\n\n          default:\n            // If the file specified by path is not found, error is returned.\n            if (thresholdGroup !== THRESHOLD_GROUP_TYPES.GLOBAL) {\n              errors = errors.concat(`Jest: Coverage data for ${thresholdGroup} was not found.`);\n            }\n\n          // Sometimes all files in the coverage data are matched by\n          // PATH and GLOB threshold groups in which case, don't error when\n          // the global threshold group doesn't match any files.\n        }\n      });\n      errors = errors.filter(err => err !== undefined && err !== null && err.length > 0);\n\n      if (errors.length > 0) {\n        this.log(`${FAIL_COLOR(errors.join('\\n'))}`);\n\n        this._setError(new Error(errors.join('\\n')));\n      }\n    }\n  }\n\n  async _getCoverageResult() {\n    if (this._globalConfig.coverageProvider === 'v8') {\n      const mergedCoverages = (0, _v8Coverage().mergeProcessCovs)(this._v8CoverageResults.map(cov => ({\n        result: cov.map(r => r.result)\n      })));\n      const fileTransforms = new Map();\n\n      this._v8CoverageResults.forEach(res => res.forEach(r => {\n        if (r.codeTransformResult && !fileTransforms.has(r.result.url)) {\n          fileTransforms.set(r.result.url, r.codeTransformResult);\n        }\n      }));\n\n      const transformedCoverage = await Promise.all(mergedCoverages.result.map(async res => {\n        var _fileTransform$wrappe;\n\n        const fileTransform = fileTransforms.get(res.url);\n        let sourcemapContent = undefined;\n\n        if (fileTransform !== null && fileTransform !== void 0 && fileTransform.sourceMapPath && fs().existsSync(fileTransform.sourceMapPath)) {\n          sourcemapContent = JSON.parse(fs().readFileSync(fileTransform.sourceMapPath, 'utf8'));\n        }\n\n        const converter = (0, _v8ToIstanbul().default)(res.url, (_fileTransform$wrappe = fileTransform === null || fileTransform === void 0 ? void 0 : fileTransform.wrapperLength) !== null && _fileTransform$wrappe !== void 0 ? _fileTransform$wrappe : 0, fileTransform && sourcemapContent ? {\n          originalSource: fileTransform.originalCode,\n          source: fileTransform.code,\n          sourceMap: {\n            sourcemap: {\n              file: res.url,\n              ...sourcemapContent\n            }\n          }\n        } : {\n          source: fs().readFileSync(res.url, 'utf8')\n        });\n        await converter.load();\n        converter.applyCoverage(res.functions);\n        const istanbulData = converter.toIstanbul();\n        return istanbulData;\n      }));\n\n      const map = _istanbulLibCoverage().default.createCoverageMap({});\n\n      transformedCoverage.forEach(res => map.merge(res));\n\n      const reportContext = _istanbulLibReport().default.createContext({\n        coverageMap: map,\n        dir: this._globalConfig.coverageDirectory,\n        watermarks: (0, _getWatermarks.default)(this._globalConfig)\n      });\n\n      return {\n        map,\n        reportContext\n      };\n    }\n\n    const map = await this._sourceMapStore.transformCoverage(this._coverageMap);\n\n    const reportContext = _istanbulLibReport().default.createContext({\n      coverageMap: map,\n      dir: this._globalConfig.coverageDirectory,\n      sourceFinder: this._sourceMapStore.sourceFinder,\n      watermarks: (0, _getWatermarks.default)(this._globalConfig)\n    });\n\n    return {\n      map,\n      reportContext\n    };\n  }\n\n}\n\nexports.default = CoverageReporter;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","path","data","_interopRequireWildcard","require","_v8Coverage","_chalk","_interopRequireDefault","_glob","fs","_istanbulLibCoverage","_istanbulLibReport","_istanbulLibSourceMaps","_istanbulReports","_v8ToIstanbul","_jestUtil","_jestWorker","_BaseReporter","_getWatermarks","obj","__esModule","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","FAIL_COLOR","bold","red","RUNNING_TEST_COLOR","dim","CoverageReporter","_context","_coverageMap","_globalConfig","_sourceMapStore","_v8CoverageResults","filename","__filename","constructor","globalConfig","context","createCoverageMap","createSourceMapStore","onTestResult","_test","testResult","v8Coverage","push","coverage","merge","onRunComplete","testContexts","aggregatedResults","_addUntestedFiles","map","reportContext","_getCoverageResult","coverageReporters","useStderr","length","forEach","reporter","additionalOptions","Array","isArray","create","maxCols","process","stdout","columns","Infinity","execute","coverageMap","e","console","error","toString","stack","_checkThreshold","files","config","collectCoverageFrom","hasteFS","matchFilesWithGlob","rootDir","filePath","isInteractive","stderr","write","worker","maxWorkers","Worker","resolve","exposedMethods","forkOptions","serialization","maxRetries","numWorkers","instrumentation","fileObj","hasCoverageData","some","v8Res","innerRes","result","url","changedFiles","from","sourcesRelatedToTestsInChangedFiles","kind","codeTransformResult","undefined","addFileCoverage","message","join","Promise","all","clearLine","end","coverageThreshold","check","name","thresholds","actuals","reduce","errors","actual","pct","actualUncovered","total","covered","threshold","THRESHOLD_GROUP_TYPES","GLOB","GLOBAL","PATH","coveredFiles","thresholdGroups","keys","groupTypeByThresholdGroup","filesByGlob","coveredFilesSortedIntoThresholdGroup","file","pathOrGlobMatches","agg","thresholdGroup","resolvedThresholdGroup","suffix","endsWith","sep","platform","absoluteThresholdGroup","indexOf","concat","sync","getFilesInThresholdGroup","filter","fileAndGroup","combineCoverage","filePaths","fileCoverageFor","combinedCoverage","nextFileCoverage","toSummary","fileMatchingGlob","err","log","_setError","Error","coverageProvider","mergedCoverages","mergeProcessCovs","cov","r","fileTransforms","Map","res","transformedCoverage","_fileTransform$wrappe","fileTransform","sourcemapContent","sourceMapPath","existsSync","JSON","parse","readFileSync","converter","wrapperLength","originalSource","originalCode","source","code","sourceMap","sourcemap","load","applyCoverage","functions","istanbulData","toIstanbul","createContext","dir","coverageDirectory","watermarks","transformCoverage","sourceFinder"],"sources":["/Users/wonjaelee/Desktop/final/node_modules/@jest/reporters/build/CoverageReporter.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _v8Coverage() {\n  const data = require('@bcoe/v8-coverage');\n\n  _v8Coverage = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _glob() {\n  const data = _interopRequireDefault(require('glob'));\n\n  _glob = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fs() {\n  const data = _interopRequireWildcard(require('graceful-fs'));\n\n  fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulLibCoverage() {\n  const data = _interopRequireDefault(require('istanbul-lib-coverage'));\n\n  _istanbulLibCoverage = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulLibReport() {\n  const data = _interopRequireDefault(require('istanbul-lib-report'));\n\n  _istanbulLibReport = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulLibSourceMaps() {\n  const data = _interopRequireDefault(require('istanbul-lib-source-maps'));\n\n  _istanbulLibSourceMaps = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulReports() {\n  const data = _interopRequireDefault(require('istanbul-reports'));\n\n  _istanbulReports = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _v8ToIstanbul() {\n  const data = _interopRequireDefault(require('v8-to-istanbul'));\n\n  _v8ToIstanbul = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestWorker() {\n  const data = require('jest-worker');\n\n  _jestWorker = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _BaseReporter = _interopRequireDefault(require('./BaseReporter'));\n\nvar _getWatermarks = _interopRequireDefault(require('./getWatermarks'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst FAIL_COLOR = _chalk().default.bold.red;\n\nconst RUNNING_TEST_COLOR = _chalk().default.bold.dim;\n\nclass CoverageReporter extends _BaseReporter.default {\n  _context;\n  _coverageMap;\n  _globalConfig;\n  _sourceMapStore;\n  _v8CoverageResults;\n  static filename = __filename;\n\n  constructor(globalConfig, context) {\n    super();\n    this._context = context;\n    this._coverageMap = _istanbulLibCoverage().default.createCoverageMap({});\n    this._globalConfig = globalConfig;\n    this._sourceMapStore =\n      _istanbulLibSourceMaps().default.createSourceMapStore();\n    this._v8CoverageResults = [];\n  }\n\n  onTestResult(_test, testResult) {\n    if (testResult.v8Coverage) {\n      this._v8CoverageResults.push(testResult.v8Coverage);\n\n      return;\n    }\n\n    if (testResult.coverage) {\n      this._coverageMap.merge(testResult.coverage);\n    }\n  }\n\n  async onRunComplete(testContexts, aggregatedResults) {\n    await this._addUntestedFiles(testContexts);\n    const {map, reportContext} = await this._getCoverageResult();\n\n    try {\n      const coverageReporters = this._globalConfig.coverageReporters || [];\n\n      if (!this._globalConfig.useStderr && coverageReporters.length < 1) {\n        coverageReporters.push('text-summary');\n      }\n\n      coverageReporters.forEach(reporter => {\n        let additionalOptions = {};\n\n        if (Array.isArray(reporter)) {\n          [reporter, additionalOptions] = reporter;\n        }\n\n        _istanbulReports()\n          .default.create(reporter, {\n            maxCols: process.stdout.columns || Infinity,\n            ...additionalOptions\n          })\n          .execute(reportContext);\n      });\n      aggregatedResults.coverageMap = map;\n    } catch (e) {\n      console.error(\n        _chalk().default.red(`\n        Failed to write coverage reports:\n        ERROR: ${e.toString()}\n        STACK: ${e.stack}\n      `)\n      );\n    }\n\n    this._checkThreshold(map);\n  }\n\n  async _addUntestedFiles(testContexts) {\n    const files = [];\n    testContexts.forEach(context => {\n      const config = context.config;\n\n      if (\n        this._globalConfig.collectCoverageFrom &&\n        this._globalConfig.collectCoverageFrom.length\n      ) {\n        context.hasteFS\n          .matchFilesWithGlob(\n            this._globalConfig.collectCoverageFrom,\n            config.rootDir\n          )\n          .forEach(filePath =>\n            files.push({\n              config,\n              path: filePath\n            })\n          );\n      }\n    });\n\n    if (!files.length) {\n      return;\n    }\n\n    if (_jestUtil().isInteractive) {\n      process.stderr.write(\n        RUNNING_TEST_COLOR('Running coverage on untested files...')\n      );\n    }\n\n    let worker;\n\n    if (this._globalConfig.maxWorkers <= 1) {\n      worker = require('./CoverageWorker');\n    } else {\n      worker = new (_jestWorker().Worker)(require.resolve('./CoverageWorker'), {\n        exposedMethods: ['worker'],\n        // @ts-expect-error: option does not exist on the node 12 types\n        forkOptions: {\n          serialization: 'json'\n        },\n        maxRetries: 2,\n        numWorkers: this._globalConfig.maxWorkers\n      });\n    }\n\n    const instrumentation = files.map(async fileObj => {\n      const filename = fileObj.path;\n      const config = fileObj.config;\n\n      const hasCoverageData = this._v8CoverageResults.some(v8Res =>\n        v8Res.some(innerRes => innerRes.result.url === filename)\n      );\n\n      if (\n        !hasCoverageData &&\n        !this._coverageMap.data[filename] &&\n        'worker' in worker\n      ) {\n        try {\n          const result = await worker.worker({\n            config,\n            context: {\n              changedFiles:\n                this._context.changedFiles &&\n                Array.from(this._context.changedFiles),\n              sourcesRelatedToTestsInChangedFiles:\n                this._context.sourcesRelatedToTestsInChangedFiles &&\n                Array.from(this._context.sourcesRelatedToTestsInChangedFiles)\n            },\n            globalConfig: this._globalConfig,\n            path: filename\n          });\n\n          if (result) {\n            if (result.kind === 'V8Coverage') {\n              this._v8CoverageResults.push([\n                {\n                  codeTransformResult: undefined,\n                  result: result.result\n                }\n              ]);\n            } else {\n              this._coverageMap.addFileCoverage(result.coverage);\n            }\n          }\n        } catch (error) {\n          console.error(\n            _chalk().default.red(\n              [\n                `Failed to collect coverage from ${filename}`,\n                `ERROR: ${error.message}`,\n                `STACK: ${error.stack}`\n              ].join('\\n')\n            )\n          );\n        }\n      }\n    });\n\n    try {\n      await Promise.all(instrumentation);\n    } catch {\n      // Do nothing; errors were reported earlier to the console.\n    }\n\n    if (_jestUtil().isInteractive) {\n      (0, _jestUtil().clearLine)(process.stderr);\n    }\n\n    if (worker && 'end' in worker && typeof worker.end === 'function') {\n      await worker.end();\n    }\n  }\n\n  _checkThreshold(map) {\n    const {coverageThreshold} = this._globalConfig;\n\n    if (coverageThreshold) {\n      function check(name, thresholds, actuals) {\n        return ['statements', 'branches', 'lines', 'functions'].reduce(\n          (errors, key) => {\n            const actual = actuals[key].pct;\n            const actualUncovered = actuals[key].total - actuals[key].covered;\n            const threshold = thresholds[key];\n\n            if (threshold !== undefined) {\n              if (threshold < 0) {\n                if (threshold * -1 < actualUncovered) {\n                  errors.push(\n                    `Jest: Uncovered count for ${key} (${actualUncovered}) ` +\n                      `exceeds ${name} threshold (${-1 * threshold})`\n                  );\n                }\n              } else if (actual < threshold) {\n                errors.push(\n                  `Jest: \"${name}\" coverage threshold for ${key} (${threshold}%) not met: ${actual}%`\n                );\n              }\n            }\n\n            return errors;\n          },\n          []\n        );\n      }\n\n      const THRESHOLD_GROUP_TYPES = {\n        GLOB: 'glob',\n        GLOBAL: 'global',\n        PATH: 'path'\n      };\n      const coveredFiles = map.files();\n      const thresholdGroups = Object.keys(coverageThreshold);\n      const groupTypeByThresholdGroup = {};\n      const filesByGlob = {};\n      const coveredFilesSortedIntoThresholdGroup = coveredFiles.reduce(\n        (files, file) => {\n          const pathOrGlobMatches = thresholdGroups.reduce(\n            (agg, thresholdGroup) => {\n              // Preserve trailing slash, but not required if root dir\n              // See https://github.com/facebook/jest/issues/12703\n              const resolvedThresholdGroup = path().resolve(thresholdGroup);\n              const suffix =\n                (thresholdGroup.endsWith(path().sep) ||\n                  (process.platform === 'win32' &&\n                    thresholdGroup.endsWith('/'))) &&\n                !resolvedThresholdGroup.endsWith(path().sep)\n                  ? path().sep\n                  : '';\n              const absoluteThresholdGroup = `${resolvedThresholdGroup}${suffix}`; // The threshold group might be a path:\n\n              if (file.indexOf(absoluteThresholdGroup) === 0) {\n                groupTypeByThresholdGroup[thresholdGroup] =\n                  THRESHOLD_GROUP_TYPES.PATH;\n                return agg.concat([[file, thresholdGroup]]);\n              } // If the threshold group is not a path it might be a glob:\n              // Note: glob.sync is slow. By memoizing the files matching each glob\n              // (rather than recalculating it for each covered file) we save a tonne\n              // of execution time.\n\n              if (filesByGlob[absoluteThresholdGroup] === undefined) {\n                filesByGlob[absoluteThresholdGroup] = _glob()\n                  .default.sync(absoluteThresholdGroup)\n                  .map(filePath => path().resolve(filePath));\n              }\n\n              if (filesByGlob[absoluteThresholdGroup].indexOf(file) > -1) {\n                groupTypeByThresholdGroup[thresholdGroup] =\n                  THRESHOLD_GROUP_TYPES.GLOB;\n                return agg.concat([[file, thresholdGroup]]);\n              }\n\n              return agg;\n            },\n            []\n          );\n\n          if (pathOrGlobMatches.length > 0) {\n            return files.concat(pathOrGlobMatches);\n          } // Neither a glob or a path? Toss it in global if there's a global threshold:\n\n          if (thresholdGroups.indexOf(THRESHOLD_GROUP_TYPES.GLOBAL) > -1) {\n            groupTypeByThresholdGroup[THRESHOLD_GROUP_TYPES.GLOBAL] =\n              THRESHOLD_GROUP_TYPES.GLOBAL;\n            return files.concat([[file, THRESHOLD_GROUP_TYPES.GLOBAL]]);\n          } // A covered file that doesn't have a threshold:\n\n          return files.concat([[file, undefined]]);\n        },\n        []\n      );\n\n      const getFilesInThresholdGroup = thresholdGroup =>\n        coveredFilesSortedIntoThresholdGroup\n          .filter(fileAndGroup => fileAndGroup[1] === thresholdGroup)\n          .map(fileAndGroup => fileAndGroup[0]);\n\n      function combineCoverage(filePaths) {\n        return filePaths\n          .map(filePath => map.fileCoverageFor(filePath))\n          .reduce((combinedCoverage, nextFileCoverage) => {\n            if (combinedCoverage === undefined || combinedCoverage === null) {\n              return nextFileCoverage.toSummary();\n            }\n\n            return combinedCoverage.merge(nextFileCoverage.toSummary());\n          }, undefined);\n      }\n\n      let errors = [];\n      thresholdGroups.forEach(thresholdGroup => {\n        switch (groupTypeByThresholdGroup[thresholdGroup]) {\n          case THRESHOLD_GROUP_TYPES.GLOBAL: {\n            const coverage = combineCoverage(\n              getFilesInThresholdGroup(THRESHOLD_GROUP_TYPES.GLOBAL)\n            );\n\n            if (coverage) {\n              errors = errors.concat(\n                check(\n                  thresholdGroup,\n                  coverageThreshold[thresholdGroup],\n                  coverage\n                )\n              );\n            }\n\n            break;\n          }\n\n          case THRESHOLD_GROUP_TYPES.PATH: {\n            const coverage = combineCoverage(\n              getFilesInThresholdGroup(thresholdGroup)\n            );\n\n            if (coverage) {\n              errors = errors.concat(\n                check(\n                  thresholdGroup,\n                  coverageThreshold[thresholdGroup],\n                  coverage\n                )\n              );\n            }\n\n            break;\n          }\n\n          case THRESHOLD_GROUP_TYPES.GLOB:\n            getFilesInThresholdGroup(thresholdGroup).forEach(\n              fileMatchingGlob => {\n                errors = errors.concat(\n                  check(\n                    fileMatchingGlob,\n                    coverageThreshold[thresholdGroup],\n                    map.fileCoverageFor(fileMatchingGlob).toSummary()\n                  )\n                );\n              }\n            );\n            break;\n\n          default:\n            // If the file specified by path is not found, error is returned.\n            if (thresholdGroup !== THRESHOLD_GROUP_TYPES.GLOBAL) {\n              errors = errors.concat(\n                `Jest: Coverage data for ${thresholdGroup} was not found.`\n              );\n            }\n\n          // Sometimes all files in the coverage data are matched by\n          // PATH and GLOB threshold groups in which case, don't error when\n          // the global threshold group doesn't match any files.\n        }\n      });\n      errors = errors.filter(\n        err => err !== undefined && err !== null && err.length > 0\n      );\n\n      if (errors.length > 0) {\n        this.log(`${FAIL_COLOR(errors.join('\\n'))}`);\n\n        this._setError(new Error(errors.join('\\n')));\n      }\n    }\n  }\n\n  async _getCoverageResult() {\n    if (this._globalConfig.coverageProvider === 'v8') {\n      const mergedCoverages = (0, _v8Coverage().mergeProcessCovs)(\n        this._v8CoverageResults.map(cov => ({\n          result: cov.map(r => r.result)\n        }))\n      );\n      const fileTransforms = new Map();\n\n      this._v8CoverageResults.forEach(res =>\n        res.forEach(r => {\n          if (r.codeTransformResult && !fileTransforms.has(r.result.url)) {\n            fileTransforms.set(r.result.url, r.codeTransformResult);\n          }\n        })\n      );\n\n      const transformedCoverage = await Promise.all(\n        mergedCoverages.result.map(async res => {\n          var _fileTransform$wrappe;\n\n          const fileTransform = fileTransforms.get(res.url);\n          let sourcemapContent = undefined;\n\n          if (\n            fileTransform !== null &&\n            fileTransform !== void 0 &&\n            fileTransform.sourceMapPath &&\n            fs().existsSync(fileTransform.sourceMapPath)\n          ) {\n            sourcemapContent = JSON.parse(\n              fs().readFileSync(fileTransform.sourceMapPath, 'utf8')\n            );\n          }\n\n          const converter = (0, _v8ToIstanbul().default)(\n            res.url,\n            (_fileTransform$wrappe =\n              fileTransform === null || fileTransform === void 0\n                ? void 0\n                : fileTransform.wrapperLength) !== null &&\n              _fileTransform$wrappe !== void 0\n              ? _fileTransform$wrappe\n              : 0,\n            fileTransform && sourcemapContent\n              ? {\n                  originalSource: fileTransform.originalCode,\n                  source: fileTransform.code,\n                  sourceMap: {\n                    sourcemap: {\n                      file: res.url,\n                      ...sourcemapContent\n                    }\n                  }\n                }\n              : {\n                  source: fs().readFileSync(res.url, 'utf8')\n                }\n          );\n          await converter.load();\n          converter.applyCoverage(res.functions);\n          const istanbulData = converter.toIstanbul();\n          return istanbulData;\n        })\n      );\n\n      const map = _istanbulLibCoverage().default.createCoverageMap({});\n\n      transformedCoverage.forEach(res => map.merge(res));\n\n      const reportContext = _istanbulLibReport().default.createContext({\n        coverageMap: map,\n        dir: this._globalConfig.coverageDirectory,\n        watermarks: (0, _getWatermarks.default)(this._globalConfig)\n      });\n\n      return {\n        map,\n        reportContext\n      };\n    }\n\n    const map = await this._sourceMapStore.transformCoverage(this._coverageMap);\n\n    const reportContext = _istanbulLibReport().default.createContext({\n      coverageMap: map,\n      dir: this._globalConfig.coverageDirectory,\n      sourceFinder: this._sourceMapStore.sourceFinder,\n      watermarks: (0, _getWatermarks.default)(this._globalConfig)\n    });\n\n    return {\n      map,\n      reportContext\n    };\n  }\n}\n\nexports.default = CoverageReporter;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}