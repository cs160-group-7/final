{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nObject.defineProperty(exports, 'EXTENSION', {\n  enumerable: true,\n  get: function () {\n    return _SnapshotResolver.EXTENSION;\n  }\n});\nObject.defineProperty(exports, 'SnapshotState', {\n  enumerable: true,\n  get: function () {\n    return _State.default;\n  }\n});\nObject.defineProperty(exports, 'addSerializer', {\n  enumerable: true,\n  get: function () {\n    return _plugins.addSerializer;\n  }\n});\nObject.defineProperty(exports, 'buildSnapshotResolver', {\n  enumerable: true,\n  get: function () {\n    return _SnapshotResolver.buildSnapshotResolver;\n  }\n});\nexports.cleanup = void 0;\nObject.defineProperty(exports, 'getSerializers', {\n  enumerable: true,\n  get: function () {\n    return _plugins.getSerializers;\n  }\n});\nObject.defineProperty(exports, 'isSnapshotPath', {\n  enumerable: true,\n  get: function () {\n    return _SnapshotResolver.isSnapshotPath;\n  }\n});\nexports.toThrowErrorMatchingSnapshot = exports.toThrowErrorMatchingInlineSnapshot = exports.toMatchSnapshot = exports.toMatchInlineSnapshot = void 0;\n\nvar fs = _interopRequireWildcard(require('graceful-fs'));\n\nvar _jestMatcherUtils = require('jest-matcher-utils');\n\nvar _SnapshotResolver = require('./SnapshotResolver');\n\nvar _printSnapshot = require('./printSnapshot');\n\nvar _utils = require('./utils');\n\nvar _plugins = require('./plugins');\n\nvar _State = _interopRequireDefault(require('./State'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nvar Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;\nvar Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;\nvar jestExistsFile = globalThis[Symbol.for('jest-native-exists-file')] || fs.existsSync;\nconst DID_NOT_THROW = 'Received function did not throw'; // same as toThrow\n\nconst NOT_SNAPSHOT_MATCHERS = `Snapshot matchers cannot be used with ${(0, _jestMatcherUtils.BOLD_WEIGHT)('not')}`;\nconst INDENTATION_REGEX = /^([^\\S\\n]*)\\S/m; // Display name in report when matcher fails same as in snapshot file,\n// but with optional hint argument in bold weight.\n\nconst printSnapshotName = function () {\n  let concatenatedBlockNames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  let hint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  let count = arguments.length > 2 ? arguments[2] : undefined;\n  const hasNames = concatenatedBlockNames.length !== 0;\n  const hasHint = hint.length !== 0;\n  return `Snapshot name: \\`${hasNames ? (0, _utils.escapeBacktickString)(concatenatedBlockNames) : ''}${hasNames && hasHint ? ': ' : ''}${hasHint ? (0, _jestMatcherUtils.BOLD_WEIGHT)((0, _utils.escapeBacktickString)(hint)) : ''} ${count}\\``;\n};\n\nfunction stripAddedIndentation(inlineSnapshot) {\n  // Find indentation if exists.\n  const match = inlineSnapshot.match(INDENTATION_REGEX);\n\n  if (!match || !match[1]) {\n    // No indentation.\n    return inlineSnapshot;\n  }\n\n  const indentation = match[1];\n  const lines = inlineSnapshot.split('\\n');\n\n  if (lines.length <= 2) {\n    // Must be at least 3 lines.\n    return inlineSnapshot;\n  }\n\n  if (lines[0].trim() !== '' || lines[lines.length - 1].trim() !== '') {\n    // If not blank first and last lines, abort.\n    return inlineSnapshot;\n  }\n\n  for (let i = 1; i < lines.length - 1; i++) {\n    if (lines[i] !== '') {\n      if (lines[i].indexOf(indentation) !== 0) {\n        // All lines except first and last should either be blank or have the same\n        // indent as the first line (or more). If this isn't the case we don't\n        // want to touch the snapshot at all.\n        return inlineSnapshot;\n      }\n\n      lines[i] = lines[i].substring(indentation.length);\n    }\n  } // Last line is a special case because it won't have the same indent as others\n  // but may still have been given some indent to line up.\n\n\n  lines[lines.length - 1] = ''; // Return inline snapshot, now at indent 0.\n\n  inlineSnapshot = lines.join('\\n');\n  return inlineSnapshot;\n}\n\nconst fileExists = (filePath, hasteFS) => hasteFS.exists(filePath) || jestExistsFile(filePath);\n\nconst cleanup = (hasteFS, update, snapshotResolver, testPathIgnorePatterns) => {\n  const pattern = `\\\\.${_SnapshotResolver.EXTENSION}$`;\n  const files = hasteFS.matchFiles(pattern);\n  let testIgnorePatternsRegex = null;\n\n  if (testPathIgnorePatterns && testPathIgnorePatterns.length > 0) {\n    testIgnorePatternsRegex = new RegExp(testPathIgnorePatterns.join('|'));\n  }\n\n  const list = files.filter(snapshotFile => {\n    const testPath = snapshotResolver.resolveTestPath(snapshotFile); // ignore snapshots of ignored tests\n\n    if (testIgnorePatternsRegex && testIgnorePatternsRegex.test(testPath)) {\n      return false;\n    }\n\n    if (!fileExists(testPath, hasteFS)) {\n      if (update === 'all') {\n        fs.unlinkSync(snapshotFile);\n      }\n\n      return true;\n    }\n\n    return false;\n  });\n  return {\n    filesRemoved: list.length,\n    filesRemovedList: list\n  };\n};\n\nexports.cleanup = cleanup;\n\nconst toMatchSnapshot = function (received, propertiesOrHint, hint) {\n  const matcherName = 'toMatchSnapshot';\n  let properties;\n  const length = arguments.length;\n\n  if (length === 2 && typeof propertiesOrHint === 'string') {\n    hint = propertiesOrHint;\n  } else if (length >= 2) {\n    if (typeof propertiesOrHint !== 'object' || propertiesOrHint === null) {\n      const options = {\n        isNot: this.isNot,\n        promise: this.promise\n      };\n      let printedWithType = (0, _jestMatcherUtils.printWithType)('Expected properties', propertiesOrHint, _printSnapshot.printExpected);\n\n      if (length === 3) {\n        options.secondArgument = 'hint';\n        options.secondArgumentColor = _jestMatcherUtils.BOLD_WEIGHT;\n\n        if (propertiesOrHint == null) {\n          printedWithType += \"\\n\\nTo provide a hint without properties: toMatchSnapshot('hint')\";\n        }\n      }\n\n      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, _printSnapshot.PROPERTIES_ARG, options), `Expected ${(0, _jestMatcherUtils.EXPECTED_COLOR)('properties')} must be an object`, printedWithType));\n    } // Future breaking change: Snapshot hint must be a string\n    // if (arguments.length === 3 && typeof hint !== 'string') {}\n\n\n    properties = propertiesOrHint;\n  }\n\n  return _toMatchSnapshot({\n    context: this,\n    hint,\n    isInline: false,\n    matcherName,\n    properties,\n    received\n  });\n};\n\nexports.toMatchSnapshot = toMatchSnapshot;\n\nconst toMatchInlineSnapshot = function (received, propertiesOrSnapshot, inlineSnapshot) {\n  const matcherName = 'toMatchInlineSnapshot';\n  let properties;\n  const length = arguments.length;\n\n  if (length === 2 && typeof propertiesOrSnapshot === 'string') {\n    inlineSnapshot = propertiesOrSnapshot;\n  } else if (length >= 2) {\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n\n    if (length === 3) {\n      options.secondArgument = _printSnapshot.SNAPSHOT_ARG;\n      options.secondArgumentColor = _printSnapshot.noColor;\n    }\n\n    if (typeof propertiesOrSnapshot !== 'object' || propertiesOrSnapshot === null) {\n      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, _printSnapshot.PROPERTIES_ARG, options), `Expected ${(0, _jestMatcherUtils.EXPECTED_COLOR)('properties')} must be an object`, (0, _jestMatcherUtils.printWithType)('Expected properties', propertiesOrSnapshot, _printSnapshot.printExpected)));\n    }\n\n    if (length === 3 && typeof inlineSnapshot !== 'string') {\n      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, _printSnapshot.PROPERTIES_ARG, options), 'Inline snapshot must be a string', (0, _jestMatcherUtils.printWithType)('Inline snapshot', inlineSnapshot, _utils.serialize)));\n    }\n\n    properties = propertiesOrSnapshot;\n  }\n\n  return _toMatchSnapshot({\n    context: this,\n    inlineSnapshot: inlineSnapshot !== undefined ? stripAddedIndentation(inlineSnapshot) : undefined,\n    isInline: true,\n    matcherName,\n    properties,\n    received\n  });\n};\n\nexports.toMatchInlineSnapshot = toMatchInlineSnapshot;\n\nconst _toMatchSnapshot = config => {\n  const {\n    context,\n    hint,\n    inlineSnapshot,\n    isInline,\n    matcherName,\n    properties\n  } = config;\n  let {\n    received\n  } = config;\n  context.dontThrow && context.dontThrow();\n  const {\n    currentTestName,\n    isNot,\n    snapshotState\n  } = context;\n\n  if (isNot) {\n    throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _printSnapshot.matcherHintFromConfig)(config, false), NOT_SNAPSHOT_MATCHERS));\n  }\n\n  if (snapshotState == null) {\n    // Because the state is the problem, this is not a matcher error.\n    // Call generic stringify from jest-matcher-utils package\n    // because uninitialized snapshot state does not need snapshot serializers.\n    throw new Error(`${(0, _printSnapshot.matcherHintFromConfig)(config, false)}\\n\\n` + 'Snapshot state must be initialized' + `\\n\\n${(0, _jestMatcherUtils.printWithType)('Snapshot state', snapshotState, _jestMatcherUtils.stringify)}`);\n  }\n\n  const fullTestName = currentTestName && hint ? `${currentTestName}: ${hint}` : currentTestName || ''; // future BREAKING change: || hint\n\n  if (typeof properties === 'object') {\n    if (typeof received !== 'object' || received === null) {\n      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _printSnapshot.matcherHintFromConfig)(config, false), `${(0, _jestMatcherUtils.RECEIVED_COLOR)('received')} value must be an object when the matcher has ${(0, _jestMatcherUtils.EXPECTED_COLOR)('properties')}`, (0, _jestMatcherUtils.printWithType)('Received', received, _printSnapshot.printReceived)));\n    }\n\n    const propertyPass = context.equals(received, properties, [context.utils.iterableEquality, context.utils.subsetEquality]);\n\n    if (!propertyPass) {\n      const key = snapshotState.fail(fullTestName, received);\n      const matched = /(\\d+)$/.exec(key);\n      const count = matched === null ? 1 : Number(matched[1]);\n\n      const message = () => `${(0, _printSnapshot.matcherHintFromConfig)(config, false)}\\n\\n${printSnapshotName(currentTestName, hint, count)}\\n\\n${(0, _printSnapshot.printPropertiesAndReceived)(properties, received, snapshotState.expand)}`;\n\n      return {\n        message,\n        name: matcherName,\n        pass: false\n      };\n    } else {\n      received = (0, _utils.deepMerge)(received, properties);\n    }\n  }\n\n  const result = snapshotState.match({\n    error: context.error,\n    inlineSnapshot,\n    isInline,\n    received,\n    testName: fullTestName\n  });\n  const {\n    actual,\n    count,\n    expected,\n    pass\n  } = result;\n\n  if (pass) {\n    return {\n      message: () => '',\n      pass: true\n    };\n  }\n\n  const message = expected === undefined ? () => `${(0, _printSnapshot.matcherHintFromConfig)(config, true)}\\n\\n${printSnapshotName(currentTestName, hint, count)}\\n\\n` + `New snapshot was ${(0, _jestMatcherUtils.BOLD_WEIGHT)('not written')}. The update flag ` + 'must be explicitly passed to write a new snapshot.\\n\\n' + 'This is likely because this test is run in a continuous integration ' + '(CI) environment in which snapshots are not written by default.\\n\\n' + `Received:${actual.includes('\\n') ? '\\n' : ' '}${(0, _printSnapshot.bReceivedColor)(actual)}` : () => `${(0, _printSnapshot.matcherHintFromConfig)(config, true)}\\n\\n${printSnapshotName(currentTestName, hint, count)}\\n\\n${(0, _printSnapshot.printSnapshotAndReceived)(expected, actual, received, snapshotState.expand)}`; // Passing the actual and expected objects so that a custom reporter\n  // could access them, for example in order to display a custom visual diff,\n  // or create a different error message\n\n  return {\n    actual,\n    expected,\n    message,\n    name: matcherName,\n    pass: false\n  };\n};\n\nconst toThrowErrorMatchingSnapshot = function (received, hint, fromPromise) {\n  const matcherName = 'toThrowErrorMatchingSnapshot'; // Future breaking change: Snapshot hint must be a string\n  // if (hint !== undefined && typeof hint !== string) {}\n\n  return _toThrowErrorMatchingSnapshot({\n    context: this,\n    hint,\n    isInline: false,\n    matcherName,\n    received\n  }, fromPromise);\n};\n\nexports.toThrowErrorMatchingSnapshot = toThrowErrorMatchingSnapshot;\n\nconst toThrowErrorMatchingInlineSnapshot = function (received, inlineSnapshot, fromPromise) {\n  const matcherName = 'toThrowErrorMatchingInlineSnapshot';\n\n  if (inlineSnapshot !== undefined && typeof inlineSnapshot !== 'string') {\n    const options = {\n      expectedColor: _printSnapshot.noColor,\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, _printSnapshot.SNAPSHOT_ARG, options), 'Inline snapshot must be a string', (0, _jestMatcherUtils.printWithType)('Inline snapshot', inlineSnapshot, _utils.serialize)));\n  }\n\n  return _toThrowErrorMatchingSnapshot({\n    context: this,\n    inlineSnapshot: inlineSnapshot !== undefined ? stripAddedIndentation(inlineSnapshot) : undefined,\n    isInline: true,\n    matcherName,\n    received\n  }, fromPromise);\n};\n\nexports.toThrowErrorMatchingInlineSnapshot = toThrowErrorMatchingInlineSnapshot;\n\nconst _toThrowErrorMatchingSnapshot = (config, fromPromise) => {\n  const {\n    context,\n    hint,\n    inlineSnapshot,\n    isInline,\n    matcherName,\n    received\n  } = config;\n  context.dontThrow && context.dontThrow();\n  const {\n    isNot,\n    promise\n  } = context;\n\n  if (!fromPromise) {\n    if (typeof received !== 'function') {\n      const options = {\n        isNot,\n        promise\n      };\n      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, '', options), `${(0, _jestMatcherUtils.RECEIVED_COLOR)('received')} value must be a function`, (0, _jestMatcherUtils.printWithType)('Received', received, _printSnapshot.printReceived)));\n    }\n  }\n\n  if (isNot) {\n    throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _printSnapshot.matcherHintFromConfig)(config, false), NOT_SNAPSHOT_MATCHERS));\n  }\n\n  let error;\n\n  if (fromPromise) {\n    error = received;\n  } else {\n    try {\n      received();\n    } catch (e) {\n      error = e;\n    }\n  }\n\n  if (error === undefined) {\n    // Because the received value is a function, this is not a matcher error.\n    throw new Error(`${(0, _printSnapshot.matcherHintFromConfig)(config, false)}\\n\\n${DID_NOT_THROW}`);\n  }\n\n  return _toMatchSnapshot({\n    context,\n    hint,\n    inlineSnapshot,\n    isInline,\n    matcherName,\n    received: error.message\n  });\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","_SnapshotResolver","EXTENSION","_State","default","_plugins","addSerializer","buildSnapshotResolver","cleanup","getSerializers","isSnapshotPath","toThrowErrorMatchingSnapshot","toThrowErrorMatchingInlineSnapshot","toMatchSnapshot","toMatchInlineSnapshot","fs","_interopRequireWildcard","require","_jestMatcherUtils","_printSnapshot","_utils","_interopRequireDefault","obj","__esModule","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","Symbol","globalThis","jestExistsFile","for","existsSync","DID_NOT_THROW","NOT_SNAPSHOT_MATCHERS","BOLD_WEIGHT","INDENTATION_REGEX","printSnapshotName","concatenatedBlockNames","hint","count","hasNames","length","hasHint","escapeBacktickString","stripAddedIndentation","inlineSnapshot","match","indentation","lines","split","trim","i","indexOf","substring","join","fileExists","filePath","hasteFS","exists","update","snapshotResolver","testPathIgnorePatterns","pattern","files","matchFiles","testIgnorePatternsRegex","RegExp","list","filter","snapshotFile","testPath","resolveTestPath","test","unlinkSync","filesRemoved","filesRemovedList","received","propertiesOrHint","matcherName","properties","arguments","options","isNot","promise","printedWithType","printWithType","printExpected","secondArgument","secondArgumentColor","Error","matcherErrorMessage","matcherHint","undefined","PROPERTIES_ARG","EXPECTED_COLOR","_toMatchSnapshot","context","isInline","propertiesOrSnapshot","SNAPSHOT_ARG","noColor","serialize","config","dontThrow","currentTestName","snapshotState","matcherHintFromConfig","stringify","fullTestName","RECEIVED_COLOR","printReceived","propertyPass","equals","utils","iterableEquality","subsetEquality","fail","matched","exec","Number","message","printPropertiesAndReceived","expand","name","pass","deepMerge","result","error","testName","actual","expected","includes","bReceivedColor","printSnapshotAndReceived","fromPromise","_toThrowErrorMatchingSnapshot","expectedColor","e"],"sources":["/Users/wonjaelee/Desktop/final/node_modules/jest-snapshot/build/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nObject.defineProperty(exports, 'EXTENSION', {\n  enumerable: true,\n  get: function () {\n    return _SnapshotResolver.EXTENSION;\n  }\n});\nObject.defineProperty(exports, 'SnapshotState', {\n  enumerable: true,\n  get: function () {\n    return _State.default;\n  }\n});\nObject.defineProperty(exports, 'addSerializer', {\n  enumerable: true,\n  get: function () {\n    return _plugins.addSerializer;\n  }\n});\nObject.defineProperty(exports, 'buildSnapshotResolver', {\n  enumerable: true,\n  get: function () {\n    return _SnapshotResolver.buildSnapshotResolver;\n  }\n});\nexports.cleanup = void 0;\nObject.defineProperty(exports, 'getSerializers', {\n  enumerable: true,\n  get: function () {\n    return _plugins.getSerializers;\n  }\n});\nObject.defineProperty(exports, 'isSnapshotPath', {\n  enumerable: true,\n  get: function () {\n    return _SnapshotResolver.isSnapshotPath;\n  }\n});\nexports.toThrowErrorMatchingSnapshot =\n  exports.toThrowErrorMatchingInlineSnapshot =\n  exports.toMatchSnapshot =\n  exports.toMatchInlineSnapshot =\n    void 0;\n\nvar fs = _interopRequireWildcard(require('graceful-fs'));\n\nvar _jestMatcherUtils = require('jest-matcher-utils');\n\nvar _SnapshotResolver = require('./SnapshotResolver');\n\nvar _printSnapshot = require('./printSnapshot');\n\nvar _utils = require('./utils');\n\nvar _plugins = require('./plugins');\n\nvar _State = _interopRequireDefault(require('./State'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\nvar Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;\nvar Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;\nvar jestExistsFile =\n  globalThis[Symbol.for('jest-native-exists-file')] || fs.existsSync;\nconst DID_NOT_THROW = 'Received function did not throw'; // same as toThrow\n\nconst NOT_SNAPSHOT_MATCHERS = `Snapshot matchers cannot be used with ${(0,\n_jestMatcherUtils.BOLD_WEIGHT)('not')}`;\nconst INDENTATION_REGEX = /^([^\\S\\n]*)\\S/m; // Display name in report when matcher fails same as in snapshot file,\n// but with optional hint argument in bold weight.\n\nconst printSnapshotName = (concatenatedBlockNames = '', hint = '', count) => {\n  const hasNames = concatenatedBlockNames.length !== 0;\n  const hasHint = hint.length !== 0;\n  return `Snapshot name: \\`${\n    hasNames ? (0, _utils.escapeBacktickString)(concatenatedBlockNames) : ''\n  }${hasNames && hasHint ? ': ' : ''}${\n    hasHint\n      ? (0, _jestMatcherUtils.BOLD_WEIGHT)(\n          (0, _utils.escapeBacktickString)(hint)\n        )\n      : ''\n  } ${count}\\``;\n};\n\nfunction stripAddedIndentation(inlineSnapshot) {\n  // Find indentation if exists.\n  const match = inlineSnapshot.match(INDENTATION_REGEX);\n\n  if (!match || !match[1]) {\n    // No indentation.\n    return inlineSnapshot;\n  }\n\n  const indentation = match[1];\n  const lines = inlineSnapshot.split('\\n');\n\n  if (lines.length <= 2) {\n    // Must be at least 3 lines.\n    return inlineSnapshot;\n  }\n\n  if (lines[0].trim() !== '' || lines[lines.length - 1].trim() !== '') {\n    // If not blank first and last lines, abort.\n    return inlineSnapshot;\n  }\n\n  for (let i = 1; i < lines.length - 1; i++) {\n    if (lines[i] !== '') {\n      if (lines[i].indexOf(indentation) !== 0) {\n        // All lines except first and last should either be blank or have the same\n        // indent as the first line (or more). If this isn't the case we don't\n        // want to touch the snapshot at all.\n        return inlineSnapshot;\n      }\n\n      lines[i] = lines[i].substring(indentation.length);\n    }\n  } // Last line is a special case because it won't have the same indent as others\n  // but may still have been given some indent to line up.\n\n  lines[lines.length - 1] = ''; // Return inline snapshot, now at indent 0.\n\n  inlineSnapshot = lines.join('\\n');\n  return inlineSnapshot;\n}\n\nconst fileExists = (filePath, hasteFS) =>\n  hasteFS.exists(filePath) || jestExistsFile(filePath);\n\nconst cleanup = (hasteFS, update, snapshotResolver, testPathIgnorePatterns) => {\n  const pattern = `\\\\.${_SnapshotResolver.EXTENSION}$`;\n  const files = hasteFS.matchFiles(pattern);\n  let testIgnorePatternsRegex = null;\n\n  if (testPathIgnorePatterns && testPathIgnorePatterns.length > 0) {\n    testIgnorePatternsRegex = new RegExp(testPathIgnorePatterns.join('|'));\n  }\n\n  const list = files.filter(snapshotFile => {\n    const testPath = snapshotResolver.resolveTestPath(snapshotFile); // ignore snapshots of ignored tests\n\n    if (testIgnorePatternsRegex && testIgnorePatternsRegex.test(testPath)) {\n      return false;\n    }\n\n    if (!fileExists(testPath, hasteFS)) {\n      if (update === 'all') {\n        fs.unlinkSync(snapshotFile);\n      }\n\n      return true;\n    }\n\n    return false;\n  });\n  return {\n    filesRemoved: list.length,\n    filesRemovedList: list\n  };\n};\n\nexports.cleanup = cleanup;\n\nconst toMatchSnapshot = function (received, propertiesOrHint, hint) {\n  const matcherName = 'toMatchSnapshot';\n  let properties;\n  const length = arguments.length;\n\n  if (length === 2 && typeof propertiesOrHint === 'string') {\n    hint = propertiesOrHint;\n  } else if (length >= 2) {\n    if (typeof propertiesOrHint !== 'object' || propertiesOrHint === null) {\n      const options = {\n        isNot: this.isNot,\n        promise: this.promise\n      };\n      let printedWithType = (0, _jestMatcherUtils.printWithType)(\n        'Expected properties',\n        propertiesOrHint,\n        _printSnapshot.printExpected\n      );\n\n      if (length === 3) {\n        options.secondArgument = 'hint';\n        options.secondArgumentColor = _jestMatcherUtils.BOLD_WEIGHT;\n\n        if (propertiesOrHint == null) {\n          printedWithType +=\n            \"\\n\\nTo provide a hint without properties: toMatchSnapshot('hint')\";\n        }\n      }\n\n      throw new Error(\n        (0, _jestMatcherUtils.matcherErrorMessage)(\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            undefined,\n            _printSnapshot.PROPERTIES_ARG,\n            options\n          ),\n          `Expected ${(0, _jestMatcherUtils.EXPECTED_COLOR)(\n            'properties'\n          )} must be an object`,\n          printedWithType\n        )\n      );\n    } // Future breaking change: Snapshot hint must be a string\n    // if (arguments.length === 3 && typeof hint !== 'string') {}\n\n    properties = propertiesOrHint;\n  }\n\n  return _toMatchSnapshot({\n    context: this,\n    hint,\n    isInline: false,\n    matcherName,\n    properties,\n    received\n  });\n};\n\nexports.toMatchSnapshot = toMatchSnapshot;\n\nconst toMatchInlineSnapshot = function (\n  received,\n  propertiesOrSnapshot,\n  inlineSnapshot\n) {\n  const matcherName = 'toMatchInlineSnapshot';\n  let properties;\n  const length = arguments.length;\n\n  if (length === 2 && typeof propertiesOrSnapshot === 'string') {\n    inlineSnapshot = propertiesOrSnapshot;\n  } else if (length >= 2) {\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n\n    if (length === 3) {\n      options.secondArgument = _printSnapshot.SNAPSHOT_ARG;\n      options.secondArgumentColor = _printSnapshot.noColor;\n    }\n\n    if (\n      typeof propertiesOrSnapshot !== 'object' ||\n      propertiesOrSnapshot === null\n    ) {\n      throw new Error(\n        (0, _jestMatcherUtils.matcherErrorMessage)(\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            undefined,\n            _printSnapshot.PROPERTIES_ARG,\n            options\n          ),\n          `Expected ${(0, _jestMatcherUtils.EXPECTED_COLOR)(\n            'properties'\n          )} must be an object`,\n          (0, _jestMatcherUtils.printWithType)(\n            'Expected properties',\n            propertiesOrSnapshot,\n            _printSnapshot.printExpected\n          )\n        )\n      );\n    }\n\n    if (length === 3 && typeof inlineSnapshot !== 'string') {\n      throw new Error(\n        (0, _jestMatcherUtils.matcherErrorMessage)(\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            undefined,\n            _printSnapshot.PROPERTIES_ARG,\n            options\n          ),\n          'Inline snapshot must be a string',\n          (0, _jestMatcherUtils.printWithType)(\n            'Inline snapshot',\n            inlineSnapshot,\n            _utils.serialize\n          )\n        )\n      );\n    }\n\n    properties = propertiesOrSnapshot;\n  }\n\n  return _toMatchSnapshot({\n    context: this,\n    inlineSnapshot:\n      inlineSnapshot !== undefined\n        ? stripAddedIndentation(inlineSnapshot)\n        : undefined,\n    isInline: true,\n    matcherName,\n    properties,\n    received\n  });\n};\n\nexports.toMatchInlineSnapshot = toMatchInlineSnapshot;\n\nconst _toMatchSnapshot = config => {\n  const {context, hint, inlineSnapshot, isInline, matcherName, properties} =\n    config;\n  let {received} = config;\n  context.dontThrow && context.dontThrow();\n  const {currentTestName, isNot, snapshotState} = context;\n\n  if (isNot) {\n    throw new Error(\n      (0, _jestMatcherUtils.matcherErrorMessage)(\n        (0, _printSnapshot.matcherHintFromConfig)(config, false),\n        NOT_SNAPSHOT_MATCHERS\n      )\n    );\n  }\n\n  if (snapshotState == null) {\n    // Because the state is the problem, this is not a matcher error.\n    // Call generic stringify from jest-matcher-utils package\n    // because uninitialized snapshot state does not need snapshot serializers.\n    throw new Error(\n      `${(0, _printSnapshot.matcherHintFromConfig)(config, false)}\\n\\n` +\n        'Snapshot state must be initialized' +\n        `\\n\\n${(0, _jestMatcherUtils.printWithType)(\n          'Snapshot state',\n          snapshotState,\n          _jestMatcherUtils.stringify\n        )}`\n    );\n  }\n\n  const fullTestName =\n    currentTestName && hint\n      ? `${currentTestName}: ${hint}`\n      : currentTestName || ''; // future BREAKING change: || hint\n\n  if (typeof properties === 'object') {\n    if (typeof received !== 'object' || received === null) {\n      throw new Error(\n        (0, _jestMatcherUtils.matcherErrorMessage)(\n          (0, _printSnapshot.matcherHintFromConfig)(config, false),\n          `${(0, _jestMatcherUtils.RECEIVED_COLOR)(\n            'received'\n          )} value must be an object when the matcher has ${(0,\n          _jestMatcherUtils.EXPECTED_COLOR)('properties')}`,\n          (0, _jestMatcherUtils.printWithType)(\n            'Received',\n            received,\n            _printSnapshot.printReceived\n          )\n        )\n      );\n    }\n\n    const propertyPass = context.equals(received, properties, [\n      context.utils.iterableEquality,\n      context.utils.subsetEquality\n    ]);\n\n    if (!propertyPass) {\n      const key = snapshotState.fail(fullTestName, received);\n      const matched = /(\\d+)$/.exec(key);\n      const count = matched === null ? 1 : Number(matched[1]);\n\n      const message = () =>\n        `${(0, _printSnapshot.matcherHintFromConfig)(\n          config,\n          false\n        )}\\n\\n${printSnapshotName(currentTestName, hint, count)}\\n\\n${(0,\n        _printSnapshot.printPropertiesAndReceived)(\n          properties,\n          received,\n          snapshotState.expand\n        )}`;\n\n      return {\n        message,\n        name: matcherName,\n        pass: false\n      };\n    } else {\n      received = (0, _utils.deepMerge)(received, properties);\n    }\n  }\n\n  const result = snapshotState.match({\n    error: context.error,\n    inlineSnapshot,\n    isInline,\n    received,\n    testName: fullTestName\n  });\n  const {actual, count, expected, pass} = result;\n\n  if (pass) {\n    return {\n      message: () => '',\n      pass: true\n    };\n  }\n\n  const message =\n    expected === undefined\n      ? () =>\n          `${(0, _printSnapshot.matcherHintFromConfig)(\n            config,\n            true\n          )}\\n\\n${printSnapshotName(currentTestName, hint, count)}\\n\\n` +\n          `New snapshot was ${(0, _jestMatcherUtils.BOLD_WEIGHT)(\n            'not written'\n          )}. The update flag ` +\n          'must be explicitly passed to write a new snapshot.\\n\\n' +\n          'This is likely because this test is run in a continuous integration ' +\n          '(CI) environment in which snapshots are not written by default.\\n\\n' +\n          `Received:${actual.includes('\\n') ? '\\n' : ' '}${(0,\n          _printSnapshot.bReceivedColor)(actual)}`\n      : () =>\n          `${(0, _printSnapshot.matcherHintFromConfig)(\n            config,\n            true\n          )}\\n\\n${printSnapshotName(currentTestName, hint, count)}\\n\\n${(0,\n          _printSnapshot.printSnapshotAndReceived)(\n            expected,\n            actual,\n            received,\n            snapshotState.expand\n          )}`; // Passing the actual and expected objects so that a custom reporter\n  // could access them, for example in order to display a custom visual diff,\n  // or create a different error message\n\n  return {\n    actual,\n    expected,\n    message,\n    name: matcherName,\n    pass: false\n  };\n};\n\nconst toThrowErrorMatchingSnapshot = function (received, hint, fromPromise) {\n  const matcherName = 'toThrowErrorMatchingSnapshot'; // Future breaking change: Snapshot hint must be a string\n  // if (hint !== undefined && typeof hint !== string) {}\n\n  return _toThrowErrorMatchingSnapshot(\n    {\n      context: this,\n      hint,\n      isInline: false,\n      matcherName,\n      received\n    },\n    fromPromise\n  );\n};\n\nexports.toThrowErrorMatchingSnapshot = toThrowErrorMatchingSnapshot;\n\nconst toThrowErrorMatchingInlineSnapshot = function (\n  received,\n  inlineSnapshot,\n  fromPromise\n) {\n  const matcherName = 'toThrowErrorMatchingInlineSnapshot';\n\n  if (inlineSnapshot !== undefined && typeof inlineSnapshot !== 'string') {\n    const options = {\n      expectedColor: _printSnapshot.noColor,\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    throw new Error(\n      (0, _jestMatcherUtils.matcherErrorMessage)(\n        (0, _jestMatcherUtils.matcherHint)(\n          matcherName,\n          undefined,\n          _printSnapshot.SNAPSHOT_ARG,\n          options\n        ),\n        'Inline snapshot must be a string',\n        (0, _jestMatcherUtils.printWithType)(\n          'Inline snapshot',\n          inlineSnapshot,\n          _utils.serialize\n        )\n      )\n    );\n  }\n\n  return _toThrowErrorMatchingSnapshot(\n    {\n      context: this,\n      inlineSnapshot:\n        inlineSnapshot !== undefined\n          ? stripAddedIndentation(inlineSnapshot)\n          : undefined,\n      isInline: true,\n      matcherName,\n      received\n    },\n    fromPromise\n  );\n};\n\nexports.toThrowErrorMatchingInlineSnapshot = toThrowErrorMatchingInlineSnapshot;\n\nconst _toThrowErrorMatchingSnapshot = (config, fromPromise) => {\n  const {context, hint, inlineSnapshot, isInline, matcherName, received} =\n    config;\n  context.dontThrow && context.dontThrow();\n  const {isNot, promise} = context;\n\n  if (!fromPromise) {\n    if (typeof received !== 'function') {\n      const options = {\n        isNot,\n        promise\n      };\n      throw new Error(\n        (0, _jestMatcherUtils.matcherErrorMessage)(\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            undefined,\n            '',\n            options\n          ),\n          `${(0, _jestMatcherUtils.RECEIVED_COLOR)(\n            'received'\n          )} value must be a function`,\n          (0, _jestMatcherUtils.printWithType)(\n            'Received',\n            received,\n            _printSnapshot.printReceived\n          )\n        )\n      );\n    }\n  }\n\n  if (isNot) {\n    throw new Error(\n      (0, _jestMatcherUtils.matcherErrorMessage)(\n        (0, _printSnapshot.matcherHintFromConfig)(config, false),\n        NOT_SNAPSHOT_MATCHERS\n      )\n    );\n  }\n\n  let error;\n\n  if (fromPromise) {\n    error = received;\n  } else {\n    try {\n      received();\n    } catch (e) {\n      error = e;\n    }\n  }\n\n  if (error === undefined) {\n    // Because the received value is a function, this is not a matcher error.\n    throw new Error(\n      `${(0, _printSnapshot.matcherHintFromConfig)(\n        config,\n        false\n      )}\\n\\n${DID_NOT_THROW}`\n    );\n  }\n\n  return _toMatchSnapshot({\n    context,\n    hint,\n    inlineSnapshot,\n    isInline,\n    matcherName,\n    received: error.message\n  });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}