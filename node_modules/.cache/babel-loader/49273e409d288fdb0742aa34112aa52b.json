{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.DuplicateError = void 0;\nObject.defineProperty(exports, 'ModuleMap', {\n  enumerable: true,\n  get: function () {\n    return _ModuleMap.default;\n  }\n});\nexports.default = void 0;\n\nfunction _crypto() {\n  const data = require('crypto');\n\n  _crypto = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _events() {\n  const data = require('events');\n\n  _events = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _os() {\n  const data = require('os');\n\n  _os = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _v() {\n  const data = require('v8');\n\n  _v = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _gracefulFs() {\n  const data = require('graceful-fs');\n\n  _gracefulFs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRegexUtil() {\n  const data = require('jest-regex-util');\n\n  _jestRegexUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestWorker() {\n  const data = require('jest-worker');\n\n  _jestWorker = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _HasteFS = _interopRequireDefault(require('./HasteFS'));\n\nvar _ModuleMap = _interopRequireDefault(require('./ModuleMap'));\n\nvar _constants = _interopRequireDefault(require('./constants'));\n\nvar _node = require('./crawlers/node');\n\nvar _watchman = require('./crawlers/watchman');\n\nvar _getMockName = _interopRequireDefault(require('./getMockName'));\n\nvar fastPath = _interopRequireWildcard(require('./lib/fast_path'));\n\nvar _getPlatformExtension = _interopRequireDefault(require('./lib/getPlatformExtension'));\n\nvar _isWatchmanInstalled = _interopRequireDefault(require('./lib/isWatchmanInstalled'));\n\nvar _normalizePathSep = _interopRequireDefault(require('./lib/normalizePathSep'));\n\nvar _FSEventsWatcher = require('./watchers/FSEventsWatcher');\n\nvar _NodeWatcher = _interopRequireDefault(require('./watchers/NodeWatcher'));\n\nvar _WatchmanWatcher = _interopRequireDefault(require('./watchers/WatchmanWatcher'));\n\nvar _worker = require('./worker');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// @ts-expect-error: not converted to TypeScript - it's a fork: https://github.com/facebook/jest/pull/10919\n// @ts-expect-error: not converted to TypeScript - it's a fork: https://github.com/facebook/jest/pull/5387\n// TypeScript doesn't like us importing from outside `rootDir`, but it doesn't\n// understand `require`.\n\n\nconst {\n  version: VERSION\n} = require('../package.json');\n\nconst CHANGE_INTERVAL = 30;\nconst MAX_WAIT_TIME = 240000;\nconst NODE_MODULES = `${path().sep}node_modules${path().sep}`;\nconst PACKAGE_JSON = `${path().sep}package.json`;\nconst VCS_DIRECTORIES = ['.git', '.hg'].map(vcs => (0, _jestRegexUtil().escapePathForRegex)(path().sep + vcs + path().sep)).join('|');\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n/**\n * HasteMap is a JavaScript implementation of Facebook's haste module system.\n *\n * This implementation is inspired by https://github.com/facebook/node-haste\n * and was built with for high-performance in large code repositories with\n * hundreds of thousands of files. This implementation is scalable and provides\n * predictable performance.\n *\n * Because the haste map creation and synchronization is critical to startup\n * performance and most tasks are blocked by I/O this class makes heavy use of\n * synchronous operations. It uses worker processes for parallelizing file\n * access and metadata extraction.\n *\n * The data structures created by `jest-haste-map` can be used directly from the\n * cache without further processing. The metadata objects in the `files` and\n * `map` objects contain cross-references: a metadata object from one can look\n * up the corresponding metadata object in the other map. Note that in most\n * projects, the number of files will be greater than the number of haste\n * modules one module can refer to many files based on platform extensions.\n *\n * type HasteMap = {\n *   clocks: WatchmanClocks,\n *   files: {[filepath: string]: FileMetaData},\n *   map: {[id: string]: ModuleMapItem},\n *   mocks: {[id: string]: string},\n * }\n *\n * // Watchman clocks are used for query synchronization and file system deltas.\n * type WatchmanClocks = {[filepath: string]: string};\n *\n * type FileMetaData = {\n *   id: ?string, // used to look up module metadata objects in `map`.\n *   mtime: number, // check for outdated files.\n *   size: number, // size of the file in bytes.\n *   visited: boolean, // whether the file has been parsed or not.\n *   dependencies: Array<string>, // all relative dependencies of this file.\n *   sha1: ?string, // SHA-1 of the file, if requested via options.\n * };\n *\n * // Modules can be targeted to a specific platform based on the file name.\n * // Example: platform.ios.js and Platform.android.js will both map to the same\n * // `Platform` module. The platform should be specified during resolution.\n * type ModuleMapItem = {[platform: string]: ModuleMetaData};\n *\n * //\n * type ModuleMetaData = {\n *   path: string, // the path to look up the file object in `files`.\n *   type: string, // the module type (either `package` or `module`).\n * };\n *\n * Note that the data structures described above are conceptual only. The actual\n * implementation uses arrays and constant keys for metadata storage. Instead of\n * `{id: 'flatMap', mtime: 3421, size: 42, visited: true, dependencies: []}` the real\n * representation is similar to `['flatMap', 3421, 42, 1, []]` to save storage space\n * and reduce parse and write time of a big JSON blob.\n *\n * The HasteMap is created as follows:\n *  1. read data from the cache or create an empty structure.\n *\n *  2. crawl the file system.\n *     * empty cache: crawl the entire file system.\n *     * cache available:\n *       * if watchman is available: get file system delta changes.\n *       * if watchman is unavailable: crawl the entire file system.\n *     * build metadata objects for every file. This builds the `files` part of\n *       the `HasteMap`.\n *\n *  3. parse and extract metadata from changed files.\n *     * this is done in parallel over worker processes to improve performance.\n *     * the worst case is to parse all files.\n *     * the best case is no file system access and retrieving all data from\n *       the cache.\n *     * the average case is a small number of changed files.\n *\n *  4. serialize the new `HasteMap` in a cache file.\n *     Worker processes can directly access the cache through `HasteMap.read()`.\n *\n */\n\n\nclass HasteMap extends _events().EventEmitter {\n  _buildPromise = null;\n  _cachePath = '';\n  _changeInterval;\n  _console;\n  _isWatchmanInstalledPromise = null;\n  _options;\n  _watchers = [];\n  _worker = null;\n\n  static getStatic(config) {\n    if (config.haste.hasteMapModulePath) {\n      return require(config.haste.hasteMapModulePath);\n    }\n\n    return HasteMap;\n  }\n\n  static async create(options) {\n    if (options.hasteMapModulePath) {\n      const CustomHasteMap = require(options.hasteMapModulePath);\n\n      return new CustomHasteMap(options);\n    }\n\n    const hasteMap = new HasteMap(options);\n    await hasteMap.setupCachePath(options);\n    return hasteMap;\n  }\n\n  constructor(options) {\n    var _options$computeDepen, _options$useWatchman;\n\n    super();\n    this._options = {\n      cacheDirectory: options.cacheDirectory || (0, _os().tmpdir)(),\n      computeDependencies: (_options$computeDepen = options.computeDependencies) !== null && _options$computeDepen !== void 0 ? _options$computeDepen : true,\n      computeSha1: options.computeSha1 || false,\n      dependencyExtractor: options.dependencyExtractor || null,\n      enableSymlinks: options.enableSymlinks || false,\n      extensions: options.extensions,\n      forceNodeFilesystemAPI: !!options.forceNodeFilesystemAPI,\n      hasteImplModulePath: options.hasteImplModulePath,\n      id: options.id,\n      maxWorkers: options.maxWorkers,\n      mocksPattern: options.mocksPattern ? new RegExp(options.mocksPattern) : null,\n      platforms: options.platforms,\n      resetCache: options.resetCache,\n      retainAllFiles: options.retainAllFiles,\n      rootDir: options.rootDir,\n      roots: Array.from(new Set(options.roots)),\n      skipPackageJson: !!options.skipPackageJson,\n      throwOnModuleCollision: !!options.throwOnModuleCollision,\n      useWatchman: (_options$useWatchman = options.useWatchman) !== null && _options$useWatchman !== void 0 ? _options$useWatchman : true,\n      watch: !!options.watch\n    };\n    this._console = options.console || globalThis.console;\n\n    if (options.ignorePattern) {\n      if (options.ignorePattern instanceof RegExp) {\n        this._options.ignorePattern = new RegExp(options.ignorePattern.source.concat(`|${VCS_DIRECTORIES}`), options.ignorePattern.flags);\n      } else {\n        throw new Error('jest-haste-map: the `ignorePattern` option must be a RegExp');\n      }\n    } else {\n      this._options.ignorePattern = new RegExp(VCS_DIRECTORIES);\n    }\n\n    if (this._options.enableSymlinks && this._options.useWatchman) {\n      throw new Error('jest-haste-map: enableSymlinks config option was set, but ' + 'is incompatible with watchman.\\n' + 'Set either `enableSymlinks` to false or `useWatchman` to false.');\n    }\n  }\n\n  async setupCachePath(options) {\n    const rootDirHash = (0, _crypto().createHash)('sha256').update(options.rootDir).digest('hex').substring(0, 32);\n    let hasteImplHash = '';\n    let dependencyExtractorHash = '';\n\n    if (options.hasteImplModulePath) {\n      const hasteImpl = require(options.hasteImplModulePath);\n\n      if (hasteImpl.getCacheKey) {\n        hasteImplHash = String(hasteImpl.getCacheKey());\n      }\n    }\n\n    if (options.dependencyExtractor) {\n      const dependencyExtractor = await (0, _jestUtil().requireOrImportModule)(options.dependencyExtractor, false);\n\n      if (dependencyExtractor.getCacheKey) {\n        dependencyExtractorHash = String(dependencyExtractor.getCacheKey());\n      }\n    }\n\n    this._cachePath = HasteMap.getCacheFilePath(this._options.cacheDirectory, `haste-map-${this._options.id}-${rootDirHash}`, VERSION, this._options.id, this._options.roots.map(root => fastPath.relative(options.rootDir, root)).join(':'), this._options.extensions.join(':'), this._options.platforms.join(':'), this._options.computeSha1.toString(), options.mocksPattern || '', (options.ignorePattern || '').toString(), hasteImplHash, dependencyExtractorHash, this._options.computeDependencies.toString());\n  }\n\n  static getCacheFilePath(tmpdir, id) {\n    for (var _len = arguments.length, extra = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      extra[_key - 2] = arguments[_key];\n    }\n\n    const hash = (0, _crypto().createHash)('sha256').update(extra.join(''));\n    return path().join(tmpdir, `${id.replace(/\\W/g, '-')}-${hash.digest('hex').substring(0, 32)}`);\n  }\n\n  static getModuleMapFromJSON(json) {\n    return _ModuleMap.default.fromJSON(json);\n  }\n\n  getCacheFilePath() {\n    return this._cachePath;\n  }\n\n  build() {\n    if (!this._buildPromise) {\n      this._buildPromise = (async () => {\n        const data = await this._buildFileMap(); // Persist when we don't know if files changed (changedFiles undefined)\n        // or when we know a file was changed or deleted.\n\n        let hasteMap;\n\n        if (data.changedFiles === undefined || data.changedFiles.size > 0 || data.removedFiles.size > 0) {\n          hasteMap = await this._buildHasteMap(data);\n\n          this._persist(hasteMap);\n        } else {\n          hasteMap = data.hasteMap;\n        }\n\n        const rootDir = this._options.rootDir;\n        const hasteFS = new _HasteFS.default({\n          files: hasteMap.files,\n          rootDir\n        });\n        const moduleMap = new _ModuleMap.default({\n          duplicates: hasteMap.duplicates,\n          map: hasteMap.map,\n          mocks: hasteMap.mocks,\n          rootDir\n        });\n\n        const __hasteMapForTest = process.env.NODE_ENV === 'test' && hasteMap || null;\n\n        await this._watch(hasteMap);\n        return {\n          __hasteMapForTest,\n          hasteFS,\n          moduleMap\n        };\n      })();\n    }\n\n    return this._buildPromise;\n  }\n  /**\n   * 1. read data from the cache or create an empty structure.\n   */\n\n\n  read() {\n    let hasteMap;\n\n    try {\n      hasteMap = (0, _v().deserialize)((0, _gracefulFs().readFileSync)(this._cachePath));\n    } catch {\n      hasteMap = this._createEmptyMap();\n    }\n\n    return hasteMap;\n  }\n\n  readModuleMap() {\n    const data = this.read();\n    return new _ModuleMap.default({\n      duplicates: data.duplicates,\n      map: data.map,\n      mocks: data.mocks,\n      rootDir: this._options.rootDir\n    });\n  }\n  /**\n   * 2. crawl the file system.\n   */\n\n\n  async _buildFileMap() {\n    let hasteMap;\n\n    try {\n      const read = this._options.resetCache ? this._createEmptyMap : this.read;\n      hasteMap = read.call(this);\n    } catch {\n      hasteMap = this._createEmptyMap();\n    }\n\n    return this._crawl(hasteMap);\n  }\n  /**\n   * 3. parse and extract metadata from changed files.\n   */\n\n\n  _processFile(hasteMap, map, mocks, filePath, workerOptions) {\n    const rootDir = this._options.rootDir;\n\n    const setModule = (id, module) => {\n      let moduleMap = map.get(id);\n\n      if (!moduleMap) {\n        moduleMap = Object.create(null);\n        map.set(id, moduleMap);\n      }\n\n      const platform = (0, _getPlatformExtension.default)(module[_constants.default.PATH], this._options.platforms) || _constants.default.GENERIC_PLATFORM;\n\n      const existingModule = moduleMap[platform];\n\n      if (existingModule && existingModule[_constants.default.PATH] !== module[_constants.default.PATH]) {\n        const method = this._options.throwOnModuleCollision ? 'error' : 'warn';\n\n        this._console[method]([`jest-haste-map: Haste module naming collision: ${id}`, '  The following files share their name; please adjust your hasteImpl:', `    * <rootDir>${path().sep}${existingModule[_constants.default.PATH]}`, `    * <rootDir>${path().sep}${module[_constants.default.PATH]}`, ''].join('\\n'));\n\n        if (this._options.throwOnModuleCollision) {\n          throw new DuplicateError(existingModule[_constants.default.PATH], module[_constants.default.PATH]);\n        } // We do NOT want consumers to use a module that is ambiguous.\n\n\n        delete moduleMap[platform];\n\n        if (Object.keys(moduleMap).length === 1) {\n          map.delete(id);\n        }\n\n        let dupsByPlatform = hasteMap.duplicates.get(id);\n\n        if (dupsByPlatform == null) {\n          dupsByPlatform = new Map();\n          hasteMap.duplicates.set(id, dupsByPlatform);\n        }\n\n        const dups = new Map([[module[_constants.default.PATH], module[_constants.default.TYPE]], [existingModule[_constants.default.PATH], existingModule[_constants.default.TYPE]]]);\n        dupsByPlatform.set(platform, dups);\n        return;\n      }\n\n      const dupsByPlatform = hasteMap.duplicates.get(id);\n\n      if (dupsByPlatform != null) {\n        const dups = dupsByPlatform.get(platform);\n\n        if (dups != null) {\n          dups.set(module[_constants.default.PATH], module[_constants.default.TYPE]);\n        }\n\n        return;\n      }\n\n      moduleMap[platform] = module;\n    };\n\n    const relativeFilePath = fastPath.relative(rootDir, filePath);\n    const fileMetadata = hasteMap.files.get(relativeFilePath);\n\n    if (!fileMetadata) {\n      throw new Error('jest-haste-map: File to process was not found in the haste map.');\n    }\n\n    const moduleMetadata = hasteMap.map.get(fileMetadata[_constants.default.ID]);\n    const computeSha1 = this._options.computeSha1 && !fileMetadata[_constants.default.SHA1]; // Callback called when the response from the worker is successful.\n\n    const workerReply = metadata => {\n      // `1` for truthy values instead of `true` to save cache space.\n      fileMetadata[_constants.default.VISITED] = 1;\n      const metadataId = metadata.id;\n      const metadataModule = metadata.module;\n\n      if (metadataId && metadataModule) {\n        fileMetadata[_constants.default.ID] = metadataId;\n        setModule(metadataId, metadataModule);\n      }\n\n      fileMetadata[_constants.default.DEPENDENCIES] = metadata.dependencies ? metadata.dependencies.join(_constants.default.DEPENDENCY_DELIM) : '';\n\n      if (computeSha1) {\n        fileMetadata[_constants.default.SHA1] = metadata.sha1;\n      }\n    }; // Callback called when the response from the worker is an error.\n\n\n    const workerError = error => {\n      if (typeof error !== 'object' || !error.message || !error.stack) {\n        error = new Error(error);\n        error.stack = ''; // Remove stack for stack-less errors.\n      }\n\n      if (!['ENOENT', 'EACCES'].includes(error.code)) {\n        throw error;\n      } // If a file cannot be read we remove it from the file list and\n      // ignore the failure silently.\n\n\n      hasteMap.files.delete(relativeFilePath);\n    }; // If we retain all files in the virtual HasteFS representation, we avoid\n    // reading them if they aren't important (node_modules).\n\n\n    if (this._options.retainAllFiles && filePath.includes(NODE_MODULES)) {\n      if (computeSha1) {\n        return this._getWorker(workerOptions).getSha1({\n          computeDependencies: this._options.computeDependencies,\n          computeSha1,\n          dependencyExtractor: this._options.dependencyExtractor,\n          filePath,\n          hasteImplModulePath: this._options.hasteImplModulePath,\n          rootDir\n        }).then(workerReply, workerError);\n      }\n\n      return null;\n    }\n\n    if (this._options.mocksPattern && this._options.mocksPattern.test(filePath)) {\n      const mockPath = (0, _getMockName.default)(filePath);\n      const existingMockPath = mocks.get(mockPath);\n\n      if (existingMockPath) {\n        const secondMockPath = fastPath.relative(rootDir, filePath);\n\n        if (existingMockPath !== secondMockPath) {\n          const method = this._options.throwOnModuleCollision ? 'error' : 'warn';\n\n          this._console[method]([`jest-haste-map: duplicate manual mock found: ${mockPath}`, '  The following files share their name; please delete one of them:', `    * <rootDir>${path().sep}${existingMockPath}`, `    * <rootDir>${path().sep}${secondMockPath}`, ''].join('\\n'));\n\n          if (this._options.throwOnModuleCollision) {\n            throw new DuplicateError(existingMockPath, secondMockPath);\n          }\n        }\n      }\n\n      mocks.set(mockPath, relativeFilePath);\n    }\n\n    if (fileMetadata[_constants.default.VISITED]) {\n      if (!fileMetadata[_constants.default.ID]) {\n        return null;\n      }\n\n      if (moduleMetadata != null) {\n        const platform = (0, _getPlatformExtension.default)(filePath, this._options.platforms) || _constants.default.GENERIC_PLATFORM;\n\n        const module = moduleMetadata[platform];\n\n        if (module == null) {\n          return null;\n        }\n\n        const moduleId = fileMetadata[_constants.default.ID];\n        let modulesByPlatform = map.get(moduleId);\n\n        if (!modulesByPlatform) {\n          modulesByPlatform = Object.create(null);\n          map.set(moduleId, modulesByPlatform);\n        }\n\n        modulesByPlatform[platform] = module;\n        return null;\n      }\n    }\n\n    return this._getWorker(workerOptions).worker({\n      computeDependencies: this._options.computeDependencies,\n      computeSha1,\n      dependencyExtractor: this._options.dependencyExtractor,\n      filePath,\n      hasteImplModulePath: this._options.hasteImplModulePath,\n      rootDir\n    }).then(workerReply, workerError);\n  }\n\n  _buildHasteMap(data) {\n    const {\n      removedFiles,\n      changedFiles,\n      hasteMap\n    } = data; // If any files were removed or we did not track what files changed, process\n    // every file looking for changes. Otherwise, process only changed files.\n\n    let map;\n    let mocks;\n    let filesToProcess;\n\n    if (changedFiles === undefined || removedFiles.size) {\n      map = new Map();\n      mocks = new Map();\n      filesToProcess = hasteMap.files;\n    } else {\n      map = hasteMap.map;\n      mocks = hasteMap.mocks;\n      filesToProcess = changedFiles;\n    }\n\n    for (const [relativeFilePath, fileMetadata] of removedFiles) {\n      this._recoverDuplicates(hasteMap, relativeFilePath, fileMetadata[_constants.default.ID]);\n    }\n\n    const promises = [];\n\n    for (const relativeFilePath of filesToProcess.keys()) {\n      if (this._options.skipPackageJson && relativeFilePath.endsWith(PACKAGE_JSON)) {\n        continue;\n      } // SHA-1, if requested, should already be present thanks to the crawler.\n\n\n      const filePath = fastPath.resolve(this._options.rootDir, relativeFilePath);\n\n      const promise = this._processFile(hasteMap, map, mocks, filePath);\n\n      if (promise) {\n        promises.push(promise);\n      }\n    }\n\n    return Promise.all(promises).then(() => {\n      this._cleanup();\n\n      hasteMap.map = map;\n      hasteMap.mocks = mocks;\n      return hasteMap;\n    }, error => {\n      this._cleanup();\n\n      throw error;\n    });\n  }\n\n  _cleanup() {\n    const worker = this._worker;\n\n    if (worker && 'end' in worker) {\n      worker.end();\n    }\n\n    this._worker = null;\n  }\n  /**\n   * 4. serialize the new `HasteMap` in a cache file.\n   */\n\n\n  _persist(hasteMap) {\n    (0, _gracefulFs().writeFileSync)(this._cachePath, (0, _v().serialize)(hasteMap));\n  }\n  /**\n   * Creates workers or parses files and extracts metadata in-process.\n   */\n\n\n  _getWorker() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      forceInBand: false\n    };\n\n    if (!this._worker) {\n      if (options.forceInBand || this._options.maxWorkers <= 1) {\n        this._worker = {\n          getSha1: _worker.getSha1,\n          worker: _worker.worker\n        };\n      } else {\n        this._worker = new (_jestWorker().Worker)(require.resolve('./worker'), {\n          exposedMethods: ['getSha1', 'worker'],\n          // @ts-expect-error: option does not exist on the node 12 types\n          forkOptions: {\n            serialization: 'json'\n          },\n          maxRetries: 3,\n          numWorkers: this._options.maxWorkers\n        });\n      }\n    }\n\n    return this._worker;\n  }\n\n  async _crawl(hasteMap) {\n    const options = this._options;\n\n    const ignore = this._ignore.bind(this);\n\n    const crawl = (await this._shouldUseWatchman()) ? _watchman.watchmanCrawl : _node.nodeCrawl;\n    const crawlerOptions = {\n      computeSha1: options.computeSha1,\n      data: hasteMap,\n      enableSymlinks: options.enableSymlinks,\n      extensions: options.extensions,\n      forceNodeFilesystemAPI: options.forceNodeFilesystemAPI,\n      ignore,\n      rootDir: options.rootDir,\n      roots: options.roots\n    };\n\n    const retry = error => {\n      if (crawl === _watchman.watchmanCrawl) {\n        this._console.warn('jest-haste-map: Watchman crawl failed. Retrying once with node ' + 'crawler.\\n' + \"  Usually this happens when watchman isn't running. Create an \" + \"empty `.watchmanconfig` file in your project's root folder or \" + 'initialize a git or hg repository in your project.\\n' + `  ${error}`);\n\n        return (0, _node.nodeCrawl)(crawlerOptions).catch(e => {\n          throw new Error('Crawler retry failed:\\n' + `  Original error: ${error.message}\\n` + `  Retry error: ${e.message}\\n`);\n        });\n      }\n\n      throw error;\n    };\n\n    try {\n      return crawl(crawlerOptions).catch(retry);\n    } catch (error) {\n      return retry(error);\n    }\n  }\n  /**\n   * Watch mode\n   */\n\n\n  async _watch(hasteMap) {\n    if (!this._options.watch) {\n      return Promise.resolve();\n    } // In watch mode, we'll only warn about module collisions and we'll retain\n    // all files, even changes to node_modules.\n\n\n    this._options.throwOnModuleCollision = false;\n    this._options.retainAllFiles = true; // WatchmanWatcher > FSEventsWatcher > sane.NodeWatcher\n\n    const Watcher = (await this._shouldUseWatchman()) ? _WatchmanWatcher.default : _FSEventsWatcher.FSEventsWatcher.isSupported() ? _FSEventsWatcher.FSEventsWatcher : _NodeWatcher.default;\n    const extensions = this._options.extensions;\n    const ignorePattern = this._options.ignorePattern;\n    const rootDir = this._options.rootDir;\n    let changeQueue = Promise.resolve();\n    let eventsQueue = []; // We only need to copy the entire haste map once on every \"frame\".\n\n    let mustCopy = true;\n\n    const createWatcher = root => {\n      const watcher = new Watcher(root, {\n        dot: true,\n        glob: extensions.map(extension => `**/*.${extension}`),\n        ignored: ignorePattern\n      });\n      return new Promise((resolve, reject) => {\n        const rejectTimeout = setTimeout(() => reject(new Error('Failed to start watch mode.')), MAX_WAIT_TIME);\n        watcher.once('ready', () => {\n          clearTimeout(rejectTimeout);\n          watcher.on('all', onChange);\n          resolve(watcher);\n        });\n      });\n    };\n\n    const emitChange = () => {\n      if (eventsQueue.length) {\n        mustCopy = true;\n        const changeEvent = {\n          eventsQueue,\n          hasteFS: new _HasteFS.default({\n            files: hasteMap.files,\n            rootDir\n          }),\n          moduleMap: new _ModuleMap.default({\n            duplicates: hasteMap.duplicates,\n            map: hasteMap.map,\n            mocks: hasteMap.mocks,\n            rootDir\n          })\n        };\n        this.emit('change', changeEvent);\n        eventsQueue = [];\n      }\n    };\n\n    const onChange = (type, filePath, root, stat) => {\n      filePath = path().join(root, (0, _normalizePathSep.default)(filePath));\n\n      if (stat && stat.isDirectory() || this._ignore(filePath) || !extensions.some(extension => filePath.endsWith(extension))) {\n        return;\n      }\n\n      const relativeFilePath = fastPath.relative(rootDir, filePath);\n      const fileMetadata = hasteMap.files.get(relativeFilePath); // The file has been accessed, not modified\n\n      if (type === 'change' && fileMetadata && stat && fileMetadata[_constants.default.MTIME] === stat.mtime.getTime()) {\n        return;\n      }\n\n      changeQueue = changeQueue.then(() => {\n        // If we get duplicate events for the same file, ignore them.\n        if (eventsQueue.find(event => event.type === type && event.filePath === filePath && (!event.stat && !stat || !!event.stat && !!stat && event.stat.mtime.getTime() === stat.mtime.getTime()))) {\n          return null;\n        }\n\n        if (mustCopy) {\n          mustCopy = false;\n          hasteMap = {\n            clocks: new Map(hasteMap.clocks),\n            duplicates: new Map(hasteMap.duplicates),\n            files: new Map(hasteMap.files),\n            map: new Map(hasteMap.map),\n            mocks: new Map(hasteMap.mocks)\n          };\n        }\n\n        const add = () => {\n          eventsQueue.push({\n            filePath,\n            stat,\n            type\n          });\n          return null;\n        };\n\n        const fileMetadata = hasteMap.files.get(relativeFilePath); // If it's not an addition, delete the file and all its metadata\n\n        if (fileMetadata != null) {\n          const moduleName = fileMetadata[_constants.default.ID];\n\n          const platform = (0, _getPlatformExtension.default)(filePath, this._options.platforms) || _constants.default.GENERIC_PLATFORM;\n\n          hasteMap.files.delete(relativeFilePath);\n          let moduleMap = hasteMap.map.get(moduleName);\n\n          if (moduleMap != null) {\n            // We are forced to copy the object because jest-haste-map exposes\n            // the map as an immutable entity.\n            moduleMap = copy(moduleMap);\n            delete moduleMap[platform];\n\n            if (Object.keys(moduleMap).length === 0) {\n              hasteMap.map.delete(moduleName);\n            } else {\n              hasteMap.map.set(moduleName, moduleMap);\n            }\n          }\n\n          if (this._options.mocksPattern && this._options.mocksPattern.test(filePath)) {\n            const mockName = (0, _getMockName.default)(filePath);\n            hasteMap.mocks.delete(mockName);\n          }\n\n          this._recoverDuplicates(hasteMap, relativeFilePath, moduleName);\n        } // If the file was added or changed,\n        // parse it and update the haste map.\n\n\n        if (type === 'add' || type === 'change') {\n          invariant(stat, 'since the file exists or changed, it should have stats');\n          const fileMetadata = ['', stat.mtime.getTime(), stat.size, 0, '', null];\n          hasteMap.files.set(relativeFilePath, fileMetadata);\n\n          const promise = this._processFile(hasteMap, hasteMap.map, hasteMap.mocks, filePath, {\n            forceInBand: true\n          }); // Cleanup\n\n\n          this._cleanup();\n\n          if (promise) {\n            return promise.then(add);\n          } else {\n            // If a file in node_modules has changed,\n            // emit an event regardless.\n            add();\n          }\n        } else {\n          add();\n        }\n\n        return null;\n      }).catch(error => {\n        this._console.error(`jest-haste-map: watch error:\\n  ${error.stack}\\n`);\n      });\n    };\n\n    this._changeInterval = setInterval(emitChange, CHANGE_INTERVAL);\n    return Promise.all(this._options.roots.map(createWatcher)).then(watchers => {\n      this._watchers = watchers;\n    });\n  }\n  /**\n   * This function should be called when the file under `filePath` is removed\n   * or changed. When that happens, we want to figure out if that file was\n   * part of a group of files that had the same ID. If it was, we want to\n   * remove it from the group. Furthermore, if there is only one file\n   * remaining in the group, then we want to restore that single file as the\n   * correct resolution for its ID, and cleanup the duplicates index.\n   */\n\n\n  _recoverDuplicates(hasteMap, relativeFilePath, moduleName) {\n    let dupsByPlatform = hasteMap.duplicates.get(moduleName);\n\n    if (dupsByPlatform == null) {\n      return;\n    }\n\n    const platform = (0, _getPlatformExtension.default)(relativeFilePath, this._options.platforms) || _constants.default.GENERIC_PLATFORM;\n\n    let dups = dupsByPlatform.get(platform);\n\n    if (dups == null) {\n      return;\n    }\n\n    dupsByPlatform = copyMap(dupsByPlatform);\n    hasteMap.duplicates.set(moduleName, dupsByPlatform);\n    dups = copyMap(dups);\n    dupsByPlatform.set(platform, dups);\n    dups.delete(relativeFilePath);\n\n    if (dups.size !== 1) {\n      return;\n    }\n\n    const uniqueModule = dups.entries().next().value;\n\n    if (!uniqueModule) {\n      return;\n    }\n\n    let dedupMap = hasteMap.map.get(moduleName);\n\n    if (!dedupMap) {\n      dedupMap = Object.create(null);\n      hasteMap.map.set(moduleName, dedupMap);\n    }\n\n    dedupMap[platform] = uniqueModule;\n    dupsByPlatform.delete(platform);\n\n    if (dupsByPlatform.size === 0) {\n      hasteMap.duplicates.delete(moduleName);\n    }\n  }\n\n  async end() {\n    if (this._changeInterval) {\n      clearInterval(this._changeInterval);\n    }\n\n    if (!this._watchers.length) {\n      return;\n    }\n\n    await Promise.all(this._watchers.map(watcher => watcher.close()));\n    this._watchers = [];\n  }\n  /**\n   * Helpers\n   */\n\n\n  _ignore(filePath) {\n    const ignorePattern = this._options.ignorePattern;\n    const ignoreMatched = ignorePattern instanceof RegExp ? ignorePattern.test(filePath) : ignorePattern && ignorePattern(filePath);\n    return ignoreMatched || !this._options.retainAllFiles && filePath.includes(NODE_MODULES);\n  }\n\n  async _shouldUseWatchman() {\n    if (!this._options.useWatchman) {\n      return false;\n    }\n\n    if (!this._isWatchmanInstalledPromise) {\n      this._isWatchmanInstalledPromise = (0, _isWatchmanInstalled.default)();\n    }\n\n    return this._isWatchmanInstalledPromise;\n  }\n\n  _createEmptyMap() {\n    return {\n      clocks: new Map(),\n      duplicates: new Map(),\n      files: new Map(),\n      map: new Map(),\n      mocks: new Map()\n    };\n  }\n\n  static H = _constants.default;\n}\n\nexports.default = HasteMap;\n\nclass DuplicateError extends Error {\n  mockPath1;\n  mockPath2;\n\n  constructor(mockPath1, mockPath2) {\n    super('Duplicated files or mocks. Please check the console for more info');\n    this.mockPath1 = mockPath1;\n    this.mockPath2 = mockPath2;\n  }\n\n}\n\nexports.DuplicateError = DuplicateError;\n\nfunction copy(object) {\n  return Object.assign(Object.create(null), object);\n}\n\nfunction copyMap(input) {\n  return new Map(input);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","DuplicateError","enumerable","get","_ModuleMap","default","_crypto","data","require","_events","_os","path","_interopRequireWildcard","_v","_gracefulFs","_jestRegexUtil","_jestUtil","_jestWorker","_HasteFS","_interopRequireDefault","_constants","_node","_watchman","_getMockName","fastPath","_getPlatformExtension","_isWatchmanInstalled","_normalizePathSep","_FSEventsWatcher","_NodeWatcher","_WatchmanWatcher","_worker","obj","__esModule","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","version","VERSION","CHANGE_INTERVAL","MAX_WAIT_TIME","NODE_MODULES","sep","PACKAGE_JSON","VCS_DIRECTORIES","map","vcs","escapePathForRegex","join","invariant","condition","message","Error","HasteMap","EventEmitter","_buildPromise","_cachePath","_changeInterval","_console","_isWatchmanInstalledPromise","_options","_watchers","getStatic","config","haste","hasteMapModulePath","create","options","CustomHasteMap","hasteMap","setupCachePath","constructor","_options$computeDepen","_options$useWatchman","cacheDirectory","tmpdir","computeDependencies","computeSha1","dependencyExtractor","enableSymlinks","extensions","forceNodeFilesystemAPI","hasteImplModulePath","id","maxWorkers","mocksPattern","RegExp","platforms","resetCache","retainAllFiles","rootDir","roots","Array","from","Set","skipPackageJson","throwOnModuleCollision","useWatchman","watch","console","globalThis","ignorePattern","source","concat","flags","rootDirHash","createHash","update","digest","substring","hasteImplHash","dependencyExtractorHash","hasteImpl","getCacheKey","String","requireOrImportModule","getCacheFilePath","root","relative","toString","extra","hash","replace","getModuleMapFromJSON","json","fromJSON","build","_buildFileMap","changedFiles","undefined","size","removedFiles","_buildHasteMap","_persist","hasteFS","files","moduleMap","duplicates","mocks","__hasteMapForTest","process","env","NODE_ENV","_watch","read","deserialize","readFileSync","_createEmptyMap","readModuleMap","_crawl","_processFile","filePath","workerOptions","setModule","module","platform","PATH","GENERIC_PLATFORM","existingModule","method","keys","length","delete","dupsByPlatform","Map","dups","TYPE","relativeFilePath","fileMetadata","moduleMetadata","ID","SHA1","workerReply","metadata","VISITED","metadataId","metadataModule","DEPENDENCIES","dependencies","DEPENDENCY_DELIM","sha1","workerError","error","stack","includes","code","_getWorker","getSha1","then","test","mockPath","existingMockPath","secondMockPath","moduleId","modulesByPlatform","worker","filesToProcess","_recoverDuplicates","promises","endsWith","resolve","promise","push","Promise","all","_cleanup","end","writeFileSync","serialize","forceInBand","Worker","exposedMethods","forkOptions","serialization","maxRetries","numWorkers","ignore","_ignore","bind","crawl","_shouldUseWatchman","watchmanCrawl","nodeCrawl","crawlerOptions","retry","warn","catch","e","Watcher","FSEventsWatcher","isSupported","changeQueue","eventsQueue","mustCopy","createWatcher","watcher","dot","glob","extension","ignored","reject","rejectTimeout","setTimeout","once","clearTimeout","on","onChange","emitChange","changeEvent","emit","type","stat","isDirectory","some","MTIME","mtime","getTime","find","event","clocks","add","moduleName","copy","mockName","setInterval","watchers","copyMap","uniqueModule","entries","next","dedupMap","clearInterval","close","ignoreMatched","H","mockPath1","mockPath2","object","assign","input"],"sources":["/Users/wonjaelee/Desktop/final/node_modules/jest-runtime/node_modules/jest-haste-map/build/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.DuplicateError = void 0;\nObject.defineProperty(exports, 'ModuleMap', {\n  enumerable: true,\n  get: function () {\n    return _ModuleMap.default;\n  }\n});\nexports.default = void 0;\n\nfunction _crypto() {\n  const data = require('crypto');\n\n  _crypto = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _events() {\n  const data = require('events');\n\n  _events = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _os() {\n  const data = require('os');\n\n  _os = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _v() {\n  const data = require('v8');\n\n  _v = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _gracefulFs() {\n  const data = require('graceful-fs');\n\n  _gracefulFs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRegexUtil() {\n  const data = require('jest-regex-util');\n\n  _jestRegexUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestWorker() {\n  const data = require('jest-worker');\n\n  _jestWorker = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _HasteFS = _interopRequireDefault(require('./HasteFS'));\n\nvar _ModuleMap = _interopRequireDefault(require('./ModuleMap'));\n\nvar _constants = _interopRequireDefault(require('./constants'));\n\nvar _node = require('./crawlers/node');\n\nvar _watchman = require('./crawlers/watchman');\n\nvar _getMockName = _interopRequireDefault(require('./getMockName'));\n\nvar fastPath = _interopRequireWildcard(require('./lib/fast_path'));\n\nvar _getPlatformExtension = _interopRequireDefault(\n  require('./lib/getPlatformExtension')\n);\n\nvar _isWatchmanInstalled = _interopRequireDefault(\n  require('./lib/isWatchmanInstalled')\n);\n\nvar _normalizePathSep = _interopRequireDefault(\n  require('./lib/normalizePathSep')\n);\n\nvar _FSEventsWatcher = require('./watchers/FSEventsWatcher');\n\nvar _NodeWatcher = _interopRequireDefault(require('./watchers/NodeWatcher'));\n\nvar _WatchmanWatcher = _interopRequireDefault(\n  require('./watchers/WatchmanWatcher')\n);\n\nvar _worker = require('./worker');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// @ts-expect-error: not converted to TypeScript - it's a fork: https://github.com/facebook/jest/pull/10919\n// @ts-expect-error: not converted to TypeScript - it's a fork: https://github.com/facebook/jest/pull/5387\n// TypeScript doesn't like us importing from outside `rootDir`, but it doesn't\n// understand `require`.\nconst {version: VERSION} = require('../package.json');\n\nconst CHANGE_INTERVAL = 30;\nconst MAX_WAIT_TIME = 240000;\nconst NODE_MODULES = `${path().sep}node_modules${path().sep}`;\nconst PACKAGE_JSON = `${path().sep}package.json`;\nconst VCS_DIRECTORIES = ['.git', '.hg']\n  .map(vcs =>\n    (0, _jestRegexUtil().escapePathForRegex)(path().sep + vcs + path().sep)\n  )\n  .join('|');\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n/**\n * HasteMap is a JavaScript implementation of Facebook's haste module system.\n *\n * This implementation is inspired by https://github.com/facebook/node-haste\n * and was built with for high-performance in large code repositories with\n * hundreds of thousands of files. This implementation is scalable and provides\n * predictable performance.\n *\n * Because the haste map creation and synchronization is critical to startup\n * performance and most tasks are blocked by I/O this class makes heavy use of\n * synchronous operations. It uses worker processes for parallelizing file\n * access and metadata extraction.\n *\n * The data structures created by `jest-haste-map` can be used directly from the\n * cache without further processing. The metadata objects in the `files` and\n * `map` objects contain cross-references: a metadata object from one can look\n * up the corresponding metadata object in the other map. Note that in most\n * projects, the number of files will be greater than the number of haste\n * modules one module can refer to many files based on platform extensions.\n *\n * type HasteMap = {\n *   clocks: WatchmanClocks,\n *   files: {[filepath: string]: FileMetaData},\n *   map: {[id: string]: ModuleMapItem},\n *   mocks: {[id: string]: string},\n * }\n *\n * // Watchman clocks are used for query synchronization and file system deltas.\n * type WatchmanClocks = {[filepath: string]: string};\n *\n * type FileMetaData = {\n *   id: ?string, // used to look up module metadata objects in `map`.\n *   mtime: number, // check for outdated files.\n *   size: number, // size of the file in bytes.\n *   visited: boolean, // whether the file has been parsed or not.\n *   dependencies: Array<string>, // all relative dependencies of this file.\n *   sha1: ?string, // SHA-1 of the file, if requested via options.\n * };\n *\n * // Modules can be targeted to a specific platform based on the file name.\n * // Example: platform.ios.js and Platform.android.js will both map to the same\n * // `Platform` module. The platform should be specified during resolution.\n * type ModuleMapItem = {[platform: string]: ModuleMetaData};\n *\n * //\n * type ModuleMetaData = {\n *   path: string, // the path to look up the file object in `files`.\n *   type: string, // the module type (either `package` or `module`).\n * };\n *\n * Note that the data structures described above are conceptual only. The actual\n * implementation uses arrays and constant keys for metadata storage. Instead of\n * `{id: 'flatMap', mtime: 3421, size: 42, visited: true, dependencies: []}` the real\n * representation is similar to `['flatMap', 3421, 42, 1, []]` to save storage space\n * and reduce parse and write time of a big JSON blob.\n *\n * The HasteMap is created as follows:\n *  1. read data from the cache or create an empty structure.\n *\n *  2. crawl the file system.\n *     * empty cache: crawl the entire file system.\n *     * cache available:\n *       * if watchman is available: get file system delta changes.\n *       * if watchman is unavailable: crawl the entire file system.\n *     * build metadata objects for every file. This builds the `files` part of\n *       the `HasteMap`.\n *\n *  3. parse and extract metadata from changed files.\n *     * this is done in parallel over worker processes to improve performance.\n *     * the worst case is to parse all files.\n *     * the best case is no file system access and retrieving all data from\n *       the cache.\n *     * the average case is a small number of changed files.\n *\n *  4. serialize the new `HasteMap` in a cache file.\n *     Worker processes can directly access the cache through `HasteMap.read()`.\n *\n */\n\nclass HasteMap extends _events().EventEmitter {\n  _buildPromise = null;\n  _cachePath = '';\n  _changeInterval;\n  _console;\n  _isWatchmanInstalledPromise = null;\n  _options;\n  _watchers = [];\n  _worker = null;\n\n  static getStatic(config) {\n    if (config.haste.hasteMapModulePath) {\n      return require(config.haste.hasteMapModulePath);\n    }\n\n    return HasteMap;\n  }\n\n  static async create(options) {\n    if (options.hasteMapModulePath) {\n      const CustomHasteMap = require(options.hasteMapModulePath);\n\n      return new CustomHasteMap(options);\n    }\n\n    const hasteMap = new HasteMap(options);\n    await hasteMap.setupCachePath(options);\n    return hasteMap;\n  }\n\n  constructor(options) {\n    var _options$computeDepen, _options$useWatchman;\n\n    super();\n    this._options = {\n      cacheDirectory: options.cacheDirectory || (0, _os().tmpdir)(),\n      computeDependencies:\n        (_options$computeDepen = options.computeDependencies) !== null &&\n        _options$computeDepen !== void 0\n          ? _options$computeDepen\n          : true,\n      computeSha1: options.computeSha1 || false,\n      dependencyExtractor: options.dependencyExtractor || null,\n      enableSymlinks: options.enableSymlinks || false,\n      extensions: options.extensions,\n      forceNodeFilesystemAPI: !!options.forceNodeFilesystemAPI,\n      hasteImplModulePath: options.hasteImplModulePath,\n      id: options.id,\n      maxWorkers: options.maxWorkers,\n      mocksPattern: options.mocksPattern\n        ? new RegExp(options.mocksPattern)\n        : null,\n      platforms: options.platforms,\n      resetCache: options.resetCache,\n      retainAllFiles: options.retainAllFiles,\n      rootDir: options.rootDir,\n      roots: Array.from(new Set(options.roots)),\n      skipPackageJson: !!options.skipPackageJson,\n      throwOnModuleCollision: !!options.throwOnModuleCollision,\n      useWatchman:\n        (_options$useWatchman = options.useWatchman) !== null &&\n        _options$useWatchman !== void 0\n          ? _options$useWatchman\n          : true,\n      watch: !!options.watch\n    };\n    this._console = options.console || globalThis.console;\n\n    if (options.ignorePattern) {\n      if (options.ignorePattern instanceof RegExp) {\n        this._options.ignorePattern = new RegExp(\n          options.ignorePattern.source.concat(`|${VCS_DIRECTORIES}`),\n          options.ignorePattern.flags\n        );\n      } else {\n        throw new Error(\n          'jest-haste-map: the `ignorePattern` option must be a RegExp'\n        );\n      }\n    } else {\n      this._options.ignorePattern = new RegExp(VCS_DIRECTORIES);\n    }\n\n    if (this._options.enableSymlinks && this._options.useWatchman) {\n      throw new Error(\n        'jest-haste-map: enableSymlinks config option was set, but ' +\n          'is incompatible with watchman.\\n' +\n          'Set either `enableSymlinks` to false or `useWatchman` to false.'\n      );\n    }\n  }\n\n  async setupCachePath(options) {\n    const rootDirHash = (0, _crypto().createHash)('sha256')\n      .update(options.rootDir)\n      .digest('hex')\n      .substring(0, 32);\n    let hasteImplHash = '';\n    let dependencyExtractorHash = '';\n\n    if (options.hasteImplModulePath) {\n      const hasteImpl = require(options.hasteImplModulePath);\n\n      if (hasteImpl.getCacheKey) {\n        hasteImplHash = String(hasteImpl.getCacheKey());\n      }\n    }\n\n    if (options.dependencyExtractor) {\n      const dependencyExtractor = await (0, _jestUtil().requireOrImportModule)(\n        options.dependencyExtractor,\n        false\n      );\n\n      if (dependencyExtractor.getCacheKey) {\n        dependencyExtractorHash = String(dependencyExtractor.getCacheKey());\n      }\n    }\n\n    this._cachePath = HasteMap.getCacheFilePath(\n      this._options.cacheDirectory,\n      `haste-map-${this._options.id}-${rootDirHash}`,\n      VERSION,\n      this._options.id,\n      this._options.roots\n        .map(root => fastPath.relative(options.rootDir, root))\n        .join(':'),\n      this._options.extensions.join(':'),\n      this._options.platforms.join(':'),\n      this._options.computeSha1.toString(),\n      options.mocksPattern || '',\n      (options.ignorePattern || '').toString(),\n      hasteImplHash,\n      dependencyExtractorHash,\n      this._options.computeDependencies.toString()\n    );\n  }\n\n  static getCacheFilePath(tmpdir, id, ...extra) {\n    const hash = (0, _crypto().createHash)('sha256').update(extra.join(''));\n    return path().join(\n      tmpdir,\n      `${id.replace(/\\W/g, '-')}-${hash.digest('hex').substring(0, 32)}`\n    );\n  }\n\n  static getModuleMapFromJSON(json) {\n    return _ModuleMap.default.fromJSON(json);\n  }\n\n  getCacheFilePath() {\n    return this._cachePath;\n  }\n\n  build() {\n    if (!this._buildPromise) {\n      this._buildPromise = (async () => {\n        const data = await this._buildFileMap(); // Persist when we don't know if files changed (changedFiles undefined)\n        // or when we know a file was changed or deleted.\n\n        let hasteMap;\n\n        if (\n          data.changedFiles === undefined ||\n          data.changedFiles.size > 0 ||\n          data.removedFiles.size > 0\n        ) {\n          hasteMap = await this._buildHasteMap(data);\n\n          this._persist(hasteMap);\n        } else {\n          hasteMap = data.hasteMap;\n        }\n\n        const rootDir = this._options.rootDir;\n        const hasteFS = new _HasteFS.default({\n          files: hasteMap.files,\n          rootDir\n        });\n        const moduleMap = new _ModuleMap.default({\n          duplicates: hasteMap.duplicates,\n          map: hasteMap.map,\n          mocks: hasteMap.mocks,\n          rootDir\n        });\n\n        const __hasteMapForTest =\n          (process.env.NODE_ENV === 'test' && hasteMap) || null;\n\n        await this._watch(hasteMap);\n        return {\n          __hasteMapForTest,\n          hasteFS,\n          moduleMap\n        };\n      })();\n    }\n\n    return this._buildPromise;\n  }\n  /**\n   * 1. read data from the cache or create an empty structure.\n   */\n\n  read() {\n    let hasteMap;\n\n    try {\n      hasteMap = (0, _v().deserialize)(\n        (0, _gracefulFs().readFileSync)(this._cachePath)\n      );\n    } catch {\n      hasteMap = this._createEmptyMap();\n    }\n\n    return hasteMap;\n  }\n\n  readModuleMap() {\n    const data = this.read();\n    return new _ModuleMap.default({\n      duplicates: data.duplicates,\n      map: data.map,\n      mocks: data.mocks,\n      rootDir: this._options.rootDir\n    });\n  }\n  /**\n   * 2. crawl the file system.\n   */\n\n  async _buildFileMap() {\n    let hasteMap;\n\n    try {\n      const read = this._options.resetCache ? this._createEmptyMap : this.read;\n      hasteMap = read.call(this);\n    } catch {\n      hasteMap = this._createEmptyMap();\n    }\n\n    return this._crawl(hasteMap);\n  }\n  /**\n   * 3. parse and extract metadata from changed files.\n   */\n\n  _processFile(hasteMap, map, mocks, filePath, workerOptions) {\n    const rootDir = this._options.rootDir;\n\n    const setModule = (id, module) => {\n      let moduleMap = map.get(id);\n\n      if (!moduleMap) {\n        moduleMap = Object.create(null);\n        map.set(id, moduleMap);\n      }\n\n      const platform =\n        (0, _getPlatformExtension.default)(\n          module[_constants.default.PATH],\n          this._options.platforms\n        ) || _constants.default.GENERIC_PLATFORM;\n\n      const existingModule = moduleMap[platform];\n\n      if (\n        existingModule &&\n        existingModule[_constants.default.PATH] !==\n          module[_constants.default.PATH]\n      ) {\n        const method = this._options.throwOnModuleCollision ? 'error' : 'warn';\n\n        this._console[method](\n          [\n            `jest-haste-map: Haste module naming collision: ${id}`,\n            '  The following files share their name; please adjust your hasteImpl:',\n            `    * <rootDir>${path().sep}${\n              existingModule[_constants.default.PATH]\n            }`,\n            `    * <rootDir>${path().sep}${module[_constants.default.PATH]}`,\n            ''\n          ].join('\\n')\n        );\n\n        if (this._options.throwOnModuleCollision) {\n          throw new DuplicateError(\n            existingModule[_constants.default.PATH],\n            module[_constants.default.PATH]\n          );\n        } // We do NOT want consumers to use a module that is ambiguous.\n\n        delete moduleMap[platform];\n\n        if (Object.keys(moduleMap).length === 1) {\n          map.delete(id);\n        }\n\n        let dupsByPlatform = hasteMap.duplicates.get(id);\n\n        if (dupsByPlatform == null) {\n          dupsByPlatform = new Map();\n          hasteMap.duplicates.set(id, dupsByPlatform);\n        }\n\n        const dups = new Map([\n          [module[_constants.default.PATH], module[_constants.default.TYPE]],\n          [\n            existingModule[_constants.default.PATH],\n            existingModule[_constants.default.TYPE]\n          ]\n        ]);\n        dupsByPlatform.set(platform, dups);\n        return;\n      }\n\n      const dupsByPlatform = hasteMap.duplicates.get(id);\n\n      if (dupsByPlatform != null) {\n        const dups = dupsByPlatform.get(platform);\n\n        if (dups != null) {\n          dups.set(\n            module[_constants.default.PATH],\n            module[_constants.default.TYPE]\n          );\n        }\n\n        return;\n      }\n\n      moduleMap[platform] = module;\n    };\n\n    const relativeFilePath = fastPath.relative(rootDir, filePath);\n    const fileMetadata = hasteMap.files.get(relativeFilePath);\n\n    if (!fileMetadata) {\n      throw new Error(\n        'jest-haste-map: File to process was not found in the haste map.'\n      );\n    }\n\n    const moduleMetadata = hasteMap.map.get(\n      fileMetadata[_constants.default.ID]\n    );\n    const computeSha1 =\n      this._options.computeSha1 && !fileMetadata[_constants.default.SHA1]; // Callback called when the response from the worker is successful.\n\n    const workerReply = metadata => {\n      // `1` for truthy values instead of `true` to save cache space.\n      fileMetadata[_constants.default.VISITED] = 1;\n      const metadataId = metadata.id;\n      const metadataModule = metadata.module;\n\n      if (metadataId && metadataModule) {\n        fileMetadata[_constants.default.ID] = metadataId;\n        setModule(metadataId, metadataModule);\n      }\n\n      fileMetadata[_constants.default.DEPENDENCIES] = metadata.dependencies\n        ? metadata.dependencies.join(_constants.default.DEPENDENCY_DELIM)\n        : '';\n\n      if (computeSha1) {\n        fileMetadata[_constants.default.SHA1] = metadata.sha1;\n      }\n    }; // Callback called when the response from the worker is an error.\n\n    const workerError = error => {\n      if (typeof error !== 'object' || !error.message || !error.stack) {\n        error = new Error(error);\n        error.stack = ''; // Remove stack for stack-less errors.\n      }\n\n      if (!['ENOENT', 'EACCES'].includes(error.code)) {\n        throw error;\n      } // If a file cannot be read we remove it from the file list and\n      // ignore the failure silently.\n\n      hasteMap.files.delete(relativeFilePath);\n    }; // If we retain all files in the virtual HasteFS representation, we avoid\n    // reading them if they aren't important (node_modules).\n\n    if (this._options.retainAllFiles && filePath.includes(NODE_MODULES)) {\n      if (computeSha1) {\n        return this._getWorker(workerOptions)\n          .getSha1({\n            computeDependencies: this._options.computeDependencies,\n            computeSha1,\n            dependencyExtractor: this._options.dependencyExtractor,\n            filePath,\n            hasteImplModulePath: this._options.hasteImplModulePath,\n            rootDir\n          })\n          .then(workerReply, workerError);\n      }\n\n      return null;\n    }\n\n    if (\n      this._options.mocksPattern &&\n      this._options.mocksPattern.test(filePath)\n    ) {\n      const mockPath = (0, _getMockName.default)(filePath);\n      const existingMockPath = mocks.get(mockPath);\n\n      if (existingMockPath) {\n        const secondMockPath = fastPath.relative(rootDir, filePath);\n\n        if (existingMockPath !== secondMockPath) {\n          const method = this._options.throwOnModuleCollision\n            ? 'error'\n            : 'warn';\n\n          this._console[method](\n            [\n              `jest-haste-map: duplicate manual mock found: ${mockPath}`,\n              '  The following files share their name; please delete one of them:',\n              `    * <rootDir>${path().sep}${existingMockPath}`,\n              `    * <rootDir>${path().sep}${secondMockPath}`,\n              ''\n            ].join('\\n')\n          );\n\n          if (this._options.throwOnModuleCollision) {\n            throw new DuplicateError(existingMockPath, secondMockPath);\n          }\n        }\n      }\n\n      mocks.set(mockPath, relativeFilePath);\n    }\n\n    if (fileMetadata[_constants.default.VISITED]) {\n      if (!fileMetadata[_constants.default.ID]) {\n        return null;\n      }\n\n      if (moduleMetadata != null) {\n        const platform =\n          (0, _getPlatformExtension.default)(\n            filePath,\n            this._options.platforms\n          ) || _constants.default.GENERIC_PLATFORM;\n\n        const module = moduleMetadata[platform];\n\n        if (module == null) {\n          return null;\n        }\n\n        const moduleId = fileMetadata[_constants.default.ID];\n        let modulesByPlatform = map.get(moduleId);\n\n        if (!modulesByPlatform) {\n          modulesByPlatform = Object.create(null);\n          map.set(moduleId, modulesByPlatform);\n        }\n\n        modulesByPlatform[platform] = module;\n        return null;\n      }\n    }\n\n    return this._getWorker(workerOptions)\n      .worker({\n        computeDependencies: this._options.computeDependencies,\n        computeSha1,\n        dependencyExtractor: this._options.dependencyExtractor,\n        filePath,\n        hasteImplModulePath: this._options.hasteImplModulePath,\n        rootDir\n      })\n      .then(workerReply, workerError);\n  }\n\n  _buildHasteMap(data) {\n    const {removedFiles, changedFiles, hasteMap} = data; // If any files were removed or we did not track what files changed, process\n    // every file looking for changes. Otherwise, process only changed files.\n\n    let map;\n    let mocks;\n    let filesToProcess;\n\n    if (changedFiles === undefined || removedFiles.size) {\n      map = new Map();\n      mocks = new Map();\n      filesToProcess = hasteMap.files;\n    } else {\n      map = hasteMap.map;\n      mocks = hasteMap.mocks;\n      filesToProcess = changedFiles;\n    }\n\n    for (const [relativeFilePath, fileMetadata] of removedFiles) {\n      this._recoverDuplicates(\n        hasteMap,\n        relativeFilePath,\n        fileMetadata[_constants.default.ID]\n      );\n    }\n\n    const promises = [];\n\n    for (const relativeFilePath of filesToProcess.keys()) {\n      if (\n        this._options.skipPackageJson &&\n        relativeFilePath.endsWith(PACKAGE_JSON)\n      ) {\n        continue;\n      } // SHA-1, if requested, should already be present thanks to the crawler.\n\n      const filePath = fastPath.resolve(\n        this._options.rootDir,\n        relativeFilePath\n      );\n\n      const promise = this._processFile(hasteMap, map, mocks, filePath);\n\n      if (promise) {\n        promises.push(promise);\n      }\n    }\n\n    return Promise.all(promises).then(\n      () => {\n        this._cleanup();\n\n        hasteMap.map = map;\n        hasteMap.mocks = mocks;\n        return hasteMap;\n      },\n      error => {\n        this._cleanup();\n\n        throw error;\n      }\n    );\n  }\n\n  _cleanup() {\n    const worker = this._worker;\n\n    if (worker && 'end' in worker) {\n      worker.end();\n    }\n\n    this._worker = null;\n  }\n  /**\n   * 4. serialize the new `HasteMap` in a cache file.\n   */\n\n  _persist(hasteMap) {\n    (0, _gracefulFs().writeFileSync)(\n      this._cachePath,\n      (0, _v().serialize)(hasteMap)\n    );\n  }\n  /**\n   * Creates workers or parses files and extracts metadata in-process.\n   */\n\n  _getWorker(\n    options = {\n      forceInBand: false\n    }\n  ) {\n    if (!this._worker) {\n      if (options.forceInBand || this._options.maxWorkers <= 1) {\n        this._worker = {\n          getSha1: _worker.getSha1,\n          worker: _worker.worker\n        };\n      } else {\n        this._worker = new (_jestWorker().Worker)(require.resolve('./worker'), {\n          exposedMethods: ['getSha1', 'worker'],\n          // @ts-expect-error: option does not exist on the node 12 types\n          forkOptions: {\n            serialization: 'json'\n          },\n          maxRetries: 3,\n          numWorkers: this._options.maxWorkers\n        });\n      }\n    }\n\n    return this._worker;\n  }\n\n  async _crawl(hasteMap) {\n    const options = this._options;\n\n    const ignore = this._ignore.bind(this);\n\n    const crawl = (await this._shouldUseWatchman())\n      ? _watchman.watchmanCrawl\n      : _node.nodeCrawl;\n    const crawlerOptions = {\n      computeSha1: options.computeSha1,\n      data: hasteMap,\n      enableSymlinks: options.enableSymlinks,\n      extensions: options.extensions,\n      forceNodeFilesystemAPI: options.forceNodeFilesystemAPI,\n      ignore,\n      rootDir: options.rootDir,\n      roots: options.roots\n    };\n\n    const retry = error => {\n      if (crawl === _watchman.watchmanCrawl) {\n        this._console.warn(\n          'jest-haste-map: Watchman crawl failed. Retrying once with node ' +\n            'crawler.\\n' +\n            \"  Usually this happens when watchman isn't running. Create an \" +\n            \"empty `.watchmanconfig` file in your project's root folder or \" +\n            'initialize a git or hg repository in your project.\\n' +\n            `  ${error}`\n        );\n\n        return (0, _node.nodeCrawl)(crawlerOptions).catch(e => {\n          throw new Error(\n            'Crawler retry failed:\\n' +\n              `  Original error: ${error.message}\\n` +\n              `  Retry error: ${e.message}\\n`\n          );\n        });\n      }\n\n      throw error;\n    };\n\n    try {\n      return crawl(crawlerOptions).catch(retry);\n    } catch (error) {\n      return retry(error);\n    }\n  }\n  /**\n   * Watch mode\n   */\n\n  async _watch(hasteMap) {\n    if (!this._options.watch) {\n      return Promise.resolve();\n    } // In watch mode, we'll only warn about module collisions and we'll retain\n    // all files, even changes to node_modules.\n\n    this._options.throwOnModuleCollision = false;\n    this._options.retainAllFiles = true; // WatchmanWatcher > FSEventsWatcher > sane.NodeWatcher\n\n    const Watcher = (await this._shouldUseWatchman())\n      ? _WatchmanWatcher.default\n      : _FSEventsWatcher.FSEventsWatcher.isSupported()\n      ? _FSEventsWatcher.FSEventsWatcher\n      : _NodeWatcher.default;\n    const extensions = this._options.extensions;\n    const ignorePattern = this._options.ignorePattern;\n    const rootDir = this._options.rootDir;\n    let changeQueue = Promise.resolve();\n    let eventsQueue = []; // We only need to copy the entire haste map once on every \"frame\".\n\n    let mustCopy = true;\n\n    const createWatcher = root => {\n      const watcher = new Watcher(root, {\n        dot: true,\n        glob: extensions.map(extension => `**/*.${extension}`),\n        ignored: ignorePattern\n      });\n      return new Promise((resolve, reject) => {\n        const rejectTimeout = setTimeout(\n          () => reject(new Error('Failed to start watch mode.')),\n          MAX_WAIT_TIME\n        );\n        watcher.once('ready', () => {\n          clearTimeout(rejectTimeout);\n          watcher.on('all', onChange);\n          resolve(watcher);\n        });\n      });\n    };\n\n    const emitChange = () => {\n      if (eventsQueue.length) {\n        mustCopy = true;\n        const changeEvent = {\n          eventsQueue,\n          hasteFS: new _HasteFS.default({\n            files: hasteMap.files,\n            rootDir\n          }),\n          moduleMap: new _ModuleMap.default({\n            duplicates: hasteMap.duplicates,\n            map: hasteMap.map,\n            mocks: hasteMap.mocks,\n            rootDir\n          })\n        };\n        this.emit('change', changeEvent);\n        eventsQueue = [];\n      }\n    };\n\n    const onChange = (type, filePath, root, stat) => {\n      filePath = path().join(root, (0, _normalizePathSep.default)(filePath));\n\n      if (\n        (stat && stat.isDirectory()) ||\n        this._ignore(filePath) ||\n        !extensions.some(extension => filePath.endsWith(extension))\n      ) {\n        return;\n      }\n\n      const relativeFilePath = fastPath.relative(rootDir, filePath);\n      const fileMetadata = hasteMap.files.get(relativeFilePath); // The file has been accessed, not modified\n\n      if (\n        type === 'change' &&\n        fileMetadata &&\n        stat &&\n        fileMetadata[_constants.default.MTIME] === stat.mtime.getTime()\n      ) {\n        return;\n      }\n\n      changeQueue = changeQueue\n        .then(() => {\n          // If we get duplicate events for the same file, ignore them.\n          if (\n            eventsQueue.find(\n              event =>\n                event.type === type &&\n                event.filePath === filePath &&\n                ((!event.stat && !stat) ||\n                  (!!event.stat &&\n                    !!stat &&\n                    event.stat.mtime.getTime() === stat.mtime.getTime()))\n            )\n          ) {\n            return null;\n          }\n\n          if (mustCopy) {\n            mustCopy = false;\n            hasteMap = {\n              clocks: new Map(hasteMap.clocks),\n              duplicates: new Map(hasteMap.duplicates),\n              files: new Map(hasteMap.files),\n              map: new Map(hasteMap.map),\n              mocks: new Map(hasteMap.mocks)\n            };\n          }\n\n          const add = () => {\n            eventsQueue.push({\n              filePath,\n              stat,\n              type\n            });\n            return null;\n          };\n\n          const fileMetadata = hasteMap.files.get(relativeFilePath); // If it's not an addition, delete the file and all its metadata\n\n          if (fileMetadata != null) {\n            const moduleName = fileMetadata[_constants.default.ID];\n\n            const platform =\n              (0, _getPlatformExtension.default)(\n                filePath,\n                this._options.platforms\n              ) || _constants.default.GENERIC_PLATFORM;\n\n            hasteMap.files.delete(relativeFilePath);\n            let moduleMap = hasteMap.map.get(moduleName);\n\n            if (moduleMap != null) {\n              // We are forced to copy the object because jest-haste-map exposes\n              // the map as an immutable entity.\n              moduleMap = copy(moduleMap);\n              delete moduleMap[platform];\n\n              if (Object.keys(moduleMap).length === 0) {\n                hasteMap.map.delete(moduleName);\n              } else {\n                hasteMap.map.set(moduleName, moduleMap);\n              }\n            }\n\n            if (\n              this._options.mocksPattern &&\n              this._options.mocksPattern.test(filePath)\n            ) {\n              const mockName = (0, _getMockName.default)(filePath);\n              hasteMap.mocks.delete(mockName);\n            }\n\n            this._recoverDuplicates(hasteMap, relativeFilePath, moduleName);\n          } // If the file was added or changed,\n          // parse it and update the haste map.\n\n          if (type === 'add' || type === 'change') {\n            invariant(\n              stat,\n              'since the file exists or changed, it should have stats'\n            );\n            const fileMetadata = [\n              '',\n              stat.mtime.getTime(),\n              stat.size,\n              0,\n              '',\n              null\n            ];\n            hasteMap.files.set(relativeFilePath, fileMetadata);\n\n            const promise = this._processFile(\n              hasteMap,\n              hasteMap.map,\n              hasteMap.mocks,\n              filePath,\n              {\n                forceInBand: true\n              }\n            ); // Cleanup\n\n            this._cleanup();\n\n            if (promise) {\n              return promise.then(add);\n            } else {\n              // If a file in node_modules has changed,\n              // emit an event regardless.\n              add();\n            }\n          } else {\n            add();\n          }\n\n          return null;\n        })\n        .catch(error => {\n          this._console.error(\n            `jest-haste-map: watch error:\\n  ${error.stack}\\n`\n          );\n        });\n    };\n\n    this._changeInterval = setInterval(emitChange, CHANGE_INTERVAL);\n    return Promise.all(this._options.roots.map(createWatcher)).then(\n      watchers => {\n        this._watchers = watchers;\n      }\n    );\n  }\n  /**\n   * This function should be called when the file under `filePath` is removed\n   * or changed. When that happens, we want to figure out if that file was\n   * part of a group of files that had the same ID. If it was, we want to\n   * remove it from the group. Furthermore, if there is only one file\n   * remaining in the group, then we want to restore that single file as the\n   * correct resolution for its ID, and cleanup the duplicates index.\n   */\n\n  _recoverDuplicates(hasteMap, relativeFilePath, moduleName) {\n    let dupsByPlatform = hasteMap.duplicates.get(moduleName);\n\n    if (dupsByPlatform == null) {\n      return;\n    }\n\n    const platform =\n      (0, _getPlatformExtension.default)(\n        relativeFilePath,\n        this._options.platforms\n      ) || _constants.default.GENERIC_PLATFORM;\n\n    let dups = dupsByPlatform.get(platform);\n\n    if (dups == null) {\n      return;\n    }\n\n    dupsByPlatform = copyMap(dupsByPlatform);\n    hasteMap.duplicates.set(moduleName, dupsByPlatform);\n    dups = copyMap(dups);\n    dupsByPlatform.set(platform, dups);\n    dups.delete(relativeFilePath);\n\n    if (dups.size !== 1) {\n      return;\n    }\n\n    const uniqueModule = dups.entries().next().value;\n\n    if (!uniqueModule) {\n      return;\n    }\n\n    let dedupMap = hasteMap.map.get(moduleName);\n\n    if (!dedupMap) {\n      dedupMap = Object.create(null);\n      hasteMap.map.set(moduleName, dedupMap);\n    }\n\n    dedupMap[platform] = uniqueModule;\n    dupsByPlatform.delete(platform);\n\n    if (dupsByPlatform.size === 0) {\n      hasteMap.duplicates.delete(moduleName);\n    }\n  }\n\n  async end() {\n    if (this._changeInterval) {\n      clearInterval(this._changeInterval);\n    }\n\n    if (!this._watchers.length) {\n      return;\n    }\n\n    await Promise.all(this._watchers.map(watcher => watcher.close()));\n    this._watchers = [];\n  }\n  /**\n   * Helpers\n   */\n\n  _ignore(filePath) {\n    const ignorePattern = this._options.ignorePattern;\n    const ignoreMatched =\n      ignorePattern instanceof RegExp\n        ? ignorePattern.test(filePath)\n        : ignorePattern && ignorePattern(filePath);\n    return (\n      ignoreMatched ||\n      (!this._options.retainAllFiles && filePath.includes(NODE_MODULES))\n    );\n  }\n\n  async _shouldUseWatchman() {\n    if (!this._options.useWatchman) {\n      return false;\n    }\n\n    if (!this._isWatchmanInstalledPromise) {\n      this._isWatchmanInstalledPromise = (0, _isWatchmanInstalled.default)();\n    }\n\n    return this._isWatchmanInstalledPromise;\n  }\n\n  _createEmptyMap() {\n    return {\n      clocks: new Map(),\n      duplicates: new Map(),\n      files: new Map(),\n      map: new Map(),\n      mocks: new Map()\n    };\n  }\n\n  static H = _constants.default;\n}\n\nexports.default = HasteMap;\n\nclass DuplicateError extends Error {\n  mockPath1;\n  mockPath2;\n\n  constructor(mockPath1, mockPath2) {\n    super('Duplicated files or mocks. Please check the console for more info');\n    this.mockPath1 = mockPath1;\n    this.mockPath2 = mockPath2;\n  }\n}\n\nexports.DuplicateError = DuplicateError;\n\nfunction copy(object) {\n  return Object.assign(Object.create(null), object);\n}\n\nfunction copyMap(input) {\n  return new Map(input);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}