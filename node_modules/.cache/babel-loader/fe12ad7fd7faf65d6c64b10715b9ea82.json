{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.createTestScheduler = createTestScheduler;\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _ciInfo() {\n  const data = require('ci-info');\n\n  _ciInfo = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _exit() {\n  const data = _interopRequireDefault(require('exit'));\n\n  _exit = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _reporters() {\n  const data = require('@jest/reporters');\n\n  _reporters = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _testResult() {\n  const data = require('@jest/test-result');\n\n  _testResult = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _transform() {\n  const data = require('@jest/transform');\n\n  _transform = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSnapshot() {\n  const data = require('jest-snapshot');\n\n  _jestSnapshot = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _ReporterDispatcher = _interopRequireDefault(require('./ReporterDispatcher'));\n\nvar _testSchedulerHelper = require('./testSchedulerHelper');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nasync function createTestScheduler(globalConfig, context) {\n  const scheduler = new TestScheduler(globalConfig, context);\n  await scheduler._setupReporters();\n  return scheduler;\n}\n\nclass TestScheduler {\n  _context;\n  _dispatcher;\n  _globalConfig;\n\n  constructor(globalConfig, context) {\n    this._context = context;\n    this._dispatcher = new _ReporterDispatcher.default();\n    this._globalConfig = globalConfig;\n  }\n\n  addReporter(reporter) {\n    this._dispatcher.register(reporter);\n  }\n\n  removeReporter(reporterConstructor) {\n    this._dispatcher.unregister(reporterConstructor);\n  }\n\n  async scheduleTests(tests, watcher) {\n    const onTestFileStart = this._dispatcher.onTestFileStart.bind(this._dispatcher);\n\n    const timings = [];\n    const testContexts = new Set();\n    tests.forEach(test => {\n      testContexts.add(test.context);\n\n      if (test.duration) {\n        timings.push(test.duration);\n      }\n    });\n    const aggregatedResults = createAggregatedResults(tests.length);\n    const estimatedTime = Math.ceil(getEstimatedTime(timings, this._globalConfig.maxWorkers) / 1000);\n    const runInBand = (0, _testSchedulerHelper.shouldRunInBand)(tests, timings, this._globalConfig);\n\n    const onResult = async (test, testResult) => {\n      if (watcher.isInterrupted()) {\n        return Promise.resolve();\n      }\n\n      if (testResult.testResults.length === 0) {\n        const message = 'Your test suite must contain at least one test.';\n        return onFailure(test, {\n          message,\n          stack: new Error(message).stack\n        });\n      } // Throws when the context is leaked after executing a test.\n\n\n      if (testResult.leaks) {\n        const message = `${_chalk().default.red.bold('EXPERIMENTAL FEATURE!\\n')}Your test suite is leaking memory. Please ensure all references are cleaned.\\n` + '\\n' + 'There is a number of things that can leak memory:\\n' + '  - Async operations that have not finished (e.g. fs.readFile).\\n' + '  - Timers not properly mocked (e.g. setInterval, setTimeout).\\n' + '  - Keeping references to the global scope.';\n        return onFailure(test, {\n          message,\n          stack: new Error(message).stack\n        });\n      }\n\n      (0, _testResult().addResult)(aggregatedResults, testResult);\n      await this._dispatcher.onTestFileResult(test, testResult, aggregatedResults);\n      return this._bailIfNeeded(testContexts, aggregatedResults, watcher);\n    };\n\n    const onFailure = async (test, error) => {\n      if (watcher.isInterrupted()) {\n        return;\n      }\n\n      const testResult = (0, _testResult().buildFailureTestResult)(test.path, error);\n      testResult.failureMessage = (0, _jestMessageUtil().formatExecError)(testResult.testExecError, test.context.config, this._globalConfig, test.path);\n      (0, _testResult().addResult)(aggregatedResults, testResult);\n      await this._dispatcher.onTestFileResult(test, testResult, aggregatedResults);\n    };\n\n    const updateSnapshotState = async () => {\n      const contextsWithSnapshotResolvers = await Promise.all(Array.from(testContexts).map(async context => [context, await (0, _jestSnapshot().buildSnapshotResolver)(context.config)]));\n      contextsWithSnapshotResolvers.forEach(_ref => {\n        let [context, snapshotResolver] = _ref;\n        const status = (0, _jestSnapshot().cleanup)(context.hasteFS, this._globalConfig.updateSnapshot, snapshotResolver, context.config.testPathIgnorePatterns);\n        aggregatedResults.snapshot.filesRemoved += status.filesRemoved;\n        aggregatedResults.snapshot.filesRemovedList = (aggregatedResults.snapshot.filesRemovedList || []).concat(status.filesRemovedList);\n      });\n      const updateAll = this._globalConfig.updateSnapshot === 'all';\n      aggregatedResults.snapshot.didUpdate = updateAll;\n      aggregatedResults.snapshot.failure = !!(!updateAll && (aggregatedResults.snapshot.unchecked || aggregatedResults.snapshot.unmatched || aggregatedResults.snapshot.filesRemoved));\n    };\n\n    await this._dispatcher.onRunStart(aggregatedResults, {\n      estimatedTime,\n      showStatus: !runInBand\n    });\n    const testRunners = Object.create(null);\n    const contextsByTestRunner = new WeakMap();\n    await Promise.all(Array.from(testContexts).map(async context => {\n      const {\n        config\n      } = context;\n\n      if (!testRunners[config.runner]) {\n        const transformer = await (0, _transform().createScriptTransformer)(config);\n        const Runner = await transformer.requireAndTranspileModule(config.runner);\n        const runner = new Runner(this._globalConfig, {\n          changedFiles: this._context.changedFiles,\n          sourcesRelatedToTestsInChangedFiles: this._context.sourcesRelatedToTestsInChangedFiles\n        });\n        testRunners[config.runner] = runner;\n        contextsByTestRunner.set(runner, context);\n      }\n    }));\n\n    const testsByRunner = this._partitionTests(testRunners, tests);\n\n    if (testsByRunner) {\n      try {\n        for (const runner of Object.keys(testRunners)) {\n          const testRunner = testRunners[runner];\n          const context = contextsByTestRunner.get(testRunner);\n          invariant(context);\n          const tests = testsByRunner[runner];\n          const testRunnerOptions = {\n            serial: runInBand || Boolean(testRunner.isSerial)\n          };\n\n          if (testRunner.supportsEventEmitters) {\n            const unsubscribes = [testRunner.on('test-file-start', _ref2 => {\n              let [test] = _ref2;\n              return onTestFileStart(test);\n            }), testRunner.on('test-file-success', _ref3 => {\n              let [test, testResult] = _ref3;\n              return onResult(test, testResult);\n            }), testRunner.on('test-file-failure', _ref4 => {\n              let [test, error] = _ref4;\n              return onFailure(test, error);\n            }), testRunner.on('test-case-result', _ref5 => {\n              let [testPath, testCaseResult] = _ref5;\n              const test = {\n                context,\n                path: testPath\n              };\n\n              this._dispatcher.onTestCaseResult(test, testCaseResult);\n            })];\n            await testRunner.runTests(tests, watcher, testRunnerOptions);\n            unsubscribes.forEach(sub => sub());\n          } else {\n            await testRunner.runTests(tests, watcher, onTestFileStart, onResult, onFailure, testRunnerOptions);\n          }\n        }\n      } catch (error) {\n        if (!watcher.isInterrupted()) {\n          throw error;\n        }\n      }\n    }\n\n    await updateSnapshotState();\n    aggregatedResults.wasInterrupted = watcher.isInterrupted();\n    await this._dispatcher.onRunComplete(testContexts, aggregatedResults);\n    const anyTestFailures = !(aggregatedResults.numFailedTests === 0 && aggregatedResults.numRuntimeErrorTestSuites === 0);\n\n    const anyReporterErrors = this._dispatcher.hasErrors();\n\n    aggregatedResults.success = !(anyTestFailures || aggregatedResults.snapshot.failure || anyReporterErrors);\n    return aggregatedResults;\n  }\n\n  _partitionTests(testRunners, tests) {\n    if (Object.keys(testRunners).length > 1) {\n      return tests.reduce((testRuns, test) => {\n        const runner = test.context.config.runner;\n\n        if (!testRuns[runner]) {\n          testRuns[runner] = [];\n        }\n\n        testRuns[runner].push(test);\n        return testRuns;\n      }, Object.create(null));\n    } else if (tests.length > 0 && tests[0] != null) {\n      // If there is only one runner, don't partition the tests.\n      return Object.assign(Object.create(null), {\n        [tests[0].context.config.runner]: tests\n      });\n    } else {\n      return null;\n    }\n  }\n\n  async _setupReporters() {\n    const {\n      collectCoverage: coverage,\n      notify,\n      verbose\n    } = this._globalConfig;\n    const reporters = this._globalConfig.reporters || [['default', {}]];\n    let summary = false;\n\n    for (const [reporter, options] of reporters) {\n      switch (reporter) {\n        case 'default':\n          summary = true;\n          verbose ? this.addReporter(new (_reporters().VerboseReporter)(this._globalConfig)) : this.addReporter(new (_reporters().DefaultReporter)(this._globalConfig));\n          break;\n\n        case 'github-actions':\n          _ciInfo().GITHUB_ACTIONS && this.addReporter(new (_reporters().GitHubActionsReporter)());\n          break;\n\n        case 'summary':\n          summary = true;\n          break;\n\n        default:\n          await this._addCustomReporter(reporter, options);\n      }\n    }\n\n    if (notify) {\n      this.addReporter(new (_reporters().NotifyReporter)(this._globalConfig, this._context));\n    }\n\n    if (coverage) {\n      this.addReporter(new (_reporters().CoverageReporter)(this._globalConfig, this._context));\n    }\n\n    if (summary) {\n      this.addReporter(new (_reporters().SummaryReporter)(this._globalConfig));\n    }\n  }\n\n  async _addCustomReporter(reporter, options) {\n    try {\n      const Reporter = await (0, _jestUtil().requireOrImportModule)(reporter);\n      this.addReporter(new Reporter(this._globalConfig, options, this._context));\n    } catch (error) {\n      error.message = `An error occurred while adding the reporter at path \"${_chalk().default.bold(reporter)}\".\\n${error instanceof Error ? error.message : ''}`;\n      throw error;\n    }\n  }\n\n  async _bailIfNeeded(testContexts, aggregatedResults, watcher) {\n    if (this._globalConfig.bail !== 0 && aggregatedResults.numFailedTests >= this._globalConfig.bail) {\n      if (watcher.isWatchMode()) {\n        await watcher.setState({\n          interrupted: true\n        });\n        return;\n      }\n\n      try {\n        await this._dispatcher.onRunComplete(testContexts, aggregatedResults);\n      } finally {\n        const exitCode = this._globalConfig.testFailureExitCode;\n        (0, _exit().default)(exitCode);\n      }\n    }\n  }\n\n}\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nconst createAggregatedResults = numTotalTestSuites => {\n  const result = (0, _testResult().makeEmptyAggregatedTestResult)();\n  result.numTotalTestSuites = numTotalTestSuites;\n  result.startTime = Date.now();\n  result.success = false;\n  return result;\n};\n\nconst getEstimatedTime = (timings, workers) => {\n  if (timings.length === 0) {\n    return 0;\n  }\n\n  const max = Math.max(...timings);\n  return timings.length <= workers ? max : Math.max(timings.reduce((sum, time) => sum + time) / workers, max);\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","createTestScheduler","_chalk","data","_interopRequireDefault","require","_ciInfo","_exit","_reporters","_testResult","_transform","_jestMessageUtil","_jestSnapshot","_jestUtil","_ReporterDispatcher","_testSchedulerHelper","obj","__esModule","default","globalConfig","context","scheduler","TestScheduler","_setupReporters","_context","_dispatcher","_globalConfig","constructor","addReporter","reporter","register","removeReporter","reporterConstructor","unregister","scheduleTests","tests","watcher","onTestFileStart","bind","timings","testContexts","Set","forEach","test","add","duration","push","aggregatedResults","createAggregatedResults","length","estimatedTime","Math","ceil","getEstimatedTime","maxWorkers","runInBand","shouldRunInBand","onResult","testResult","isInterrupted","Promise","resolve","testResults","message","onFailure","stack","Error","leaks","red","bold","addResult","onTestFileResult","_bailIfNeeded","error","buildFailureTestResult","path","failureMessage","formatExecError","testExecError","config","updateSnapshotState","contextsWithSnapshotResolvers","all","Array","from","map","buildSnapshotResolver","snapshotResolver","status","cleanup","hasteFS","updateSnapshot","testPathIgnorePatterns","snapshot","filesRemoved","filesRemovedList","concat","updateAll","didUpdate","failure","unchecked","unmatched","onRunStart","showStatus","testRunners","create","contextsByTestRunner","WeakMap","runner","transformer","createScriptTransformer","Runner","requireAndTranspileModule","changedFiles","sourcesRelatedToTestsInChangedFiles","set","testsByRunner","_partitionTests","keys","testRunner","get","invariant","testRunnerOptions","serial","Boolean","isSerial","supportsEventEmitters","unsubscribes","on","testPath","testCaseResult","onTestCaseResult","runTests","sub","wasInterrupted","onRunComplete","anyTestFailures","numFailedTests","numRuntimeErrorTestSuites","anyReporterErrors","hasErrors","success","reduce","testRuns","assign","collectCoverage","coverage","notify","verbose","reporters","summary","options","VerboseReporter","DefaultReporter","GITHUB_ACTIONS","GitHubActionsReporter","_addCustomReporter","NotifyReporter","CoverageReporter","SummaryReporter","Reporter","requireOrImportModule","bail","isWatchMode","setState","interrupted","exitCode","testFailureExitCode","condition","numTotalTestSuites","result","makeEmptyAggregatedTestResult","startTime","Date","now","workers","max","sum","time"],"sources":["/Users/wonjaelee/Desktop/final/node_modules/@jest/core/build/TestScheduler.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.createTestScheduler = createTestScheduler;\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _ciInfo() {\n  const data = require('ci-info');\n\n  _ciInfo = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _exit() {\n  const data = _interopRequireDefault(require('exit'));\n\n  _exit = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _reporters() {\n  const data = require('@jest/reporters');\n\n  _reporters = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _testResult() {\n  const data = require('@jest/test-result');\n\n  _testResult = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _transform() {\n  const data = require('@jest/transform');\n\n  _transform = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSnapshot() {\n  const data = require('jest-snapshot');\n\n  _jestSnapshot = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _ReporterDispatcher = _interopRequireDefault(\n  require('./ReporterDispatcher')\n);\n\nvar _testSchedulerHelper = require('./testSchedulerHelper');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nasync function createTestScheduler(globalConfig, context) {\n  const scheduler = new TestScheduler(globalConfig, context);\n  await scheduler._setupReporters();\n  return scheduler;\n}\n\nclass TestScheduler {\n  _context;\n  _dispatcher;\n  _globalConfig;\n\n  constructor(globalConfig, context) {\n    this._context = context;\n    this._dispatcher = new _ReporterDispatcher.default();\n    this._globalConfig = globalConfig;\n  }\n\n  addReporter(reporter) {\n    this._dispatcher.register(reporter);\n  }\n\n  removeReporter(reporterConstructor) {\n    this._dispatcher.unregister(reporterConstructor);\n  }\n\n  async scheduleTests(tests, watcher) {\n    const onTestFileStart = this._dispatcher.onTestFileStart.bind(\n      this._dispatcher\n    );\n\n    const timings = [];\n    const testContexts = new Set();\n    tests.forEach(test => {\n      testContexts.add(test.context);\n\n      if (test.duration) {\n        timings.push(test.duration);\n      }\n    });\n    const aggregatedResults = createAggregatedResults(tests.length);\n    const estimatedTime = Math.ceil(\n      getEstimatedTime(timings, this._globalConfig.maxWorkers) / 1000\n    );\n    const runInBand = (0, _testSchedulerHelper.shouldRunInBand)(\n      tests,\n      timings,\n      this._globalConfig\n    );\n\n    const onResult = async (test, testResult) => {\n      if (watcher.isInterrupted()) {\n        return Promise.resolve();\n      }\n\n      if (testResult.testResults.length === 0) {\n        const message = 'Your test suite must contain at least one test.';\n        return onFailure(test, {\n          message,\n          stack: new Error(message).stack\n        });\n      } // Throws when the context is leaked after executing a test.\n\n      if (testResult.leaks) {\n        const message =\n          `${_chalk().default.red.bold(\n            'EXPERIMENTAL FEATURE!\\n'\n          )}Your test suite is leaking memory. Please ensure all references are cleaned.\\n` +\n          '\\n' +\n          'There is a number of things that can leak memory:\\n' +\n          '  - Async operations that have not finished (e.g. fs.readFile).\\n' +\n          '  - Timers not properly mocked (e.g. setInterval, setTimeout).\\n' +\n          '  - Keeping references to the global scope.';\n        return onFailure(test, {\n          message,\n          stack: new Error(message).stack\n        });\n      }\n\n      (0, _testResult().addResult)(aggregatedResults, testResult);\n      await this._dispatcher.onTestFileResult(\n        test,\n        testResult,\n        aggregatedResults\n      );\n      return this._bailIfNeeded(testContexts, aggregatedResults, watcher);\n    };\n\n    const onFailure = async (test, error) => {\n      if (watcher.isInterrupted()) {\n        return;\n      }\n\n      const testResult = (0, _testResult().buildFailureTestResult)(\n        test.path,\n        error\n      );\n      testResult.failureMessage = (0, _jestMessageUtil().formatExecError)(\n        testResult.testExecError,\n        test.context.config,\n        this._globalConfig,\n        test.path\n      );\n      (0, _testResult().addResult)(aggregatedResults, testResult);\n      await this._dispatcher.onTestFileResult(\n        test,\n        testResult,\n        aggregatedResults\n      );\n    };\n\n    const updateSnapshotState = async () => {\n      const contextsWithSnapshotResolvers = await Promise.all(\n        Array.from(testContexts).map(async context => [\n          context,\n          await (0, _jestSnapshot().buildSnapshotResolver)(context.config)\n        ])\n      );\n      contextsWithSnapshotResolvers.forEach(([context, snapshotResolver]) => {\n        const status = (0, _jestSnapshot().cleanup)(\n          context.hasteFS,\n          this._globalConfig.updateSnapshot,\n          snapshotResolver,\n          context.config.testPathIgnorePatterns\n        );\n        aggregatedResults.snapshot.filesRemoved += status.filesRemoved;\n        aggregatedResults.snapshot.filesRemovedList = (\n          aggregatedResults.snapshot.filesRemovedList || []\n        ).concat(status.filesRemovedList);\n      });\n      const updateAll = this._globalConfig.updateSnapshot === 'all';\n      aggregatedResults.snapshot.didUpdate = updateAll;\n      aggregatedResults.snapshot.failure = !!(\n        !updateAll &&\n        (aggregatedResults.snapshot.unchecked ||\n          aggregatedResults.snapshot.unmatched ||\n          aggregatedResults.snapshot.filesRemoved)\n      );\n    };\n\n    await this._dispatcher.onRunStart(aggregatedResults, {\n      estimatedTime,\n      showStatus: !runInBand\n    });\n    const testRunners = Object.create(null);\n    const contextsByTestRunner = new WeakMap();\n    await Promise.all(\n      Array.from(testContexts).map(async context => {\n        const {config} = context;\n\n        if (!testRunners[config.runner]) {\n          const transformer = await (0, _transform().createScriptTransformer)(\n            config\n          );\n          const Runner = await transformer.requireAndTranspileModule(\n            config.runner\n          );\n          const runner = new Runner(this._globalConfig, {\n            changedFiles: this._context.changedFiles,\n            sourcesRelatedToTestsInChangedFiles:\n              this._context.sourcesRelatedToTestsInChangedFiles\n          });\n          testRunners[config.runner] = runner;\n          contextsByTestRunner.set(runner, context);\n        }\n      })\n    );\n\n    const testsByRunner = this._partitionTests(testRunners, tests);\n\n    if (testsByRunner) {\n      try {\n        for (const runner of Object.keys(testRunners)) {\n          const testRunner = testRunners[runner];\n          const context = contextsByTestRunner.get(testRunner);\n          invariant(context);\n          const tests = testsByRunner[runner];\n          const testRunnerOptions = {\n            serial: runInBand || Boolean(testRunner.isSerial)\n          };\n\n          if (testRunner.supportsEventEmitters) {\n            const unsubscribes = [\n              testRunner.on('test-file-start', ([test]) =>\n                onTestFileStart(test)\n              ),\n              testRunner.on('test-file-success', ([test, testResult]) =>\n                onResult(test, testResult)\n              ),\n              testRunner.on('test-file-failure', ([test, error]) =>\n                onFailure(test, error)\n              ),\n              testRunner.on(\n                'test-case-result',\n                ([testPath, testCaseResult]) => {\n                  const test = {\n                    context,\n                    path: testPath\n                  };\n\n                  this._dispatcher.onTestCaseResult(test, testCaseResult);\n                }\n              )\n            ];\n            await testRunner.runTests(tests, watcher, testRunnerOptions);\n            unsubscribes.forEach(sub => sub());\n          } else {\n            await testRunner.runTests(\n              tests,\n              watcher,\n              onTestFileStart,\n              onResult,\n              onFailure,\n              testRunnerOptions\n            );\n          }\n        }\n      } catch (error) {\n        if (!watcher.isInterrupted()) {\n          throw error;\n        }\n      }\n    }\n\n    await updateSnapshotState();\n    aggregatedResults.wasInterrupted = watcher.isInterrupted();\n    await this._dispatcher.onRunComplete(testContexts, aggregatedResults);\n    const anyTestFailures = !(\n      aggregatedResults.numFailedTests === 0 &&\n      aggregatedResults.numRuntimeErrorTestSuites === 0\n    );\n\n    const anyReporterErrors = this._dispatcher.hasErrors();\n\n    aggregatedResults.success = !(\n      anyTestFailures ||\n      aggregatedResults.snapshot.failure ||\n      anyReporterErrors\n    );\n    return aggregatedResults;\n  }\n\n  _partitionTests(testRunners, tests) {\n    if (Object.keys(testRunners).length > 1) {\n      return tests.reduce((testRuns, test) => {\n        const runner = test.context.config.runner;\n\n        if (!testRuns[runner]) {\n          testRuns[runner] = [];\n        }\n\n        testRuns[runner].push(test);\n        return testRuns;\n      }, Object.create(null));\n    } else if (tests.length > 0 && tests[0] != null) {\n      // If there is only one runner, don't partition the tests.\n      return Object.assign(Object.create(null), {\n        [tests[0].context.config.runner]: tests\n      });\n    } else {\n      return null;\n    }\n  }\n\n  async _setupReporters() {\n    const {collectCoverage: coverage, notify, verbose} = this._globalConfig;\n    const reporters = this._globalConfig.reporters || [['default', {}]];\n    let summary = false;\n\n    for (const [reporter, options] of reporters) {\n      switch (reporter) {\n        case 'default':\n          summary = true;\n          verbose\n            ? this.addReporter(\n                new (_reporters().VerboseReporter)(this._globalConfig)\n              )\n            : this.addReporter(\n                new (_reporters().DefaultReporter)(this._globalConfig)\n              );\n          break;\n\n        case 'github-actions':\n          _ciInfo().GITHUB_ACTIONS &&\n            this.addReporter(new (_reporters().GitHubActionsReporter)());\n          break;\n\n        case 'summary':\n          summary = true;\n          break;\n\n        default:\n          await this._addCustomReporter(reporter, options);\n      }\n    }\n\n    if (notify) {\n      this.addReporter(\n        new (_reporters().NotifyReporter)(this._globalConfig, this._context)\n      );\n    }\n\n    if (coverage) {\n      this.addReporter(\n        new (_reporters().CoverageReporter)(this._globalConfig, this._context)\n      );\n    }\n\n    if (summary) {\n      this.addReporter(new (_reporters().SummaryReporter)(this._globalConfig));\n    }\n  }\n\n  async _addCustomReporter(reporter, options) {\n    try {\n      const Reporter = await (0, _jestUtil().requireOrImportModule)(reporter);\n      this.addReporter(\n        new Reporter(this._globalConfig, options, this._context)\n      );\n    } catch (error) {\n      error.message = `An error occurred while adding the reporter at path \"${_chalk().default.bold(\n        reporter\n      )}\".\\n${error instanceof Error ? error.message : ''}`;\n      throw error;\n    }\n  }\n\n  async _bailIfNeeded(testContexts, aggregatedResults, watcher) {\n    if (\n      this._globalConfig.bail !== 0 &&\n      aggregatedResults.numFailedTests >= this._globalConfig.bail\n    ) {\n      if (watcher.isWatchMode()) {\n        await watcher.setState({\n          interrupted: true\n        });\n        return;\n      }\n\n      try {\n        await this._dispatcher.onRunComplete(testContexts, aggregatedResults);\n      } finally {\n        const exitCode = this._globalConfig.testFailureExitCode;\n        (0, _exit().default)(exitCode);\n      }\n    }\n  }\n}\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nconst createAggregatedResults = numTotalTestSuites => {\n  const result = (0, _testResult().makeEmptyAggregatedTestResult)();\n  result.numTotalTestSuites = numTotalTestSuites;\n  result.startTime = Date.now();\n  result.success = false;\n  return result;\n};\n\nconst getEstimatedTime = (timings, workers) => {\n  if (timings.length === 0) {\n    return 0;\n  }\n\n  const max = Math.max(...timings);\n  return timings.length <= workers\n    ? max\n    : Math.max(timings.reduce((sum, time) => sum + time) / workers, max);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}