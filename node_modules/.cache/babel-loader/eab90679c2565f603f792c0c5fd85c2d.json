{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.createScriptTransformer = createScriptTransformer;\nexports.createTranspilingRequire = createTranspilingRequire;\n\nfunction _crypto() {\n  const data = require('crypto');\n\n  _crypto = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _core() {\n  const data = require('@babel/core');\n\n  _core = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _babelPluginIstanbul() {\n  const data = _interopRequireDefault(require('babel-plugin-istanbul'));\n\n  _babelPluginIstanbul = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _convertSourceMap() {\n  const data = require('convert-source-map');\n\n  _convertSourceMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fastJsonStableStringify() {\n  const data = _interopRequireDefault(require('fast-json-stable-stringify'));\n\n  _fastJsonStableStringify = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fs() {\n  const data = _interopRequireWildcard(require('graceful-fs'));\n\n  fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _pirates() {\n  const data = require('pirates');\n\n  _pirates = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _slash() {\n  const data = _interopRequireDefault(require('slash'));\n\n  _slash = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _writeFileAtomic() {\n  const data = require('write-file-atomic');\n\n  _writeFileAtomic = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestHasteMap() {\n  const data = _interopRequireDefault(require('jest-haste-map'));\n\n  _jestHasteMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _enhanceUnexpectedTokenMessage = _interopRequireDefault(require('./enhanceUnexpectedTokenMessage'));\n\nvar _runtimeErrorsAndWarnings = require('./runtimeErrorsAndWarnings');\n\nvar _shouldInstrument = _interopRequireDefault(require('./shouldInstrument'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// @ts-expect-error: should just be `require.resolve`, but the tests mess that up\n// Use `require` to avoid TS rootDir\n\n\nconst {\n  version: VERSION\n} = require('../package.json'); // This data structure is used to avoid recalculating some data every time that\n// we need to transform a file. Since ScriptTransformer is instantiated for each\n// file we need to keep this object in the local scope of this module.\n\n\nconst projectCaches = new Map(); // To reset the cache for specific changesets (rather than package version).\n\nconst CACHE_VERSION = '1';\n\nasync function waitForPromiseWithCleanup(promise, cleanup) {\n  try {\n    await promise;\n  } finally {\n    cleanup();\n  }\n} // type predicate\n\n\nfunction isTransformerFactory(t) {\n  return typeof t.createTransformer === 'function';\n}\n\nclass ScriptTransformer {\n  _cache;\n  _transformCache = new Map();\n  _transformsAreLoaded = false;\n\n  constructor(_config, _cacheFS) {\n    this._config = _config;\n    this._cacheFS = _cacheFS;\n    const configString = (0, _fastJsonStableStringify().default)(this._config);\n    let projectCache = projectCaches.get(configString);\n\n    if (!projectCache) {\n      projectCache = {\n        configString,\n        ignorePatternsRegExp: calcIgnorePatternRegExp(this._config),\n        transformRegExp: calcTransformRegExp(this._config),\n        transformedFiles: new Map()\n      };\n      projectCaches.set(configString, projectCache);\n    }\n\n    this._cache = projectCache;\n  }\n\n  _buildCacheKeyFromFileInfo(fileData, filename, transformOptions, transformerCacheKey) {\n    if (transformerCacheKey) {\n      return (0, _crypto().createHash)('sha256').update(transformerCacheKey).update(CACHE_VERSION).digest('hex').substring(0, 32);\n    }\n\n    return (0, _crypto().createHash)('sha256').update(fileData).update(transformOptions.configString).update(transformOptions.instrument ? 'instrument' : '').update(filename).update(CACHE_VERSION).digest('hex').substring(0, 32);\n  }\n\n  _getCacheKey(fileData, filename, options) {\n    const configString = this._cache.configString;\n    const {\n      transformer,\n      transformerConfig = {}\n    } = this._getTransformer(filename) || {};\n    let transformerCacheKey = undefined;\n    const transformOptions = { ...options,\n      cacheFS: this._cacheFS,\n      config: this._config,\n      configString,\n      transformerConfig\n    };\n\n    if (typeof (transformer === null || transformer === void 0 ? void 0 : transformer.getCacheKey) === 'function') {\n      transformerCacheKey = transformer.getCacheKey(fileData, filename, transformOptions);\n    }\n\n    return this._buildCacheKeyFromFileInfo(fileData, filename, transformOptions, transformerCacheKey);\n  }\n\n  async _getCacheKeyAsync(fileData, filename, options) {\n    const configString = this._cache.configString;\n    const {\n      transformer,\n      transformerConfig = {}\n    } = this._getTransformer(filename) || {};\n    let transformerCacheKey = undefined;\n    const transformOptions = { ...options,\n      cacheFS: this._cacheFS,\n      config: this._config,\n      configString,\n      transformerConfig\n    };\n\n    if (transformer) {\n      const getCacheKey = transformer.getCacheKeyAsync || transformer.getCacheKey;\n\n      if (typeof getCacheKey === 'function') {\n        transformerCacheKey = await getCacheKey(fileData, filename, transformOptions);\n      }\n    }\n\n    return this._buildCacheKeyFromFileInfo(fileData, filename, transformOptions, transformerCacheKey);\n  }\n\n  _createFolderFromCacheKey(filename, cacheKey) {\n    const HasteMapClass = _jestHasteMap().default.getStatic(this._config);\n\n    const baseCacheDir = HasteMapClass.getCacheFilePath(this._config.cacheDirectory, `jest-transform-cache-${this._config.id}`, VERSION); // Create sub folders based on the cacheKey to avoid creating one\n    // directory with many files.\n\n    const cacheDir = path().join(baseCacheDir, cacheKey[0] + cacheKey[1]);\n    const cacheFilenamePrefix = path().basename(filename, path().extname(filename)).replace(/\\W/g, '');\n    const cachePath = (0, _slash().default)(path().join(cacheDir, `${cacheFilenamePrefix}_${cacheKey}`));\n    (0, _jestUtil().createDirectory)(cacheDir);\n    return cachePath;\n  }\n\n  _getFileCachePath(filename, content, options) {\n    const cacheKey = this._getCacheKey(content, filename, options);\n\n    return this._createFolderFromCacheKey(filename, cacheKey);\n  }\n\n  async _getFileCachePathAsync(filename, content, options) {\n    const cacheKey = await this._getCacheKeyAsync(content, filename, options);\n    return this._createFolderFromCacheKey(filename, cacheKey);\n  }\n\n  _getTransformPath(filename) {\n    const transformRegExp = this._cache.transformRegExp;\n\n    if (!transformRegExp) {\n      return undefined;\n    }\n\n    for (let i = 0; i < transformRegExp.length; i++) {\n      if (transformRegExp[i][0].test(filename)) {\n        return transformRegExp[i][1];\n      }\n    }\n\n    return undefined;\n  }\n\n  async loadTransformers() {\n    await Promise.all(this._config.transform.map(async _ref => {\n      let [, transformPath, transformerConfig] = _ref;\n      let transformer = await (0, _jestUtil().requireOrImportModule)(transformPath);\n\n      if (!transformer) {\n        throw new Error((0, _runtimeErrorsAndWarnings.makeInvalidTransformerError)(transformPath));\n      }\n\n      if (isTransformerFactory(transformer)) {\n        transformer = transformer.createTransformer(transformerConfig);\n      }\n\n      if (typeof transformer.process !== 'function' && typeof transformer.processAsync !== 'function') {\n        throw new Error((0, _runtimeErrorsAndWarnings.makeInvalidTransformerError)(transformPath));\n      }\n\n      const res = {\n        transformer,\n        transformerConfig\n      };\n\n      this._transformCache.set(transformPath, res);\n    }));\n    this._transformsAreLoaded = true;\n  }\n\n  _getTransformer(filename) {\n    if (!this._transformsAreLoaded) {\n      throw new Error('Jest: Transformers have not been loaded yet - make sure to run `loadTransformers` and wait for it to complete before starting to transform files');\n    }\n\n    if (this._config.transform.length === 0) {\n      return null;\n    }\n\n    const transformPath = this._getTransformPath(filename);\n\n    if (!transformPath) {\n      return null;\n    }\n\n    const cached = this._transformCache.get(transformPath);\n\n    if (cached) {\n      return cached;\n    }\n\n    throw new Error(`Jest was unable to load the transformer defined for ${filename}. This is a bug in Jest, please open up an issue`);\n  }\n\n  _instrumentFile(filename, input, canMapToInput, options) {\n    const inputCode = typeof input === 'string' ? input : input.code;\n    const inputMap = typeof input === 'string' ? null : input.map;\n    const result = (0, _core().transformSync)(inputCode, {\n      auxiliaryCommentBefore: ' istanbul ignore next ',\n      babelrc: false,\n      caller: {\n        name: '@jest/transform',\n        supportsDynamicImport: options.supportsDynamicImport,\n        supportsExportNamespaceFrom: options.supportsExportNamespaceFrom,\n        supportsStaticESM: options.supportsStaticESM,\n        supportsTopLevelAwait: options.supportsTopLevelAwait\n      },\n      configFile: false,\n      filename,\n      plugins: [[_babelPluginIstanbul().default, {\n        compact: false,\n        // files outside `cwd` will not be instrumented\n        cwd: this._config.rootDir,\n        exclude: [],\n        extension: false,\n        inputSourceMap: inputMap,\n        useInlineSourceMaps: false\n      }]],\n      sourceMaps: canMapToInput ? 'both' : false\n    });\n\n    if (result && result.code) {\n      return result;\n    }\n\n    return input;\n  }\n\n  _buildTransformResult(filename, cacheFilePath, content, transformer, shouldCallTransform, options, processed, sourceMapPath) {\n    let transformed = {\n      code: content,\n      map: null\n    };\n\n    if (transformer && shouldCallTransform) {\n      if (processed != null && typeof processed.code === 'string') {\n        transformed = processed;\n      } else {\n        const transformPath = this._getTransformPath(filename);\n\n        invariant(transformPath);\n        throw new Error((0, _runtimeErrorsAndWarnings.makeInvalidReturnValueError)(transformPath));\n      }\n    }\n\n    if (!transformed.map) {\n      try {\n        //Could be a potential freeze here.\n        //See: https://github.com/facebook/jest/pull/5177#discussion_r158883570\n        const inlineSourceMap = (0, _convertSourceMap().fromSource)(transformed.code);\n\n        if (inlineSourceMap) {\n          transformed.map = inlineSourceMap.toObject();\n        }\n      } catch {\n        const transformPath = this._getTransformPath(filename);\n\n        invariant(transformPath);\n        console.warn((0, _runtimeErrorsAndWarnings.makeInvalidSourceMapWarning)(filename, transformPath));\n      }\n    } // That means that the transform has a custom instrumentation\n    // logic and will handle it based on `config.collectCoverage` option\n\n\n    const transformWillInstrument = shouldCallTransform && transformer && transformer.canInstrument; // Apply instrumentation to the code if necessary, keeping the instrumented code and new map\n\n    let map = transformed.map;\n    let code;\n\n    if (!transformWillInstrument && options.instrument) {\n      /**\n       * We can map the original source code to the instrumented code ONLY if\n       * - the process of transforming the code produced a source map e.g. ts-jest\n       * - we did not transform the source code\n       *\n       * Otherwise we cannot make any statements about how the instrumented code corresponds to the original code,\n       * and we should NOT emit any source maps\n       *\n       */\n      const shouldEmitSourceMaps = transformer != null && map != null || transformer == null;\n\n      const instrumented = this._instrumentFile(filename, transformed, shouldEmitSourceMaps, options);\n\n      code = typeof instrumented === 'string' ? instrumented : instrumented.code;\n      map = typeof instrumented === 'string' ? null : instrumented.map;\n    } else {\n      code = transformed.code;\n    }\n\n    if (map) {\n      const sourceMapContent = typeof map === 'string' ? map : JSON.stringify(map);\n      invariant(sourceMapPath, 'We should always have default sourceMapPath');\n      writeCacheFile(sourceMapPath, sourceMapContent);\n    } else {\n      sourceMapPath = null;\n    }\n\n    writeCodeCacheFile(cacheFilePath, code);\n    return {\n      code,\n      originalCode: content,\n      sourceMapPath\n    };\n  }\n\n  transformSource(filepath, content, options) {\n    const filename = (0, _jestUtil().tryRealpath)(filepath);\n    const {\n      transformer,\n      transformerConfig = {}\n    } = this._getTransformer(filename) || {};\n\n    const cacheFilePath = this._getFileCachePath(filename, content, options);\n\n    const sourceMapPath = `${cacheFilePath}.map`; // Ignore cache if `config.cache` is set (--no-cache)\n\n    const code = this._config.cache ? readCodeCacheFile(cacheFilePath) : null;\n\n    if (code) {\n      // This is broken: we return the code, and a path for the source map\n      // directly from the cache. But, nothing ensures the source map actually\n      // matches that source code. They could have gotten out-of-sync in case\n      // two separate processes write concurrently to the same cache files.\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    }\n\n    let processed = null;\n    let shouldCallTransform = false;\n\n    if (transformer && this.shouldTransform(filename)) {\n      shouldCallTransform = true;\n      assertSyncTransformer(transformer, this._getTransformPath(filename));\n      processed = transformer.process(content, filename, { ...options,\n        cacheFS: this._cacheFS,\n        config: this._config,\n        configString: this._cache.configString,\n        transformerConfig\n      });\n    }\n\n    return this._buildTransformResult(filename, cacheFilePath, content, transformer, shouldCallTransform, options, processed, sourceMapPath);\n  }\n\n  async transformSourceAsync(filepath, content, options) {\n    const filename = (0, _jestUtil().tryRealpath)(filepath);\n    const {\n      transformer,\n      transformerConfig = {}\n    } = this._getTransformer(filename) || {};\n    const cacheFilePath = await this._getFileCachePathAsync(filename, content, options);\n    const sourceMapPath = `${cacheFilePath}.map`; // Ignore cache if `config.cache` is set (--no-cache)\n\n    const code = this._config.cache ? readCodeCacheFile(cacheFilePath) : null;\n\n    if (code) {\n      // This is broken: we return the code, and a path for the source map\n      // directly from the cache. But, nothing ensures the source map actually\n      // matches that source code. They could have gotten out-of-sync in case\n      // two separate processes write concurrently to the same cache files.\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    }\n\n    let processed = null;\n    let shouldCallTransform = false;\n\n    if (transformer && this.shouldTransform(filename)) {\n      shouldCallTransform = true;\n      const process = transformer.processAsync || transformer.process; // This is probably dead code since `_getTransformerAsync` already asserts this\n\n      invariant(typeof process === 'function', 'A transformer must always export either a `process` or `processAsync`');\n      processed = await process(content, filename, { ...options,\n        cacheFS: this._cacheFS,\n        config: this._config,\n        configString: this._cache.configString,\n        transformerConfig\n      });\n    }\n\n    return this._buildTransformResult(filename, cacheFilePath, content, transformer, shouldCallTransform, options, processed, sourceMapPath);\n  }\n\n  async _transformAndBuildScriptAsync(filename, options, transformOptions, fileSource) {\n    const {\n      isInternalModule\n    } = options;\n    let fileContent = fileSource !== null && fileSource !== void 0 ? fileSource : this._cacheFS.get(filename);\n\n    if (!fileContent) {\n      fileContent = fs().readFileSync(filename, 'utf8');\n\n      this._cacheFS.set(filename, fileContent);\n    }\n\n    const content = stripShebang(fileContent);\n    let code = content;\n    let sourceMapPath = null;\n    const willTransform = !isInternalModule && (transformOptions.instrument || this.shouldTransform(filename));\n\n    try {\n      if (willTransform) {\n        const transformedSource = await this.transformSourceAsync(filename, content, transformOptions);\n        code = transformedSource.code;\n        sourceMapPath = transformedSource.sourceMapPath;\n      }\n\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    } catch (e) {\n      throw (0, _enhanceUnexpectedTokenMessage.default)(e);\n    }\n  }\n\n  _transformAndBuildScript(filename, options, transformOptions, fileSource) {\n    const {\n      isInternalModule\n    } = options;\n    let fileContent = fileSource !== null && fileSource !== void 0 ? fileSource : this._cacheFS.get(filename);\n\n    if (!fileContent) {\n      fileContent = fs().readFileSync(filename, 'utf8');\n\n      this._cacheFS.set(filename, fileContent);\n    }\n\n    const content = stripShebang(fileContent);\n    let code = content;\n    let sourceMapPath = null;\n    const willTransform = !isInternalModule && (transformOptions.instrument || this.shouldTransform(filename));\n\n    try {\n      if (willTransform) {\n        const transformedSource = this.transformSource(filename, content, transformOptions);\n        code = transformedSource.code;\n        sourceMapPath = transformedSource.sourceMapPath;\n      }\n\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    } catch (e) {\n      throw (0, _enhanceUnexpectedTokenMessage.default)(e);\n    }\n  }\n\n  async transformAsync(filename, options, fileSource) {\n    const instrument = options.coverageProvider === 'babel' && (0, _shouldInstrument.default)(filename, options, this._config);\n    const scriptCacheKey = getScriptCacheKey(filename, instrument);\n\n    let result = this._cache.transformedFiles.get(scriptCacheKey);\n\n    if (result) {\n      return result;\n    }\n\n    result = await this._transformAndBuildScriptAsync(filename, options, { ...options,\n      instrument\n    }, fileSource);\n\n    if (scriptCacheKey) {\n      this._cache.transformedFiles.set(scriptCacheKey, result);\n    }\n\n    return result;\n  }\n\n  transform(filename, options, fileSource) {\n    const instrument = options.coverageProvider === 'babel' && (0, _shouldInstrument.default)(filename, options, this._config);\n    const scriptCacheKey = getScriptCacheKey(filename, instrument);\n\n    let result = this._cache.transformedFiles.get(scriptCacheKey);\n\n    if (result) {\n      return result;\n    }\n\n    result = this._transformAndBuildScript(filename, options, { ...options,\n      instrument\n    }, fileSource);\n\n    if (scriptCacheKey) {\n      this._cache.transformedFiles.set(scriptCacheKey, result);\n    }\n\n    return result;\n  }\n\n  transformJson(filename, options, fileSource) {\n    const {\n      isInternalModule\n    } = options;\n    const willTransform = !isInternalModule && this.shouldTransform(filename);\n\n    if (willTransform) {\n      const {\n        code: transformedJsonSource\n      } = this.transformSource(filename, fileSource, { ...options,\n        instrument: false\n      });\n      return transformedJsonSource;\n    }\n\n    return fileSource;\n  }\n\n  async requireAndTranspileModule(moduleName, callback) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      applyInteropRequireDefault: true,\n      instrument: false,\n      supportsDynamicImport: false,\n      supportsExportNamespaceFrom: false,\n      supportsStaticESM: false,\n      supportsTopLevelAwait: false\n    };\n    let transforming = false;\n    const {\n      applyInteropRequireDefault,\n      ...transformOptions\n    } = options;\n    const revertHook = (0, _pirates().addHook)((code, filename) => {\n      try {\n        transforming = true;\n        return this.transformSource(filename, code, transformOptions).code || code;\n      } finally {\n        transforming = false;\n      }\n    }, {\n      // Exclude `mjs` extension when addHook because pirates don't support hijack es module\n      exts: this._config.moduleFileExtensions.filter(ext => ext !== 'mjs').map(ext => `.${ext}`),\n      ignoreNodeModules: false,\n      matcher: filename => {\n        if (transforming) {\n          // Don't transform any dependency required by the transformer itself\n          return false;\n        }\n\n        return this.shouldTransform(filename);\n      }\n    });\n\n    try {\n      const module = await (0, _jestUtil().requireOrImportModule)(moduleName, applyInteropRequireDefault);\n\n      if (!callback) {\n        revertHook();\n        return module;\n      }\n\n      const cbResult = callback(module);\n\n      if ((0, _jestUtil().isPromise)(cbResult)) {\n        return waitForPromiseWithCleanup(cbResult, revertHook).then(() => module);\n      }\n\n      return module;\n    } finally {\n      revertHook();\n    }\n  }\n\n  shouldTransform(filename) {\n    const ignoreRegexp = this._cache.ignorePatternsRegExp;\n    const isIgnored = ignoreRegexp ? ignoreRegexp.test(filename) : false;\n    return this._config.transform.length !== 0 && !isIgnored;\n  }\n\n} // TODO: do we need to define the generics twice?\n\n\nasync function createTranspilingRequire(config) {\n  const transformer = await createScriptTransformer(config);\n  return async function requireAndTranspileModule(resolverPath) {\n    let applyInteropRequireDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const transpiledModule = await transformer.requireAndTranspileModule(resolverPath, // eslint-disable-next-line @typescript-eslint/no-empty-function\n    () => {}, {\n      applyInteropRequireDefault,\n      instrument: false,\n      supportsDynamicImport: false,\n      // this might be true, depending on node version.\n      supportsExportNamespaceFrom: false,\n      supportsStaticESM: false,\n      supportsTopLevelAwait: false\n    });\n    return transpiledModule;\n  };\n}\n\nconst removeFile = path => {\n  try {\n    fs().unlinkSync(path);\n  } catch {}\n};\n\nconst stripShebang = content => {\n  // If the file data starts with a shebang remove it. Leaves the empty line\n  // to keep stack trace line numbers correct.\n  if (content.startsWith('#!')) {\n    return content.replace(/^#!.*/, '');\n  } else {\n    return content;\n  }\n};\n/**\n * This is like `writeCacheFile` but with an additional sanity checksum. We\n * cannot use the same technique for source maps because we expose source map\n * cache file paths directly to callsites, with the expectation they can read\n * it right away. This is not a great system, because source map cache file\n * could get corrupted, out-of-sync, etc.\n */\n\n\nfunction writeCodeCacheFile(cachePath, code) {\n  const checksum = (0, _crypto().createHash)('sha256').update(code).digest('hex').substring(0, 32);\n  writeCacheFile(cachePath, `${checksum}\\n${code}`);\n}\n/**\n * Read counterpart of `writeCodeCacheFile`. We verify that the content of the\n * file matches the checksum, in case some kind of corruption happened. This\n * could happen if an older version of `jest-runtime` writes non-atomically to\n * the same cache, for example.\n */\n\n\nfunction readCodeCacheFile(cachePath) {\n  const content = readCacheFile(cachePath);\n\n  if (content == null) {\n    return null;\n  }\n\n  const code = content.substring(33);\n  const checksum = (0, _crypto().createHash)('sha256').update(code).digest('hex').substring(0, 32);\n\n  if (checksum === content.substring(0, 32)) {\n    return code;\n  }\n\n  return null;\n}\n/**\n * Writing to the cache atomically relies on 'rename' being atomic on most\n * file systems. Doing atomic write reduces the risk of corruption by avoiding\n * two processes to write to the same file at the same time. It also reduces\n * the risk of reading a file that's being overwritten at the same time.\n */\n\n\nconst writeCacheFile = (cachePath, fileData) => {\n  try {\n    (0, _writeFileAtomic().sync)(cachePath, fileData, {\n      encoding: 'utf8',\n      fsync: false\n    });\n  } catch (e) {\n    if (cacheWriteErrorSafeToIgnore(e, cachePath)) {\n      return;\n    }\n\n    e.message = `jest: failed to cache transform results in: ${cachePath}\\nFailure message: ${e.message}`;\n    removeFile(cachePath);\n    throw e;\n  }\n};\n/**\n * On Windows, renames are not atomic, leading to EPERM exceptions when two\n * processes attempt to rename to the same target file at the same time.\n * If the target file exists we can be reasonably sure another process has\n * legitimately won a cache write race and ignore the error.\n */\n\n\nconst cacheWriteErrorSafeToIgnore = (e, cachePath) => process.platform === 'win32' && e.code === 'EPERM' && fs().existsSync(cachePath);\n\nconst readCacheFile = cachePath => {\n  if (!fs().existsSync(cachePath)) {\n    return null;\n  }\n\n  let fileData;\n\n  try {\n    fileData = fs().readFileSync(cachePath, 'utf8');\n  } catch (e) {\n    e.message = `jest: failed to read cache file: ${cachePath}\\nFailure message: ${e.message}`;\n    removeFile(cachePath);\n    throw e;\n  }\n\n  if (fileData == null) {\n    // We must have somehow created the file but failed to write to it,\n    // let's delete it and retry.\n    removeFile(cachePath);\n  }\n\n  return fileData;\n};\n\nconst getScriptCacheKey = (filename, instrument) => {\n  const mtime = fs().statSync(filename).mtime;\n  return `${filename}_${mtime.getTime()}${instrument ? '_instrumented' : ''}`;\n};\n\nconst calcIgnorePatternRegExp = config => {\n  if (!config.transformIgnorePatterns || config.transformIgnorePatterns.length === 0) {\n    return undefined;\n  }\n\n  return new RegExp(config.transformIgnorePatterns.join('|'));\n};\n\nconst calcTransformRegExp = config => {\n  if (!config.transform.length) {\n    return undefined;\n  }\n\n  const transformRegexp = [];\n\n  for (let i = 0; i < config.transform.length; i++) {\n    transformRegexp.push([new RegExp(config.transform[i][0]), config.transform[i][1], config.transform[i][2]]);\n  }\n\n  return transformRegexp;\n};\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nfunction assertSyncTransformer(transformer, name) {\n  invariant(name);\n  invariant(typeof transformer.process === 'function', (0, _runtimeErrorsAndWarnings.makeInvalidSyncTransformerError)(name));\n}\n\nasync function createScriptTransformer(config) {\n  let cacheFS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Map();\n  const transformer = new ScriptTransformer(config, cacheFS);\n  await transformer.loadTransformers();\n  return transformer;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","createScriptTransformer","createTranspilingRequire","_crypto","data","require","path","_interopRequireWildcard","_core","_babelPluginIstanbul","_interopRequireDefault","_convertSourceMap","_fastJsonStableStringify","fs","_pirates","_slash","_writeFileAtomic","_jestHasteMap","_jestUtil","_enhanceUnexpectedTokenMessage","_runtimeErrorsAndWarnings","_shouldInstrument","obj","__esModule","default","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","version","VERSION","projectCaches","Map","CACHE_VERSION","waitForPromiseWithCleanup","promise","cleanup","isTransformerFactory","t","createTransformer","ScriptTransformer","_cache","_transformCache","_transformsAreLoaded","constructor","_config","_cacheFS","configString","projectCache","ignorePatternsRegExp","calcIgnorePatternRegExp","transformRegExp","calcTransformRegExp","transformedFiles","_buildCacheKeyFromFileInfo","fileData","filename","transformOptions","transformerCacheKey","createHash","update","digest","substring","instrument","_getCacheKey","options","transformer","transformerConfig","_getTransformer","undefined","cacheFS","config","getCacheKey","_getCacheKeyAsync","getCacheKeyAsync","_createFolderFromCacheKey","cacheKey","HasteMapClass","getStatic","baseCacheDir","getCacheFilePath","cacheDirectory","id","cacheDir","join","cacheFilenamePrefix","basename","extname","replace","cachePath","createDirectory","_getFileCachePath","content","_getFileCachePathAsync","_getTransformPath","i","length","test","loadTransformers","Promise","all","transform","map","transformPath","requireOrImportModule","Error","makeInvalidTransformerError","process","processAsync","res","cached","_instrumentFile","input","canMapToInput","inputCode","code","inputMap","result","transformSync","auxiliaryCommentBefore","babelrc","caller","name","supportsDynamicImport","supportsExportNamespaceFrom","supportsStaticESM","supportsTopLevelAwait","configFile","plugins","compact","cwd","rootDir","exclude","extension","inputSourceMap","useInlineSourceMaps","sourceMaps","_buildTransformResult","cacheFilePath","shouldCallTransform","processed","sourceMapPath","transformed","invariant","makeInvalidReturnValueError","inlineSourceMap","fromSource","toObject","console","warn","makeInvalidSourceMapWarning","transformWillInstrument","canInstrument","shouldEmitSourceMaps","instrumented","sourceMapContent","JSON","stringify","writeCacheFile","writeCodeCacheFile","originalCode","transformSource","filepath","tryRealpath","readCodeCacheFile","shouldTransform","assertSyncTransformer","transformSourceAsync","_transformAndBuildScriptAsync","fileSource","isInternalModule","fileContent","readFileSync","stripShebang","willTransform","transformedSource","e","_transformAndBuildScript","transformAsync","coverageProvider","scriptCacheKey","getScriptCacheKey","transformJson","transformedJsonSource","requireAndTranspileModule","moduleName","callback","applyInteropRequireDefault","transforming","revertHook","addHook","exts","moduleFileExtensions","filter","ext","ignoreNodeModules","matcher","module","cbResult","isPromise","then","ignoreRegexp","isIgnored","resolverPath","transpiledModule","removeFile","unlinkSync","startsWith","checksum","readCacheFile","sync","encoding","fsync","cacheWriteErrorSafeToIgnore","message","platform","existsSync","mtime","statSync","getTime","transformIgnorePatterns","RegExp","transformRegexp","push","condition","makeInvalidSyncTransformerError"],"sources":["/Users/wonjaelee/Desktop/final/node_modules/@jest/reporters/node_modules/@jest/transform/build/ScriptTransformer.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.createScriptTransformer = createScriptTransformer;\nexports.createTranspilingRequire = createTranspilingRequire;\n\nfunction _crypto() {\n  const data = require('crypto');\n\n  _crypto = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _core() {\n  const data = require('@babel/core');\n\n  _core = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _babelPluginIstanbul() {\n  const data = _interopRequireDefault(require('babel-plugin-istanbul'));\n\n  _babelPluginIstanbul = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _convertSourceMap() {\n  const data = require('convert-source-map');\n\n  _convertSourceMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fastJsonStableStringify() {\n  const data = _interopRequireDefault(require('fast-json-stable-stringify'));\n\n  _fastJsonStableStringify = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fs() {\n  const data = _interopRequireWildcard(require('graceful-fs'));\n\n  fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _pirates() {\n  const data = require('pirates');\n\n  _pirates = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _slash() {\n  const data = _interopRequireDefault(require('slash'));\n\n  _slash = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _writeFileAtomic() {\n  const data = require('write-file-atomic');\n\n  _writeFileAtomic = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestHasteMap() {\n  const data = _interopRequireDefault(require('jest-haste-map'));\n\n  _jestHasteMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _enhanceUnexpectedTokenMessage = _interopRequireDefault(\n  require('./enhanceUnexpectedTokenMessage')\n);\n\nvar _runtimeErrorsAndWarnings = require('./runtimeErrorsAndWarnings');\n\nvar _shouldInstrument = _interopRequireDefault(require('./shouldInstrument'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// @ts-expect-error: should just be `require.resolve`, but the tests mess that up\n// Use `require` to avoid TS rootDir\nconst {version: VERSION} = require('../package.json');\n\n// This data structure is used to avoid recalculating some data every time that\n// we need to transform a file. Since ScriptTransformer is instantiated for each\n// file we need to keep this object in the local scope of this module.\nconst projectCaches = new Map(); // To reset the cache for specific changesets (rather than package version).\n\nconst CACHE_VERSION = '1';\n\nasync function waitForPromiseWithCleanup(promise, cleanup) {\n  try {\n    await promise;\n  } finally {\n    cleanup();\n  }\n} // type predicate\n\nfunction isTransformerFactory(t) {\n  return typeof t.createTransformer === 'function';\n}\n\nclass ScriptTransformer {\n  _cache;\n  _transformCache = new Map();\n  _transformsAreLoaded = false;\n\n  constructor(_config, _cacheFS) {\n    this._config = _config;\n    this._cacheFS = _cacheFS;\n    const configString = (0, _fastJsonStableStringify().default)(this._config);\n    let projectCache = projectCaches.get(configString);\n\n    if (!projectCache) {\n      projectCache = {\n        configString,\n        ignorePatternsRegExp: calcIgnorePatternRegExp(this._config),\n        transformRegExp: calcTransformRegExp(this._config),\n        transformedFiles: new Map()\n      };\n      projectCaches.set(configString, projectCache);\n    }\n\n    this._cache = projectCache;\n  }\n\n  _buildCacheKeyFromFileInfo(\n    fileData,\n    filename,\n    transformOptions,\n    transformerCacheKey\n  ) {\n    if (transformerCacheKey) {\n      return (0, _crypto().createHash)('sha256')\n        .update(transformerCacheKey)\n        .update(CACHE_VERSION)\n        .digest('hex')\n        .substring(0, 32);\n    }\n\n    return (0, _crypto().createHash)('sha256')\n      .update(fileData)\n      .update(transformOptions.configString)\n      .update(transformOptions.instrument ? 'instrument' : '')\n      .update(filename)\n      .update(CACHE_VERSION)\n      .digest('hex')\n      .substring(0, 32);\n  }\n\n  _getCacheKey(fileData, filename, options) {\n    const configString = this._cache.configString;\n    const {transformer, transformerConfig = {}} =\n      this._getTransformer(filename) || {};\n    let transformerCacheKey = undefined;\n    const transformOptions = {\n      ...options,\n      cacheFS: this._cacheFS,\n      config: this._config,\n      configString,\n      transformerConfig\n    };\n\n    if (\n      typeof (transformer === null || transformer === void 0\n        ? void 0\n        : transformer.getCacheKey) === 'function'\n    ) {\n      transformerCacheKey = transformer.getCacheKey(\n        fileData,\n        filename,\n        transformOptions\n      );\n    }\n\n    return this._buildCacheKeyFromFileInfo(\n      fileData,\n      filename,\n      transformOptions,\n      transformerCacheKey\n    );\n  }\n\n  async _getCacheKeyAsync(fileData, filename, options) {\n    const configString = this._cache.configString;\n    const {transformer, transformerConfig = {}} =\n      this._getTransformer(filename) || {};\n    let transformerCacheKey = undefined;\n    const transformOptions = {\n      ...options,\n      cacheFS: this._cacheFS,\n      config: this._config,\n      configString,\n      transformerConfig\n    };\n\n    if (transformer) {\n      const getCacheKey =\n        transformer.getCacheKeyAsync || transformer.getCacheKey;\n\n      if (typeof getCacheKey === 'function') {\n        transformerCacheKey = await getCacheKey(\n          fileData,\n          filename,\n          transformOptions\n        );\n      }\n    }\n\n    return this._buildCacheKeyFromFileInfo(\n      fileData,\n      filename,\n      transformOptions,\n      transformerCacheKey\n    );\n  }\n\n  _createFolderFromCacheKey(filename, cacheKey) {\n    const HasteMapClass = _jestHasteMap().default.getStatic(this._config);\n\n    const baseCacheDir = HasteMapClass.getCacheFilePath(\n      this._config.cacheDirectory,\n      `jest-transform-cache-${this._config.id}`,\n      VERSION\n    ); // Create sub folders based on the cacheKey to avoid creating one\n    // directory with many files.\n\n    const cacheDir = path().join(baseCacheDir, cacheKey[0] + cacheKey[1]);\n    const cacheFilenamePrefix = path()\n      .basename(filename, path().extname(filename))\n      .replace(/\\W/g, '');\n    const cachePath = (0, _slash().default)(\n      path().join(cacheDir, `${cacheFilenamePrefix}_${cacheKey}`)\n    );\n    (0, _jestUtil().createDirectory)(cacheDir);\n    return cachePath;\n  }\n\n  _getFileCachePath(filename, content, options) {\n    const cacheKey = this._getCacheKey(content, filename, options);\n\n    return this._createFolderFromCacheKey(filename, cacheKey);\n  }\n\n  async _getFileCachePathAsync(filename, content, options) {\n    const cacheKey = await this._getCacheKeyAsync(content, filename, options);\n    return this._createFolderFromCacheKey(filename, cacheKey);\n  }\n\n  _getTransformPath(filename) {\n    const transformRegExp = this._cache.transformRegExp;\n\n    if (!transformRegExp) {\n      return undefined;\n    }\n\n    for (let i = 0; i < transformRegExp.length; i++) {\n      if (transformRegExp[i][0].test(filename)) {\n        return transformRegExp[i][1];\n      }\n    }\n\n    return undefined;\n  }\n\n  async loadTransformers() {\n    await Promise.all(\n      this._config.transform.map(\n        async ([, transformPath, transformerConfig]) => {\n          let transformer = await (0, _jestUtil().requireOrImportModule)(\n            transformPath\n          );\n\n          if (!transformer) {\n            throw new Error(\n              (0, _runtimeErrorsAndWarnings.makeInvalidTransformerError)(\n                transformPath\n              )\n            );\n          }\n\n          if (isTransformerFactory(transformer)) {\n            transformer = transformer.createTransformer(transformerConfig);\n          }\n\n          if (\n            typeof transformer.process !== 'function' &&\n            typeof transformer.processAsync !== 'function'\n          ) {\n            throw new Error(\n              (0, _runtimeErrorsAndWarnings.makeInvalidTransformerError)(\n                transformPath\n              )\n            );\n          }\n\n          const res = {\n            transformer,\n            transformerConfig\n          };\n\n          this._transformCache.set(transformPath, res);\n        }\n      )\n    );\n    this._transformsAreLoaded = true;\n  }\n\n  _getTransformer(filename) {\n    if (!this._transformsAreLoaded) {\n      throw new Error(\n        'Jest: Transformers have not been loaded yet - make sure to run `loadTransformers` and wait for it to complete before starting to transform files'\n      );\n    }\n\n    if (this._config.transform.length === 0) {\n      return null;\n    }\n\n    const transformPath = this._getTransformPath(filename);\n\n    if (!transformPath) {\n      return null;\n    }\n\n    const cached = this._transformCache.get(transformPath);\n\n    if (cached) {\n      return cached;\n    }\n\n    throw new Error(\n      `Jest was unable to load the transformer defined for ${filename}. This is a bug in Jest, please open up an issue`\n    );\n  }\n\n  _instrumentFile(filename, input, canMapToInput, options) {\n    const inputCode = typeof input === 'string' ? input : input.code;\n    const inputMap = typeof input === 'string' ? null : input.map;\n    const result = (0, _core().transformSync)(inputCode, {\n      auxiliaryCommentBefore: ' istanbul ignore next ',\n      babelrc: false,\n      caller: {\n        name: '@jest/transform',\n        supportsDynamicImport: options.supportsDynamicImport,\n        supportsExportNamespaceFrom: options.supportsExportNamespaceFrom,\n        supportsStaticESM: options.supportsStaticESM,\n        supportsTopLevelAwait: options.supportsTopLevelAwait\n      },\n      configFile: false,\n      filename,\n      plugins: [\n        [\n          _babelPluginIstanbul().default,\n          {\n            compact: false,\n            // files outside `cwd` will not be instrumented\n            cwd: this._config.rootDir,\n            exclude: [],\n            extension: false,\n            inputSourceMap: inputMap,\n            useInlineSourceMaps: false\n          }\n        ]\n      ],\n      sourceMaps: canMapToInput ? 'both' : false\n    });\n\n    if (result && result.code) {\n      return result;\n    }\n\n    return input;\n  }\n\n  _buildTransformResult(\n    filename,\n    cacheFilePath,\n    content,\n    transformer,\n    shouldCallTransform,\n    options,\n    processed,\n    sourceMapPath\n  ) {\n    let transformed = {\n      code: content,\n      map: null\n    };\n\n    if (transformer && shouldCallTransform) {\n      if (processed != null && typeof processed.code === 'string') {\n        transformed = processed;\n      } else {\n        const transformPath = this._getTransformPath(filename);\n\n        invariant(transformPath);\n        throw new Error(\n          (0, _runtimeErrorsAndWarnings.makeInvalidReturnValueError)(\n            transformPath\n          )\n        );\n      }\n    }\n\n    if (!transformed.map) {\n      try {\n        //Could be a potential freeze here.\n        //See: https://github.com/facebook/jest/pull/5177#discussion_r158883570\n        const inlineSourceMap = (0, _convertSourceMap().fromSource)(\n          transformed.code\n        );\n\n        if (inlineSourceMap) {\n          transformed.map = inlineSourceMap.toObject();\n        }\n      } catch {\n        const transformPath = this._getTransformPath(filename);\n\n        invariant(transformPath);\n        console.warn(\n          (0, _runtimeErrorsAndWarnings.makeInvalidSourceMapWarning)(\n            filename,\n            transformPath\n          )\n        );\n      }\n    } // That means that the transform has a custom instrumentation\n    // logic and will handle it based on `config.collectCoverage` option\n\n    const transformWillInstrument =\n      shouldCallTransform && transformer && transformer.canInstrument; // Apply instrumentation to the code if necessary, keeping the instrumented code and new map\n\n    let map = transformed.map;\n    let code;\n\n    if (!transformWillInstrument && options.instrument) {\n      /**\n       * We can map the original source code to the instrumented code ONLY if\n       * - the process of transforming the code produced a source map e.g. ts-jest\n       * - we did not transform the source code\n       *\n       * Otherwise we cannot make any statements about how the instrumented code corresponds to the original code,\n       * and we should NOT emit any source maps\n       *\n       */\n      const shouldEmitSourceMaps =\n        (transformer != null && map != null) || transformer == null;\n\n      const instrumented = this._instrumentFile(\n        filename,\n        transformed,\n        shouldEmitSourceMaps,\n        options\n      );\n\n      code =\n        typeof instrumented === 'string' ? instrumented : instrumented.code;\n      map = typeof instrumented === 'string' ? null : instrumented.map;\n    } else {\n      code = transformed.code;\n    }\n\n    if (map) {\n      const sourceMapContent =\n        typeof map === 'string' ? map : JSON.stringify(map);\n      invariant(sourceMapPath, 'We should always have default sourceMapPath');\n      writeCacheFile(sourceMapPath, sourceMapContent);\n    } else {\n      sourceMapPath = null;\n    }\n\n    writeCodeCacheFile(cacheFilePath, code);\n    return {\n      code,\n      originalCode: content,\n      sourceMapPath\n    };\n  }\n\n  transformSource(filepath, content, options) {\n    const filename = (0, _jestUtil().tryRealpath)(filepath);\n    const {transformer, transformerConfig = {}} =\n      this._getTransformer(filename) || {};\n\n    const cacheFilePath = this._getFileCachePath(filename, content, options);\n\n    const sourceMapPath = `${cacheFilePath}.map`; // Ignore cache if `config.cache` is set (--no-cache)\n\n    const code = this._config.cache ? readCodeCacheFile(cacheFilePath) : null;\n\n    if (code) {\n      // This is broken: we return the code, and a path for the source map\n      // directly from the cache. But, nothing ensures the source map actually\n      // matches that source code. They could have gotten out-of-sync in case\n      // two separate processes write concurrently to the same cache files.\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    }\n\n    let processed = null;\n    let shouldCallTransform = false;\n\n    if (transformer && this.shouldTransform(filename)) {\n      shouldCallTransform = true;\n      assertSyncTransformer(transformer, this._getTransformPath(filename));\n      processed = transformer.process(content, filename, {\n        ...options,\n        cacheFS: this._cacheFS,\n        config: this._config,\n        configString: this._cache.configString,\n        transformerConfig\n      });\n    }\n\n    return this._buildTransformResult(\n      filename,\n      cacheFilePath,\n      content,\n      transformer,\n      shouldCallTransform,\n      options,\n      processed,\n      sourceMapPath\n    );\n  }\n\n  async transformSourceAsync(filepath, content, options) {\n    const filename = (0, _jestUtil().tryRealpath)(filepath);\n    const {transformer, transformerConfig = {}} =\n      this._getTransformer(filename) || {};\n    const cacheFilePath = await this._getFileCachePathAsync(\n      filename,\n      content,\n      options\n    );\n    const sourceMapPath = `${cacheFilePath}.map`; // Ignore cache if `config.cache` is set (--no-cache)\n\n    const code = this._config.cache ? readCodeCacheFile(cacheFilePath) : null;\n\n    if (code) {\n      // This is broken: we return the code, and a path for the source map\n      // directly from the cache. But, nothing ensures the source map actually\n      // matches that source code. They could have gotten out-of-sync in case\n      // two separate processes write concurrently to the same cache files.\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    }\n\n    let processed = null;\n    let shouldCallTransform = false;\n\n    if (transformer && this.shouldTransform(filename)) {\n      shouldCallTransform = true;\n      const process = transformer.processAsync || transformer.process; // This is probably dead code since `_getTransformerAsync` already asserts this\n\n      invariant(\n        typeof process === 'function',\n        'A transformer must always export either a `process` or `processAsync`'\n      );\n      processed = await process(content, filename, {\n        ...options,\n        cacheFS: this._cacheFS,\n        config: this._config,\n        configString: this._cache.configString,\n        transformerConfig\n      });\n    }\n\n    return this._buildTransformResult(\n      filename,\n      cacheFilePath,\n      content,\n      transformer,\n      shouldCallTransform,\n      options,\n      processed,\n      sourceMapPath\n    );\n  }\n\n  async _transformAndBuildScriptAsync(\n    filename,\n    options,\n    transformOptions,\n    fileSource\n  ) {\n    const {isInternalModule} = options;\n    let fileContent =\n      fileSource !== null && fileSource !== void 0\n        ? fileSource\n        : this._cacheFS.get(filename);\n\n    if (!fileContent) {\n      fileContent = fs().readFileSync(filename, 'utf8');\n\n      this._cacheFS.set(filename, fileContent);\n    }\n\n    const content = stripShebang(fileContent);\n    let code = content;\n    let sourceMapPath = null;\n    const willTransform =\n      !isInternalModule &&\n      (transformOptions.instrument || this.shouldTransform(filename));\n\n    try {\n      if (willTransform) {\n        const transformedSource = await this.transformSourceAsync(\n          filename,\n          content,\n          transformOptions\n        );\n        code = transformedSource.code;\n        sourceMapPath = transformedSource.sourceMapPath;\n      }\n\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    } catch (e) {\n      throw (0, _enhanceUnexpectedTokenMessage.default)(e);\n    }\n  }\n\n  _transformAndBuildScript(filename, options, transformOptions, fileSource) {\n    const {isInternalModule} = options;\n    let fileContent =\n      fileSource !== null && fileSource !== void 0\n        ? fileSource\n        : this._cacheFS.get(filename);\n\n    if (!fileContent) {\n      fileContent = fs().readFileSync(filename, 'utf8');\n\n      this._cacheFS.set(filename, fileContent);\n    }\n\n    const content = stripShebang(fileContent);\n    let code = content;\n    let sourceMapPath = null;\n    const willTransform =\n      !isInternalModule &&\n      (transformOptions.instrument || this.shouldTransform(filename));\n\n    try {\n      if (willTransform) {\n        const transformedSource = this.transformSource(\n          filename,\n          content,\n          transformOptions\n        );\n        code = transformedSource.code;\n        sourceMapPath = transformedSource.sourceMapPath;\n      }\n\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    } catch (e) {\n      throw (0, _enhanceUnexpectedTokenMessage.default)(e);\n    }\n  }\n\n  async transformAsync(filename, options, fileSource) {\n    const instrument =\n      options.coverageProvider === 'babel' &&\n      (0, _shouldInstrument.default)(filename, options, this._config);\n    const scriptCacheKey = getScriptCacheKey(filename, instrument);\n\n    let result = this._cache.transformedFiles.get(scriptCacheKey);\n\n    if (result) {\n      return result;\n    }\n\n    result = await this._transformAndBuildScriptAsync(\n      filename,\n      options,\n      {...options, instrument},\n      fileSource\n    );\n\n    if (scriptCacheKey) {\n      this._cache.transformedFiles.set(scriptCacheKey, result);\n    }\n\n    return result;\n  }\n\n  transform(filename, options, fileSource) {\n    const instrument =\n      options.coverageProvider === 'babel' &&\n      (0, _shouldInstrument.default)(filename, options, this._config);\n    const scriptCacheKey = getScriptCacheKey(filename, instrument);\n\n    let result = this._cache.transformedFiles.get(scriptCacheKey);\n\n    if (result) {\n      return result;\n    }\n\n    result = this._transformAndBuildScript(\n      filename,\n      options,\n      {...options, instrument},\n      fileSource\n    );\n\n    if (scriptCacheKey) {\n      this._cache.transformedFiles.set(scriptCacheKey, result);\n    }\n\n    return result;\n  }\n\n  transformJson(filename, options, fileSource) {\n    const {isInternalModule} = options;\n    const willTransform = !isInternalModule && this.shouldTransform(filename);\n\n    if (willTransform) {\n      const {code: transformedJsonSource} = this.transformSource(\n        filename,\n        fileSource,\n        {...options, instrument: false}\n      );\n      return transformedJsonSource;\n    }\n\n    return fileSource;\n  }\n\n  async requireAndTranspileModule(\n    moduleName,\n    callback,\n    options = {\n      applyInteropRequireDefault: true,\n      instrument: false,\n      supportsDynamicImport: false,\n      supportsExportNamespaceFrom: false,\n      supportsStaticESM: false,\n      supportsTopLevelAwait: false\n    }\n  ) {\n    let transforming = false;\n    const {applyInteropRequireDefault, ...transformOptions} = options;\n    const revertHook = (0, _pirates().addHook)(\n      (code, filename) => {\n        try {\n          transforming = true;\n          return (\n            this.transformSource(filename, code, transformOptions).code || code\n          );\n        } finally {\n          transforming = false;\n        }\n      },\n      {\n        // Exclude `mjs` extension when addHook because pirates don't support hijack es module\n        exts: this._config.moduleFileExtensions\n          .filter(ext => ext !== 'mjs')\n          .map(ext => `.${ext}`),\n        ignoreNodeModules: false,\n        matcher: filename => {\n          if (transforming) {\n            // Don't transform any dependency required by the transformer itself\n            return false;\n          }\n\n          return this.shouldTransform(filename);\n        }\n      }\n    );\n\n    try {\n      const module = await (0, _jestUtil().requireOrImportModule)(\n        moduleName,\n        applyInteropRequireDefault\n      );\n\n      if (!callback) {\n        revertHook();\n        return module;\n      }\n\n      const cbResult = callback(module);\n\n      if ((0, _jestUtil().isPromise)(cbResult)) {\n        return waitForPromiseWithCleanup(cbResult, revertHook).then(\n          () => module\n        );\n      }\n\n      return module;\n    } finally {\n      revertHook();\n    }\n  }\n\n  shouldTransform(filename) {\n    const ignoreRegexp = this._cache.ignorePatternsRegExp;\n    const isIgnored = ignoreRegexp ? ignoreRegexp.test(filename) : false;\n    return this._config.transform.length !== 0 && !isIgnored;\n  }\n} // TODO: do we need to define the generics twice?\n\nasync function createTranspilingRequire(config) {\n  const transformer = await createScriptTransformer(config);\n  return async function requireAndTranspileModule(\n    resolverPath,\n    applyInteropRequireDefault = false\n  ) {\n    const transpiledModule = await transformer.requireAndTranspileModule(\n      resolverPath, // eslint-disable-next-line @typescript-eslint/no-empty-function\n      () => {},\n      {\n        applyInteropRequireDefault,\n        instrument: false,\n        supportsDynamicImport: false,\n        // this might be true, depending on node version.\n        supportsExportNamespaceFrom: false,\n        supportsStaticESM: false,\n        supportsTopLevelAwait: false\n      }\n    );\n    return transpiledModule;\n  };\n}\n\nconst removeFile = path => {\n  try {\n    fs().unlinkSync(path);\n  } catch {}\n};\n\nconst stripShebang = content => {\n  // If the file data starts with a shebang remove it. Leaves the empty line\n  // to keep stack trace line numbers correct.\n  if (content.startsWith('#!')) {\n    return content.replace(/^#!.*/, '');\n  } else {\n    return content;\n  }\n};\n/**\n * This is like `writeCacheFile` but with an additional sanity checksum. We\n * cannot use the same technique for source maps because we expose source map\n * cache file paths directly to callsites, with the expectation they can read\n * it right away. This is not a great system, because source map cache file\n * could get corrupted, out-of-sync, etc.\n */\n\nfunction writeCodeCacheFile(cachePath, code) {\n  const checksum = (0, _crypto().createHash)('sha256')\n    .update(code)\n    .digest('hex')\n    .substring(0, 32);\n  writeCacheFile(cachePath, `${checksum}\\n${code}`);\n}\n/**\n * Read counterpart of `writeCodeCacheFile`. We verify that the content of the\n * file matches the checksum, in case some kind of corruption happened. This\n * could happen if an older version of `jest-runtime` writes non-atomically to\n * the same cache, for example.\n */\n\nfunction readCodeCacheFile(cachePath) {\n  const content = readCacheFile(cachePath);\n\n  if (content == null) {\n    return null;\n  }\n\n  const code = content.substring(33);\n  const checksum = (0, _crypto().createHash)('sha256')\n    .update(code)\n    .digest('hex')\n    .substring(0, 32);\n\n  if (checksum === content.substring(0, 32)) {\n    return code;\n  }\n\n  return null;\n}\n/**\n * Writing to the cache atomically relies on 'rename' being atomic on most\n * file systems. Doing atomic write reduces the risk of corruption by avoiding\n * two processes to write to the same file at the same time. It also reduces\n * the risk of reading a file that's being overwritten at the same time.\n */\n\nconst writeCacheFile = (cachePath, fileData) => {\n  try {\n    (0, _writeFileAtomic().sync)(cachePath, fileData, {\n      encoding: 'utf8',\n      fsync: false\n    });\n  } catch (e) {\n    if (cacheWriteErrorSafeToIgnore(e, cachePath)) {\n      return;\n    }\n\n    e.message = `jest: failed to cache transform results in: ${cachePath}\\nFailure message: ${e.message}`;\n    removeFile(cachePath);\n    throw e;\n  }\n};\n/**\n * On Windows, renames are not atomic, leading to EPERM exceptions when two\n * processes attempt to rename to the same target file at the same time.\n * If the target file exists we can be reasonably sure another process has\n * legitimately won a cache write race and ignore the error.\n */\n\nconst cacheWriteErrorSafeToIgnore = (e, cachePath) =>\n  process.platform === 'win32' &&\n  e.code === 'EPERM' &&\n  fs().existsSync(cachePath);\n\nconst readCacheFile = cachePath => {\n  if (!fs().existsSync(cachePath)) {\n    return null;\n  }\n\n  let fileData;\n\n  try {\n    fileData = fs().readFileSync(cachePath, 'utf8');\n  } catch (e) {\n    e.message = `jest: failed to read cache file: ${cachePath}\\nFailure message: ${e.message}`;\n    removeFile(cachePath);\n    throw e;\n  }\n\n  if (fileData == null) {\n    // We must have somehow created the file but failed to write to it,\n    // let's delete it and retry.\n    removeFile(cachePath);\n  }\n\n  return fileData;\n};\n\nconst getScriptCacheKey = (filename, instrument) => {\n  const mtime = fs().statSync(filename).mtime;\n  return `${filename}_${mtime.getTime()}${instrument ? '_instrumented' : ''}`;\n};\n\nconst calcIgnorePatternRegExp = config => {\n  if (\n    !config.transformIgnorePatterns ||\n    config.transformIgnorePatterns.length === 0\n  ) {\n    return undefined;\n  }\n\n  return new RegExp(config.transformIgnorePatterns.join('|'));\n};\n\nconst calcTransformRegExp = config => {\n  if (!config.transform.length) {\n    return undefined;\n  }\n\n  const transformRegexp = [];\n\n  for (let i = 0; i < config.transform.length; i++) {\n    transformRegexp.push([\n      new RegExp(config.transform[i][0]),\n      config.transform[i][1],\n      config.transform[i][2]\n    ]);\n  }\n\n  return transformRegexp;\n};\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nfunction assertSyncTransformer(transformer, name) {\n  invariant(name);\n  invariant(\n    typeof transformer.process === 'function',\n    (0, _runtimeErrorsAndWarnings.makeInvalidSyncTransformerError)(name)\n  );\n}\n\nasync function createScriptTransformer(config, cacheFS = new Map()) {\n  const transformer = new ScriptTransformer(config, cacheFS);\n  await transformer.loadTransformers();\n  return transformer;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}